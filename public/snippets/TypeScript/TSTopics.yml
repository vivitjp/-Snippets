---
#-------------------------------
# TypeScript
#-------------------------------
- ENTRY:
  CATEGORY: TypeScript

- ENTRY:
  EXPLAIN: TSC
  BODY: |
    ■ TypeScript コンパイラ (TSC) のインストール

      > npm install -g typescript

    ■ コマンド & オプション

      tsc -v                            // バージョン確認
      tsc ファイル名.ts                  // コンパイル実行、出力は同ディレクトリにファイル名.js
      tsc ファイル名.ts --watch          // 変更監視モードでコンパイル実行
      tsc ファイル名.ts --noEmit         // コンパイルのみ実行、出力ファイルは生成しない
      tsc --init                        // tsconfig.json 初期化
      tsc --project tsconfig.json       // 指定した tsconfig.json でコンパイル実行
      tsc --build                       // プロジェクトのビルド
      tsc --build --clean               // ビルド成果物のクリーン
      tsc --help                        // ヘルプ表示

- ENTRY:
  EXPLAIN: TSC メモリ対策
  BODY: |
    ■ tsc 実行時のメモリ関連 Node/V8 オプションと、メモリ負荷を下げる TypeScript 側の設定

    ■ Node/V8 のメモリ上限を増やす（推奨）

    ・直接 node で tsc を起動（単位は MB。例は 4GB）

      node --max-old-space-size=4096 ./node_modules/typescript/bin/tsc -p 

        開発・小規模プロジェクト: 512MB ～ 1024MB
        中規模プロジェクト: 2048MB
        大規模アプリ / 多数の依存: 4096MB
        大規模モノレポ / 並列ビルド: 8192MB〜16384MB（ホストの物理RAMに依存）

    ・npm スクリプト例（package.json）:

      "scripts": {
        "build:ts": "node --max-old-space-size=4096 ./node_modules/typescript/bin/tsc -p tsconfig.json"
        "build:ts": "cross-env NODE_OPTIONS=--max-old-space-size=4096 npx tsc -p tsconfig.json"   // cross-env 使用例
      }

    ・ぷらっとフォーム別の実行例:

      NODE_OPTIONS=--max-old-space-size=4096 npx tsc -p             環境変数で指定（POSIX）:
      $env:NODE_OPTIONS="--max-old-space-size=4096"; npx tsc -p     Windows（PowerShell）:
      set NODE_OPTIONS=--max-old-space-size=4096 && npx tsc -p      Windows（cmd.exe）:

    ■ GC / プロファイリング用の Node フラグ（トラブルシュート時）

    ・ガベージコレクション追跡:

      node --trace_gc --max-old-space-size=4096 ./node_modules/typescript/bin/tsc -p 

    ・メモリスナップショット / デバッガ:

      node --inspect --max-old-space-size=4096 ./node_modules/typescript/bin/tsc -p 

    ■ TypeScript 側でメモリ負荷を下げる設定（tsconfig.json）

      {
        "compilerOptions": {
          "skipLibCheck": true,                  // 外部型のチェックをスキップしてメモリ/時間削減
          "incremental": true,                   // 増分ビルドで再コンパイルを減らす        
          "tsBuildInfoFile": ".tsbuildinfo",     // 増分ビルド情報の保存先ファイル 
          "composite": false                     // 大規模なら true + project references で分割ビルドにする           
        }
      }

    ■ 運用上の追加Tips

      ・CI ではまず npx tsc --noEmit（型チェック）を走らせ、必要時にメモリ増加を適用
      ・大規模リポジトリはプロジェクト参照でビルドを分割する（メモリ節約＋並列化）
      ・必要以上に大きなユーティリティ型や巨大な型演算はコンパイラ負荷を上げるので見直す
      ・メモリ不足エラー（OOM）が出る場合はまず --max-old-space-size を増やし、併せて skipLibCheck を有効化

- ENTRY:
  EXPLAIN: TSC Tips
  BODY: |
    【strict: true】 モードを有効にして型品質を担保

    【npx tsc --noEmit】 CIでは型チェックのみ実行、ビルドとは別に型チェックを走らせる（早く失敗を検知）

    【incremental: true】 .tsbuildinfo により再ビルドが高速化、開発時は増分コンパイル

    【composite: true】 references 大型リポジトリはプロジェクト参照を使い、並列/段階的ビルド

    【skipLibCheck: true】 外部型のチェック高速化、サードパーティ型で問題なければ設定型チェックを早める

    【isolatedModules: true】 Babel 等でトランスパイルするなら有効にして単一ファイル単位の変換に適合させる

    【declaration/declarationMap: true】 ライブラリならエクスポート用型定義を出すを使い、emitDeclarationOnly を検討

    【モジュール互換の問題対処】 esModuleInterop: true と allowSyntheticDefaultImports: true で import の互換性を改善

    【パスエイリアス管理】 baseUrl + paths を使い、ビルドツール（webpack/vite）側でも同じ alias を設定

    【型のみのインポートを明示】 不要な実行時の依存を避けるため import type { Foo } from 'x' を使う

    【漸進的マイグレーション】 allowJs: true + checkJs: false で JS を併用しつつ段階的に TS 化

    【実行時の JSON 取り込み】 resolveJsonModule: true を使うと import data from './a.json' が型付きで可能

    【パフォーマンス診断】 ビルドプロファイルは tsc --diagnostics / tsc --extendedDiagnostics で解析

    【エディタ/tsserver の負荷対策】 大規模プロジェクトでは exclude を適切に設定し、typeRoots を整理する

    【型のコスト対策】 巨大な型演算はコンパイル遅延の原因、冗長なユーティリティ型や非常に深いネストを見直す

    【型方針をドキュメント化】 tsconfig.json のコメントやリポジトリ README に推奨ルール（noImplicitAny など）を書いて統一

- ENTRY:
  EXPLAIN: Suggestions
  BODY: |
    ■ typescript.Suggest

    "typescript.suggest.autoImports": true              // 自動インポート候補を表示
    "typescript.suggest.completeFunctionCalls": true    // 関数呼び出しの括弧と引数を自動補
    "typescript.suggest.enabled": true                  // 全般的なコード補完を有効化
    "typescript.suggest.includeCompletionsForModuleExports": true // モジュールのエクスポートも補完候補に含める
    "typescript.suggest.includeCompletionsWithInsertText": true    // 補完テキストを含む候補を表示
    "typescript.suggest.names": true                    // 変数名の候補を表示
    "typescript.suggest.paths": true                    // パス補完を有効化

    ■ typescript.Preferences

    "typescript.preferences.importModuleSpecifier": "relative"  // 相対パスでインポートを生成
    "typescript.preferences.quoteStyle": "single"               // シングルクォートで囲む
    "typescript.preferences.includeCompletionsForImportStatements": true // インポート文の補完を含める
    "typescript.preferences.includeCompletionsWithSnippetText": true      // スニペットテキストを含む補完を有効化
    "typescript.preferences.autoImportFileExcludePatterns": { "**/node_modules/**": true } // 自動インポートから node_modules を除外

    ■ typescript.CodeFix

    "typescript.codeFix.autoFixOnSave": true               // 保存時に自動修正を適用
    "typescript.codeFix.enableBetterFunctionCompletion": true // 関数補完の改善を有効化
    "typescript.codeFix.enableImportFixes": true           // インポート修正を有効化
    "typescript.codeFix.enableRefactorings": true          // リファクタリングを有効化
    "typescript.codeFix.enableSuggestions": true           // コード修正の提案を有効化

    ■ typescript.format

    "typescript.format.enable": true                       // フォーマット機能を有効化
    "typescript.format.insertSpaceAfterCommaDelimiter": true // カンマの後にスペースを挿入
    "typescript.format.placeOpenBraceOnNewLineForControlBlocks": false // 制御ブロックの開き波括弧を新しい行に配置しない
    "typescript.format.semicolons": "insert"              // セミコロンを自動挿入
    "typescript.format.trimTrailingWhitespace": true       // 行末の空白を削除

    ■ typescript.preferences.organizeImports
    "typescript.preferences.organizeImports.sortImports": true        // インポートをソート
    "typescript.preferences.organizeImports.removeUnusedImports": true // 未使用のインポートを削除

- ENTRY:
  EXPLAIN: トランスパイル
  BODY: |
    ■ トランスパイルとは

    ・TypeScript (TS) や JSX などの高レベル言語を、ブラウザや Node.js で実行可能な JavaScript に変換するプロセス
    ・主な目的: 最新の言語機能を古い環境で動作させる、型チェック後のコード生成
    ・コンパイルとの違い: コンパイルは低レベル言語 (機械語) への変換、トランスパイルは同レベル言語間の変換

    ■ 選び方のポイント

    ・速度重視: esbuild, SWC
    ・型安全重視: tsc, Next.js
    ・柔軟性重視: Babel
    ・フレームワーク使用: Next.js, Vite
    ・大規模プロジェクト: 高速ツール + tsc 型チェックの組み合わせ

    ■ Tips

    ・開発時は高速ツール、本番ビルド時は安定ツール
    ・ソースマップを有効にしてデバッグしやすくする
    ・CI/CD で型チェックを別途実行 (esbuild 等では型チェックされない)

- ENTRY:
  EXPLAIN: トランスパイラ
  BODY: |
    ■ tsc (TypeScript Compiler)

    ・TypeScript 公式コンパイラ
    ・機能: TS → JS 変換、ソースマップ生成
    ・バンドル機能: なし
    ・型チェック: あり
    ・利点: 標準的、設定豊富 (tsconfig.json)
    ・欠点: 遅い (大規模プロジェクトで数秒〜数分)、
    ・使用例: スタンドアロン、ビルドスクリプト

    ■ Babel

    ・JS トランスパイラ、プラグイン中心
    ・機能: JS → 互換 JS、TS サポート (プラグイン)、React 対応
    ・バンドル機能: 限定的
    ・型チェック: なし
    ・利点: 柔軟性高、プラグイン豊富、ブラウザ互換性調整
    ・欠点: 遅い、設定が複雑、バンドル機能が限定的
    ・使用例: カスタム変換、ライブラリ開発

    ・ babel のバンドル機能が限定的な理由
      ・Babel は主にコード変換に特化しており、バンドルは専門外
      ・バンドラ (webpack, Rollup など) と組み合わせて使用
      ・Babel 自体のバンドル機能は基本的なものであり、最適化や依存関係管理には限界あり

    ■ Next.js

    ・React フレームワーク、内部で tsc や SWC を使用
    ・機能: TS/JSX → JS、SSR/SSG 対応、自動最適化
    ・バンドル機能: 内蔵 (webpack ベース)
    ・型チェック: あり (tsc ベース)
    ・利点: フルスタック開発、Vercel 統合
    ・欠点: 設定が複雑、ビルド時間が長い場合あり
    ・使用例: Web アプリ開発

    ■ Vite

    ・ビルドツール、開発時は esbuild、本番時は Rollup
    ・機能: 高速 HMR、TS サポート、プラグイン豊富
    ・バンドル機能: 内蔵 (Rollup ベース)
    ・型チェック: なし (tsc と組み合わせ推奨)
    ・利点: 開発速度が速い (esbuild 採用)
    ・欠点: 本番ビルドは Rollup のためやや遅い
    ・使用例: モダン Web 開発

    ■ esbuild

    ・Go 言語製トランスパイラ
    ・機能: TS/JSX → JS、バンドル、ミニファイ
    ・バンドル機能: 内蔵
    ・型チェック: なし (tsc と組み合わせ推奨)
    ・利点: 非常に速い (他のツールの 10-100 倍)、シンプル
    ・欠点: 一部機能未成熟
    ・使用例: 高速ビルド、Vite の開発サーバー

    ■ SWC (Speedy Web Compiler)

    ・Rust 製トランスパイラ
    ・機能: TS/JSX → JS、バンドル、ミニファイ
    ・バンドル機能: 内蔵
    ・型チェック: なし (tsc と組み合わせ推奨)
    ・利点: 高速 (esbuild 並み)、Next.js 標準採用
    ・欠点: 設定が複雑、一部 Babel プラグイン未対応
    ・使用例: Next.js ビルド、Rust エコシステム

- ENTRY:
  EXPLAIN: モジュールバンドラ
  BODY: |
    ■ バンドルとは?

      ・複数のモジュールやファイルを1つのファイルにまとめるプロセス
      ・目的: ネットワーク要求の削減、依存関係の管理、最適化

    ■ モジュールバンドラの選び方ポイント

      ・プロジェクト規模: 小規模は Parcel、大規模は WebPack
      ・パフォーマンス: esbuild や SWC ベースのツール
      ・設定の柔軟性: WebPack は高度なカスタマイズが可能
      ・エコシステム: プラグインやローダーの豊富さ
      ・フレームワーク統合: Next.js や Vite など

    ■ WebPack

    ・モジュールバンドラ、依存関係解析と最適化に特化
    ・機能: モジュール結合、コード分割、アセット管理
    ・利点: 柔軟な設定、多数のローダー/プラグイン
    ・欠点: 設定が複雑、学習コスト高い
    ・使用例: 大規模アプリケーションのビルド

    ・基本的な TypeScript 対応設定例 (webpack.config.js):

      config.module.rules = [
        {
          test: /\.tsx?$/,
          use: 'ts-loader',
          exclude: /node_modules/,
        },
      ];

    ■ Rollup

    ・モジュールバンドラ、ライブラリ向けに最適化
    ・機能: モジュール結合、ツリーシェイキング、プラグイン豊富
    ・利点: 小さなバンドルサイズ、ESM サポート
    ・欠点: 設定が複雑、大規模アプリには不向き
    ・使用例: ライブラリ開発、ESM 出力

    ・基本的な設定例 (rollup.config.js):

      import typescript from '@rollup/plugin-typescript';

      export default {
        input: 'src/index.ts',
        output: {
          file: 'dist/bundle.js',
          format: 'cjs',
        },
        plugins: [typescript()],
      };

    ■ Parcel

    ・ゼロコンフィグバンドラ、初心者向け
    ・機能: 自動依存解析、ホットリロード、アセット管理
    ・利点: 設定不要、使いやすい
    ・欠点: 大規模アプリには不向き、カスタマイズ性低い
    ・使用例: 小規模プロジェクト、プロトタイピング

    ・基本的な設定例 (package.json):

      {
        "scripts": {
          "build": "parcel build src/index.html",
          "start": "parcel src/index.html"
        }
      }

- ENTRY:
  EXPLAIN: ビルド・オプション
  BODY: |
    ■ TreeShaking

    ・未使用コードを削除し、バンドルサイズを削減
    ・Rollup や WebPack でサポート
    ・ESM モジュールを使用することで効果的に機能

     ・WebPack での設定例: production モードではデフォルトで有効

      module.exports = {
        mode: 'production',
        optimization: {
          usedExports: true,            // Tree Shaking を有効化
        },
      };

      ※ Nextjs や Vite ではデフォルトで有効
        無効にしたい場合: Nextjs: next.config.js で optimization.usedExports = false

    ■ Code Splitting

    ・コードを複数のチャンクに分割し、必要な部分だけをロード
    ・WebPack の dynamic import() で実現可能
    ・初期ロード時間の短縮に有効

    ■ Minification

    ・コードを圧縮し、ファイルサイズを削減
    ・Terser や UglifyJS などのツールを使用
    ・可読性は低下するが、パフォーマンス向上に寄与

    ・Terser を WebPack で使用する例:

      const TerserPlugin = require('terser-webpack-plugin');

      module.exports = {
        optimization: {
          minimize: true,
          minimizer: [new TerserPlugin()],
        },
      };

      ※ Nextjs や Vite ではデフォルトで有効
      無効にしたい場合: Nextjs: next.config.js で optimization.minimize = false

    ■ Source Maps

    ・圧縮コードと元のソースコードを対応付けるマッピングファイル
    ・デバッグ時に役立つ
    ・ビルドツールで自動生成可能

- ENTRY:
  EXPLAIN: TS-loader
  BODY: |
    ■ 概要

    ・TypeScript ファイルを WebPack で処理するためのローダー
    ・TypeScript コンパイラ (tsc) で TS を JS に変換、WebPack のバンドルプロセスに統合

    ■ 主な機能
    ・TypeScript ファイルのコンパイル
    ・ソースマップの生成
    ・WebPack のモジュールシステムとの統合

    ■ インストール

      npm install --save-dev ts-loader typescript

    ■ 使い方(webpack.config.js)

      module.exports = {
        entry: './src/index.ts',
        module: {
          rules: [
            {
              test: /\.tsx?$/,
              use: 'ts-loader',
              exclude: /node_modules/,
            },
          ],
        },
        resolve: {
          extensions: ['.tsx', '.ts', '.js'],
        },
        output: {
          filename: 'bundle.js',

#-------------------------------
# Tips
#-------------------------------

- ENTRY:
  CATEGORY: Tips

#-------------------------------
# ENUM
#-------------------------------
- ENTRY:
  EXPLAIN: |
    デコレータ: 型チェック無視 @ts-ignore など
  BODY: |
    // @ts-ignore
    const foo = 1

    // prettier-ignore
    const foo = {a: 1, b: { c: 2 }, d: 3, e: 4, f: 5, g: 6}  // 1行にまとめる

    // eslint-disable-next-line
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const foo = 1

#-------------------------------
# ENUM
#-------------------------------
- ENTRY:
  EXPLAIN: makeEnum:const配列からenum(Object)作成
  BODY: |
    function makeEnum<T extends readonly string[]>(配列: T) {
        return 配列.filter(Boolean).reduce(
        (acc, cur) => ({ ...acc, [cur]: cur }),
        //{} as { [key in typeof 配列[number]]: string;}
        {} as Record<typeof 配列[number],string>
        );
    }

    const Enum型式 = makeEnum(["A", "B", "C", "D"] as const);
    => Enum型式: { A: string; B: string; C: string; D: string; }

#-------------------------------
# union
#-------------------------------
- ENTRY:
  EXPLAIN: Object/Array -> Union型
  BODY: |
    ■ Object -> Union型

    const person = {
      a: "Name",
      b: "Address",
    } as const

    type Person = typeof person[keyof typeof person]  

    結果: "Name" | "Address"

    ■ Array -> Union型

    const person = [ "Name", "Address" ] as const
    type Person = (typeof person)[number]

    結果: "Name" | "Address"

#-------------------------------
# Switch
#-------------------------------
- ENTRY:
  EXPLAIN: switchでneverチェック
  BODY: |
    export const func = (name: Person) => {
      switch (name) {
        case "Name":
          break
        case "Address":
          break
        default: {
          const _exhaustiveCheck: never = name
          throw new Error(`Switch Error: ${name}`)
        }
      }
    }

#-------------------------------
# 判別可能なUnion型
#-------------------------------
- ENTRY:
  EXPLAIN: 判別可能なUnion型
  BODY: |
    interface Square {
      kind: "square"  <-- 判別子
      size: number
    }

    interface Rectangle {
      kind: "rectangle"  <-- 判別子
      width: number
      height: number
    }

    type Shape = Square | Rectangle

    const area = (s: Shape) => {
      switch (s.kind) {  <-- 判別子
        case "square":    return s.size * s.size
        case "rectangle": return s.width * s.height
        default:          return null
      }
    }

#-------------------------------
# 関数のオーバーロード
#-------------------------------
- ENTRY:
  EXPLAIN: 関数のオーバーロード
  BODY: |
    interface Overloaded {
      (foo: string): string
      (foo: number): number
    }

    function stringOrNumber(foo: number): number
    function stringOrNumber(foo: string): string
    function stringOrNumber(foo: any): any {
      if (typeof foo === "number") {
        return foo * foo
      } else if (typeof foo === "string") {
        return `Hello ${foo}`
      }
    }

    // 注意 Arrow 関数はオーバーロードできない

#-------------------------------
# 構造的部分型とその例外: Freshness
#-------------------------------
- ENTRY:
  EXPLAIN: 構造的部分型の例外
  BODY: |
    const foo = { x: 1, y: 2, z: 3 }
    const onlyX: { x: number } = foo //OK

    const func1 = ({ name }: { name: string }) => {
      console.log(name)
    }
    const func2 = ({ name, ...args }: { name: string; [key: string]: unknown }) => {
      console.log(name)
    }

    var person = { name: "matt", job: "officer" }
    func1(person) //構造的部分型 OK
    func1({ name: "matt", job: "officer" }) //構造的部分型の例外 Object Literal: NG
    func2({ name: "matt", job: "officer" }) //OK

#-------------------------------
# 型ガード(in)
#-------------------------------
- ENTRY:
  EXPLAIN: 型ガード(in)
  BODY: |
    interface A { x: number }
    interface B { y: string }
    function typeGuardIn(q: A | B) {
      if ("x" in q) console.log(q.x)
      else console.log(q.y)
    }

#-------------------------------
# 型ガード
#-------------------------------
- ENTRY:
  EXPLAIN: 型ガード
  BODY: |
    ■ ユーザ定義型

    "is A" は「戻り値側の型述語（type predicate）」

    ・関数が true を返したときに呼び出し元で arg が A と見なされる
    ・関数が false を返したときに呼び出し元で arg が A ではないと見なされる

      interface A { a: number; common: string }
      interface B { b: number; common: string }

      function isFoo(arg: any): arg is A {  // 関数名 isXxxx で定義
        return arg.a !== undefined
      }

      if (isFoo(x)) {
        // ここでは x は A として扱える（型狭窄）
        console.log(x.a)
      } else {
        // ここでは x は A ではない
      }

    ■ 型ガード(文字列)

    const isString = (value: unknown): value is string => {
      return typeof value === "string" && value !== null
    }

    ■ 型ガード(文字列配列)

    const isStringArray = (value: unknown): value is string[] => {
      return (
        typeof value === "object" &&
        value !== null &&
        Array.isArray(value) &&
        !value.some((v) => !isString(v))
      )
    }

    ■ 型ガード(object)

    type WouldBe<T> = { [P in keyof T]?: unknown }  // 全属性 "Optional"、全値 unknown型

    const isTypeObject = <T extends Record<string, unknown>>(
      value: unknown
    ): value is WouldBe<T> => typeof value === "object" && value !== null

    ■ 型ガード(任意の型)

    type Foo = {
      a: string
      b: number
    }

    const isFoo = (value: unknown): value is Foo =>
      isTypeObject<Foo>(value) &&
      typeof value.a === "string" &&
      typeof value.b === "number"

#-------------------------------
# Literal 型 推論
#-------------------------------
- ENTRY:
  EXPLAIN: Literal型推論
  BODY: |
    function func(A: "foo") {}

    const objA = { A: "foo" }
    func(objA.A)                        //NG: objA.A = string

    const objB = { B: "foo" as const }
    func(objB.B)                        //OK

    const objC = { C: "foo" } as const
    func(objC.C)                        //OK

    const objD: { [key: string]: "foo" } = {
      D: "foo",
    }
    func(objD.D)                        //OK

#-------------------------------
# ReadOnly
#-------------------------------
- ENTRY:
  EXPLAIN: ReadonlyArray<> 読み取り専用型
  BODY: |
    const foo: number[] = [1, 2, 3]
    foo.push(4) // OK

    const fooRO: ReadonlyArray<number> = [1, 2, 3]
    fooRO.push(4) // NG

#-------------------------------
# Utility Partial
#-------------------------------
- ENTRY:
  EXPLAIN: Record, Partial を用いたObject型生成の比較
  BODY: |
    const obj = {"A": 1, "B": 2, "C": 3};

    ■ 意図する挙動：Partial<T>

    const objA: Partial<Record<keyof typeof obj, number>> = {
        A: 1,
        B: 2,
        //C: 3,
    }

    ■ 意図とは異なる挙動：Record<K, T>

    const objB: Record<Partial<keyof typeof obj>, number> = {
        A: 1,
        B: 2,
        //C: 3,  <-- NG
    }

#-------------------------------
# 排他的 OR
#-------------------------------
- ENTRY:
  EXPLAIN: |
    排他的OR -> 参照: 型(AND/OR)
  BODY: |
    type P = { name:string, age: number }
    type A = { city:string, zip: string }

    ■ OR[ | ] 🛑どちらか一方を満たす(排他的ORではないので両方でもOK)

    const OK: P | A = { name: "Eve", age: 18 }                          // ⭕ P を満たす
    const OK: P | A = { city: "Paris", zip:"03" }                       // ⭕ A を満たす
    const OK: P | A = { name: "Eve", age: 18, city: "Paris" }           // ⭕ 少なくとも P を満たす
    const OK: P | A = { name: "Eve", age: 18, city: "Paris", zip:"03" } // ⭕ 両方を満たす
    const NG: P | A = { name: "Eve", city:"Eve" }                       // ❌ 混用
    const NG: P | A = { city: "Paris", age: 18 }                        // ❌ 混用

    ■ XOR 🛑排他的OR(Utility活用)

    type XOR<T> = { [X in keyof T]?: never; }
    type XP = P & XOR<A>
    type XA = A & XOR<P>

    const OK: XP | XA = { name: "Eve", age: 18 }                          // ⭕ P を満たす
    const OK: XP | XA = { city: "Paris", zip:"03" }                       // ⭕ A を満たす
    const NG: XP | XA = { name: "Eve", age: 18, city: "Paris" }           // ❌ 排他的 OR
    const NG: XP | XA = { name: "Eve", age: 18, city: "Paris", zip:"03" } // ❌ 排他的 OR
    const NG: XP | XA = { name: "Eve", city:"Eve" }                       // ❌ 混用
    const NG: XP | XA = { city: "Paris", age: 18 }                        // ❌ 混用

#-------------------------------
# Literal Join
#-------------------------------
- ENTRY:
  EXPLAIN: ReactHookForm での複層オブジェクト対応
  BODY: |
    ■ ReactHookFormでのKeyが複数Keyの合成になった場合の対処

    type Phases = "groupA" | "groupB";
    type Attrs = "name" | "age";

    const defaultData = {
      name: "Smith",
      age: 1,
    };
    type DefaultDataHidden = typeof defaultData;

    type Data = Partial<Record<`${Phases}.${Attrs}`, string>>;
    const data: Data = {
      "groupA.name": "John",
      "groupA.age": "Tokyo",
      "groupB.name": "Jim",
      "groupB.age": "LA",
    };

    type ErrorDataHidden = Record<
      Phases,
      Record<keyof DefaultDataHidden, { message: string }>
    >;

    const errorData: ErrorDataHidden = {
      groupA: {
        name: { message: "Must be String" },
        age: { message: "Must be Number" },
      },
      groupB: {
        name: { message: "Must be String" },
        age: { message: "Must be Number" },
      },
    };

    //-----------------------------------------------
    // Data
    //-----------------------------------------------
    {
      type DefaultData = typeof defaultData;
      type DefaultDataKeys = keyof DefaultData;

      type DataKeys = keyof typeof data;
      const phases = ["groupA", "groupB"];

      phases.forEach((phase) => {
        const keyName = "name" as DefaultDataKeys;
        const res1 = data?.[`${phase}.${keyName}` as DataKeys] || "Unknown";
        console.log(keyName, res1);
      });
    }

    //-----------------------------------------------
    // Error
    //-----------------------------------------------
    {
      type DefaultData = typeof defaultData;
      const dataKeys = Object.keys(data);

      dataKeys.forEach((key) => {
        const [phase, attr] = key.split(".");
        const res1 =
          errorData?.[phase as Phases]?.[attr as keyof DefaultData]?.message ||
          "Unknown";
        console.log(phase, attr, res1);
      });
    }
