---
#-------------------------------
# TypeScript 2024
#-------------------------------
- ENTRY:
  CATEGORY: åŸºç¤

- ENTRY:
  EXPLAIN: å‹(ãƒ“ãƒ«ãƒˆã‚¤ãƒ³å‹)
  BODY: |
    â–  ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹(7ç¨®é¡)

    type Primitive = number | string | boolean | bigint | symbol | undefined | null

    b:boolean   = true;                      // Booleanå‹
    s:string    = "abc";                     // æ–‡å­—åˆ—å‹
    n:number    = 1;                         // æ•°å‹
    b:bigint    = 10n;                       // BigIntå‹(ES2020)
    y:symbol    = Symbol();                  // ã‚·ãƒ³ãƒœãƒ«å‹
    u:undefined = undefined;                 // undefinedå‹
    l:null      = null;                      // nullå‹

    â–  çµ„ã¿è¾¼ã¿å‹(4ç¨®é¡)

    type Builtin = Primitive | Function | Date | Error | RegExp

    const f: Function = ()=>{}                // é–¢æ•°å‹
    const f: Function = ()=>void              // é–¢æ•°å‹(void)
    const f: (...args:any[])=>any             // é–¢æ•°å‹(å¼•æ•°/æˆ»ã‚Šå€¤æŒ‡å®š)

    type Func = (a:number)=>string            // ã‚«ã‚¹ã‚¿ãƒ å‹
    type FuncVoid = (a:number)=>void          // ã‚«ã‚¹ã‚¿ãƒ å‹(void)

    const d: Date = new Date();               // æ—¥ä»˜å‹
    const d: Date = new Date("2024-01-01");   // æ—¥ä»˜å‹(new)

    const e: Error = new Error("error");      // ã‚¨ãƒ©ãƒ¼å‹
    const e: Error = new TypeError("type");   // å‹ã‚¨ãƒ©ãƒ¼å‹

    const r: RegExp = /abc/;                  // æ­£è¦è¡¨ç¾å‹
    const r: RegExp = new RegExp("abc");      // æ­£è¦è¡¨ç¾å‹(new)

    â–  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹

    a:object={}                              // ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ä»¥å¤–: {},[],()=>{}
    b:Object={}                              // null,undefinedä»¥å¤–å…¨éƒ¨:å¿Œé¿!
    c:{} = {}                                // â‰’Object

    â–  any å‹

    const a:any = 10;
    const i:number = a;                      // (å±é™º)ä»£å…¥OK i = any å‹!
    const s:string = a;                      // (å±é™º)ä»£å…¥OK s = any å‹!
    const o:object = a;                      // (å±é™º)ä»£å…¥OK o = any å‹!

    â–  unknown å‹

    const a:unknown = 10;
    const i:number = a;                      // (å®‰å…¨)Error ä»£å…¥ä¸å¯
    const s:string = a;                      // (å®‰å…¨)Error ä»£å…¥ä¸å¯
    const o:object = a;                      // (å®‰å…¨)Error ä»£å…¥ä¸å¯ 

    if(typeof(a)==="string")                 // å‹Check:v5.3
      const s:string = a;                    // (å®‰å…¨)ä»£å…¥å¯

    â–  never å‹                                // Genericã§å¤šç”¨ã•ã‚Œã‚‹ 

    type A={ a:"A" }
    type B={ a:"B" }

    const f=(props:A|B)=>{
      switch (props.a) {
        case "A": return ...
        case "B": return ...
        default: let _ng:never = props       // è­¦å‘Š

- ENTRY:
  EXPLAIN: Union & Intersection
  BODY: |
    type P = { name:string, age: number }
    type A = { city:string, zip: string }

    â–  AND[ & ] ä¸¡æ–¹ã‚’æº€ãŸã™

    const NG: P & A = { name: "Eve", age: 18 }                          // âŒ ä¸è¶³
    const NG: P & A = { city: "Paris", zip:"03" }                       // âŒ ä¸è¶³
    const NG: P & A = { name: "Eve", age: 18, city: "Paris" }           // âŒ ä¸è¶³
    const OK: P & A = { name: "Eve", age: 18, city: "Paris", zip:"03" } // â­•ä¸¡æ–¹ã‚’æº€ãŸã™

    â–  OR[ | ] ã©ã¡ã‚‰ã‹ä¸€æ–¹ã‚’æº€ãŸã™(æ’ä»–çš„ORã§ã¯ãªã„ã®ã§ä¸¡æ–¹ã§ã‚‚OK)

    const OK: P | A = { name: "Eve", age: 18 }                          // â­• P ã‚’æº€ãŸã™
    const OK: P | A = { city: "Paris", zip:"03" }                       // â­• A ã‚’æº€ãŸã™
    const OK: P | A = { name: "Eve", age: 18, city: "Paris" }           // â­• å°‘ãªãã¨ã‚‚ P ã‚’æº€ãŸã™
    const OK: P | A = { name: "Eve", age: 18, city: "Paris", zip:"03" } // â­• ä¸¡æ–¹ã‚’æº€ãŸã™
    const NG: P | A = { name: "Eve", city:"Eve" }                       // âŒ æ··ç”¨
    const NG: P | A = { city: "Paris", age: 18 }                        // âŒ æ··ç”¨

    â–  XOR æ’ä»–çš„OR(Utilityæ´»ç”¨)

    type XOR<T> = { [X in keyof T]?: never | undefined; }

    type XP = P & XOR<A>
    type XA = A & XOR<P>

    const OK: XP | XA = { name: "Eve", age: 18 }                          // â­• P ã‚’æº€ãŸã™
    const OK: XP | XA = { city: "Paris", zip:"03" }                       // â­• A ã‚’æº€ãŸã™
    const NG: XP | XA = { name: "Eve", age: 18, city: "Paris" }           // âŒ æ’ä»–çš„ OR
    const NG: XP | XA = { name: "Eve", age: 18, city: "Paris", zip:"03" } // âŒ æ’ä»–çš„ OR
    const NG: XP | XA = { name: "Eve", city:"Eve" }                       // âŒ æ··ç”¨
    const NG: XP | XA = { city: "Paris", age: 18 }                        // âŒ æ··ç”¨

- ENTRY:
  EXPLAIN: å®šæ•°, widening & narrowing
  BODY: |
    â–  å®šæ•°åŒ– (const)

    ãƒ»const å®£è¨€ã¯ãƒªãƒ†ãƒ©ãƒ«å‹ã¨ã—ã¦æ¨è«–ã•ã‚Œã‚‹
    ãƒ»let å®£è¨€ã¯ä¸€èˆ¬çš„ãªå‹ã¨ã—ã¦æ¨è«–ã•ã‚Œã‚‹

    â–  widening & narrowing

    ãƒ»Widening: å‹ãŒä¸€èˆ¬åŒ–ã•ã‚Œã‚‹ (let å®£è¨€ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£)
    ãƒ»Narrowing: å‹ãŒç‰¹å®šåŒ–ã•ã‚Œã‚‹ (const å®£è¨€ã‚„ as const ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

    â–  ä¾‹

    let a = 1                                // a:numberå‹
    const a = 1                              // a:1å‹
    const a = {a:1}                          // widening:  {a:number}å‹
    const b = {a:1} as const                 // narrowing: {readonly a:1}å‹
    type A = { readonly a:number }           // èª­å–å°‚ç”¨

- ENTRY:
  EXPLAIN: interface vs type
  BODY: |
    â–  interface

    ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®æ§‹æ–‡ã§
    ãƒ»æ‹¡å¼µã‚„ãƒãƒ¼ã‚¸ãŒå¯èƒ½
    ãƒ»å‹ã®æ‹¡å¼µã«æ°—ã¥ã‹ãªã„ãƒªã‚¹ã‚¯ã‚ã‚Š

    interface A { a:number, x?:string }
    interface B { b:number }                 // {b}
    interface B { c:number }                 // ãƒãƒ¼ã‚¸{b,c} åŒã˜åå‰ã§ã‚‚ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„
    interface C extends A, B {}              // {}å¿…è¦
    => const c:C ={ a:1, b:2, c:3 }

    â–  type

    ãƒ»å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®æ§‹æ–‡
    ãƒ»ã‚ˆã‚ŠæŸ”è»Ÿã«å‹ã‚’å®šç¾©ã§ãã‚‹
    ãƒ»æ‹¡å¼µã‚„ãƒãƒ¼ã‚¸ã¯ä¸å¯

    type A = { a: number, x?:string }
    type B = A & { b: number }               // intersect
    const b:B = { a: 1, b: 2 }               // å‹é©ç”¨

- ENTRY:
  EXPLAIN: keyof (å‹å–å¾—)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã‚’ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã¨ã—ã¦å–å¾—ã™ã‚‹ãŸã‚ã®å‹æ¼”ç®—å­
    ãƒ»å‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã‚’å‹•çš„ã«å–å¾—ã—ã¦æ“ä½œã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    type Keys = keyof ObjectType

    â–  ä¾‹

    type Person = {
      name: string;
      age: number;
      city: string;
    }

    type PersonKeys = keyof Person          // "name" | "age" | "city"
    const key: PersonKeys = "name"          // æœ‰åŠ¹ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å

    â–  é…åˆ—ã‹ã‚‰å‹

    const x = ["A", "B", "C"] as const

    type Keys = (typeof x)[number]           // "A"|"B"|"C"
    type Y = typeof x[0|1]                   // "A" | "B"

    â–  é…åˆ—ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹

    const keys = ["A", "B", "C"] as const 
    type Keys = { [K in typeof keys[number]] : number }

    const values:Keys = { "A": 1, "B": 2, "C": 3 }

    â–  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‹(constç„¡)

    const o = { a: "A", b: "B" }             // constç„¡ -> widening

    type X = typeof o                        // {a:number;b:number;}
    type K = keyof X                         // "a" | "b"
    type Y = keyof typeof o                  // "a" | "b"
    type B = (typeof o)[keyof typeof o]      // string <= Widening

    â–  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‹(constæœ‰)

    const o = { a: "A", b: "B" } as const    // constæœ‰ -> narrowing

    type X = typeof o                        // { readonly a:"A"; readonly b:"B"; } â­•
    type K = keyof X                         // "a" | "b"
    type Y = keyof typeof o                  // "a" | "b"
    type B = (typeof o)[keyof typeof o]      // "A" | "B"

    â–  é…åˆ—ã‹ã‚‰ENUMä½œæˆ

    const array = ["A", "B", "C", "D"] as const

    function makeEnum<T extends readonly string[]>(é…åˆ—: T) {
      return é…åˆ—.filter(Boolean).reduce(
      (acc, cur) => ({ ...acc, [cur]: cur }),
      {} as {[key in typeof é…åˆ—[number]]: string}
      );
    }

    const ENUM = makeEnum(array);
    çµæœ: {
      A: string; <-- ğŸ”´ widening
      B: string;
      C: string;
      D: string;
    }

    function makeEnumAsConst<T extends readonly string[]>(é…åˆ—: T) {
        return é…åˆ—.filter(Boolean).reduce(
        (acc, cur) => ({ ...acc, [cur]: cur }),
        {} as { readonly [key in typeof é…åˆ—[number]]: key} <-- ğŸ”µ readonly conståŒ–
        );
    }

    const ENUM2 = makeEnumAsConst(array);
    çµæœ: {
      readonly A: "A";
      readonly B: "B";
      readonly C: "C";
      readonly D: "D";
    }

- ENTRY:
  EXPLAIN: MappedType (ãƒãƒƒãƒ—å‹)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»æ—¢å­˜ã®å‹ã‚’åŸºã«æ–°ã—ã„å‹ã‚’å‹•çš„ã«ç”Ÿæˆ
    ãƒ»å‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å¤‰æ›ã€ä¿®é£¾ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    ãƒ»ä¸»ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§ä½¿ç”¨

    â–  åŸºæœ¬æ§‹æ–‡

    type NewType = {
      [Key in keyof ExistingType]: Transform<ExistingType[Key]>
    }

    â–  ä¾‹

    type Original = {
      name: string;
      age: number;
    }

    type PartialOriginal = {
      [K in keyof Original]?: Original[K];          // ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«
    }

    type ReadonlyOriginal = {
      readonly [K in keyof Original]: Original[K];  // èª­ã¿å–ã‚Šå°‚ç”¨
    }

    type StringifiedOriginal = {
      [K in keyof Original]: string;                // ã™ã¹ã¦stringå‹
    }

    â–  MappedType & Record<> æ¯”è¼ƒ

    type Property = "name" | "address"

    type Person1 = { [ K in Property]: string }
    {
        name: string;
        address: string;
    }

    type Person2 = Record<Property, string>
    {
        name: string;
        address: string;
    }

    â–  MappedType + Record<>

    type Section = "sales" | "management"
    type Property = "name" | "address"

    type SecPersonA = {[S in Section]: Record<Property, string> }

    const secPersonA:SecPersonA  = {
        sales: {name:"John", address: "Tokyo"},
        management: {name:"Smith", address: "Osaka"}      // âŒ å…¨éƒ¨ä½¿ç”¨å¿…é ˆ
    }

    const secPersonB: Partial<SecPersonA>  = {
        sales: {name:"John", address: "Tokyo"},
        // management: {name:"Smith", address: "Osaka"}   // â­• éƒ¨åˆ†ä½¿ç”¨OK
    }

- ENTRY:
  EXPLAIN: Indexed Access Type (æ·»å­—ã‚¢ã‚¯ã‚»ã‚¹)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®ç‰¹å®šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»é…åˆ—ã‚„ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã®å‹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ã‚‚ä½¿ç”¨ã•ã‚Œã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    type PropertyType = ObjectType[KeyType]
    type ElementType = ArrayType[IndexType]

    â–  ä¾‹

    type T = {
      a: { x:number }
      b: string
    }

    const x: T["a"]      = { x: 123 }
    const y: T["a"]["x"] = 123

    â–  å‹å†…ã®å‹æµç”¨

    type A = T["a"];                    // { x:number }
    type B = T["a"|"b"];                // { x:number } | string

- ENTRY:
  EXPLAIN: as (ã‚¨ã‚¤ãƒªã‚¢ã‚¹)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å‹ã‚„å€¤ã«åˆ¥åã‚’ä»˜ã‘ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã«ã‚‚ä½¿ç”¨ã•ã‚Œã‚‹(åˆ¥ç”¨é€”)

    â–  åŸºæœ¬æ§‹æ–‡

    type NewType = {
      [Key in keyof ExistingType as `some${Capitalize<string & Key>}`]: string
    }

    â–  ä¾‹

    type Person = {
      name: string;
      age: number;
    }

    type Renamed = {
      [K in keyof Person as `my${Capitalize<string & K>}`]: (param: Person[K]) => void;
    }
    çµæœå‹: {
       myName: (param: string) => void; 
       myAge: (param: number) => void;
    }

- ENTRY:
  EXPLAIN: å‹æŒ‡å®š (å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å¤‰æ•°ã‚„å¼ã«å¯¾ã—ã¦ç‰¹å®šã®å‹ã‚’å¼·åˆ¶çš„ã«é©ç”¨ã™ã‚‹æ–¹æ³•
    ãƒ»å‹ãƒã‚§ãƒƒã‚¯ã‚’ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„
    ãƒ»æ…é‡ã«ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹

    â–  ä¾‹

    type A = { a: number; b: string | number }

    const a1: A = { a: 1, b: 2 }
    const a2: A = { a: 1, b: "2" }
    const a3 = { a: 1, b: 2 } as A           //å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
    [NG] const a4 = { a: "1", b: 2 } as A    //ã‚¨ãƒ©ãƒ¼: é–“é•ã£ãŸå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
    [NG] const a5 = <A>{ a: 1, b: 2 }        //ã‚¨ãƒ©ãƒ¼: é–“é•ã£ãŸå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®ä½¿ã„æ–¹(<A>)

    type B = { a: number; b: number }

    const b = { a: 1, b: "2" } as B          // ã‚¨ãƒ©ãƒ¼: é–“é•ã£ãŸå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
    const b = { a: 1 } as unknown as B       // å¼·åˆ¶(å¼·åˆ¶å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³) ğŸ”´ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„

- ENTRY:
  EXPLAIN: satisfies (å‹é©åˆæ¼”ç®—å­) v4.9+
  BODY: |
    â–  æ¦‚è¦

    ãƒ»TypeScript 4.9ã§å°å…¥ã•ã‚ŒãŸå‹æ¼”ç®—å­
    ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„å€¤ãŒç‰¹å®šã®å‹ã«é©åˆã—ã¦ã„ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»å‹ã®äº’æ›æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŒã€å€¤ã®å‹è‡ªä½“ã¯å¤‰æ›´ã—ãªã„
    ãƒ»1ã¤ä»¥ä¸Šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„
    ãƒ»as ã¨ç•°ãªã‚Šã€å‹ã®ãƒªãƒ†ãƒ©ãƒ«æ€§ã‚’ä¿æŒã™ã‚‹
    ãƒ»Widening(stringåŒ–)ã‚’é˜²ããªã©

    â–  ä¾‹

    type A = { x: string; y: number }

    const a1: A = { x: "X", y: 1 }

    ãƒ»å¤‰æ•° `a1` ã®å‹: A ({ x: string; y: number })
    ãƒ»ç†ç”±: å¤‰æ•°æ³¨é‡ˆ `: A` ãŒå„ªå…ˆã•ã‚Œã€RHS ã¯æ³¨é‡ˆã«åˆã‚ã›ã¦æ‰±ã‚ã‚Œã‚‹

    const a2 = { x: "X", y: 1 } satisfies A

    ãƒ»å¤‰æ•° `a2` ã®æ¨è«–å‹: { x: "X"; y: 1 }
    ãƒ»ç†ç”±: `satisfies` ã¯äº’æ›æ€§ãƒã‚§ãƒƒã‚¯ã®ã¿ã§ã€å¼ã®å…·ä½“çš„ãªå‹ï¼ˆãƒªãƒ†ãƒ©ãƒ«æ€§ï¼‰ã¯ä¿æŒã™ã‚‹

    const a3 = { x: "X", y: 1 } as const

    ãƒ»æ¨è«–å‹: { readonly x: "X"; readonly y: 1 }

    const a4 = { x: "X", y: 1 } as const satisfies A

    ãƒ»å¤‰æ•° `a4` ã®æ¨è«–å‹: { readonly x: "X"; readonly y: 1 }
    ãƒ»ç†ç”±: `as const` ãŒå¼ã®å‹ã‚’ readonly ãƒªãƒ†ãƒ©ãƒ«ã«ã—ã€`satisfies` ã¯äº’æ›æ€§ã‚’æ¤œè¨¼ã™ã‚‹ã ã‘

    const a5: A = { x: "X", y: 1 } as const

    ãƒ»å¤‰æ•° `a5` ã®å‹: A ({ x: string; y: number })
    ãƒ»ç†ç”±: å¤‰æ•°æ³¨é‡ˆãŒå„ªå…ˆã•ã‚Œã‚‹ãŸã‚ã€RHS ã® as const ã«ã‚ˆã‚‹ãƒªãƒ†ãƒ©ãƒ«æ€§ã¯å¤‰æ•°ã®å‹ã«ã¯åæ˜ ã•ã‚Œãªã„

- ENTRY:
  EXPLAIN: enum (åˆ—æŒ™ä½“å‹)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»é–¢é€£ã™ã‚‹å®šæ•°ã®é›†åˆã‚’å®šç¾©ã™ã‚‹ãŸã‚ã®æ§‹æ–‡
    ãƒ»æ•°å€¤åˆ—æŒ™ä½“ã¨æ–‡å­—åˆ—åˆ—æŒ™ä½“ã®2ç¨®é¡ãŒã‚ã‚‹

    â–  åŸºæœ¬æ§‹æ–‡(æ•°å€¤åˆ—æŒ™ä½“)

    enum EnumName {
      Member1 = 0,
      Member2 = 1,
      Member3 = 2,
    }

    enum ColorNo {
      Red = 1,                          // ColorNo.Red = 1
      Green,                            // ColorNo.Green = 2
      Blue,                             // ColorNo.Blue = 3
    }

    â–  åŸºæœ¬æ§‹æ–‡(æ–‡å­—åˆ—åˆ—æŒ™ä½“)

    enum EnumName {
      Member1 = "value1",
      Member2 = "value2",
      Member3 = "value3",
    }

    enum ColorName {
      Red = "red",                      // ColorName.Red = "red"
      Blue = "blue",                    // ColorName.Blue = "blue"
    }

#-------------------------------
# Function
#-------------------------------
- ENTRY:
  CATEGORY: é–¢æ•°

- ENTRY:
  EXPLAIN: é–¢æ•°å‹
  BODY: |
    â–  æ¦‚è¦

    ãƒ»é–¢æ•°ã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã®å‹ã‚’æŒ‡å®šã™ã‚‹æ–¹æ³•
    ãƒ»é–¢æ•°å‹(Function Type)ã¨Arrowé–¢æ•°å‹(Arrow Function Type)ã®2ç¨®é¡ãŒã‚ã‚‹
      ãƒ»é•ã„: æ§‹æ–‡ã®ã¿ã§ã€ä½¿ç”¨ä¸Šã®é•ã„ã¯ãªã„
    ãƒ»å¼•æ•°ã®æ•°ã‚„å‹ã®äº’æ›æ€§ãƒ«ãƒ¼ãƒ«ãŒã‚ã‚‹
      ãƒ»å¼•æ•°ã®æ•°ãŒå°‘ãªãã¦ã‚‚å¤šãã¦ã‚‚OK(ãŸã ã—å‹äº’æ›æ€§ã¯å¿…è¦)
      ãƒ»æˆ»ã‚Šå€¤å‹ã¯æŒ‡å®šå‹ã«ä»£å…¥å¯èƒ½ã§ã‚ã‚Œã°OK

    â–  åŸºæœ¬æ§‹æ–‡(Function Type)

    type FunctionType = {
      (param1: Type1, param2: Type2): ReturnType;
    }

    type Func = {
      (a: number, b: string): void;
    }

    â–  åŸºæœ¬æ§‹æ–‡(Arrow Function Type)

    type ArrowFunctionType = (param1: Type1, param2: Type2) => ReturnType;

    type Func = (a: number, b: string) => void;

    â–  ä¾‹

    const func: Func = (a: number, b: string): void => { ... }             // â­•
    const func: Func = (a: number): void => { ... }                        // â­•: å¼•æ•°ä¸è¶³
    const func: Func = (): void => { ... }                                 // â­•: å¼•æ•°ãªã—
    const func: Func = (a: number, b: string, c: boolean): void => { ... } // âŒ: å¼•æ•°éå¤š
    const func: Func = (a: string, b: string): void => { ... }             // âŒ: å¼•æ•°å‹ä¸ä¸€è‡´
    const func: Func = (a: number, b: string): number => { ... }           // âŒ: æˆ»ã‚Šå€¤å‹ä¸ä¸€è‡´

- ENTRY:
  EXPLAIN: é–¢æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
  BODY: |
    â–  æ¦‚è¦

    ãƒ»åŒã˜é–¢æ•°åã§è¤‡æ•°ã®é–¢æ•°ã‚·ã‚°ãƒãƒãƒ£(å¼•æ•°ã¨æˆ»ã‚Šå€¤ã®å‹)ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•
    ãƒ»é–¢æ•°ã®å¼•æ•°ã‚„æˆ»ã‚Šå€¤ã®å‹ãŒç•°ãªã‚‹å ´åˆã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»å®Ÿè£…ã¯1ã¤ã§ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚·ã‚°ãƒãƒãƒ£ã«åŸºã¥ã„ã¦å‹•ä½œã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹

    â–  åŸºæœ¬ã‚µãƒ³ãƒ—ãƒ«

      â€» å…ˆã«è¤‡æ•°ã®é–¢æ•°å®£è¨€ã‚’è¡Œã„ã€æœ€å¾Œã«1ã¤ã®å®Ÿè£…ã‚’è¨˜è¿°ã™ã‚‹

      function func(param: string): void
      function func(param: string[]): void
      function func(param: string | string[]): void  // Union ã§ã®ã¾ã¨ã‚ãŒå¿…è¦(æ­£ç¢ºãªå‹å¿…é ˆ)
      {
          if(typeof param==="string") { } else { }
      }

      const result1 = func("ABC")
      const result2 = func(["ABC"])

    â–  é–¢æ•°å‹å®£è¨€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰(æˆ»ã‚Šå€¤ void)

    type FuncOverload = {
      (a: string): void;
      (a: string[]): void;
    }

    const func: FuncOverload = (a: string | string[]): void => {
      if(typeof a==="string") { } else { }
    }

    â–  é–¢æ•°å‹å®£è¨€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰(æˆ»ã‚Šå€¤å¤šæ§˜)

    type FuncOverload = {
      (a: string): number;
      (a: string[]): string;
    }

    const func: FuncOverload = ((a: string | string[]) => {
      if(typeof a==="string") {
        return a.length
      } else {
        return a.join(",")
      }
    }) as FuncOverload      // ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰å‹ã‚’æŒ‡å®š(ã“ã‚Œä»¥å¤–ã®æ–¹æ³•ãŒè¦‹ã¤ã‹ã£ã¦ã„ãªã„)

    ãƒ»æˆ»ã‚Šå€¤å‹ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã®ã‚·ã‚°ãƒãƒãƒ£ã«åŸºã¥ã„ã¦æ¨è«–ã•ã‚Œã‚‹
    ãƒ»å®Ÿè£…å†…ã§ã®å‹ãƒã‚§ãƒƒã‚¯ãŒå¿…è¦

- ENTRY:
  EXPLAIN: ã‚³ãƒ³ãƒ‘ãƒ‹ã‚ªãƒ³ (React Moduleå‘½åè¦å‰‡)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ãã®å‹å®šç¾©ã‚’åŒã˜åå‰ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
    ãƒ»ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®Propså‹ã‚’å¤–éƒ¨ã§å†åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»æ³¨æ„: å‹ã®ã¿ä½¿ç”¨ã—ãŸã„æ™‚ã¯ã€type å‹ ã‚’ä½¿ç”¨ã—ãªã„ã¨ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ¬ä½“ã‚‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã—ã¾ã†

    â–  åŸºæœ¬æ§‹æ–‡

    // MyComponent.tsx
    export type MyComponent = {
      title: string;
      count: number;
    }

    export const MyComponent: React.FC<MyComponent> = ({ title, count }) => {
      return ( ... )}

    // AnotherFile.tsx
    import { MyComponent } from "./MyComponent"
    const AnotherComponent: React.FC<MyComponent> = ({ title, count }) => {
      return ( ... )
    }

    // å‹ã®ã¿ä½¿ç”¨ã—ãŸã„å ´åˆ
    import type { MyComponent } from "./MyComponent"

- ENTRY:
  EXPLAIN: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®å¤šå±æ€§ãƒã‚§ãƒƒã‚¯
  BODY: |
    â–  æŒ™å‹•ã®ç†ç”±

    ãƒ»TypeScriptã®æ§‹é€ çš„å‹ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®äº’æ›æ€§ãŒæŸ”è»Ÿã«æ‰±ã‚ã‚Œã‚‹
    ãƒ»é–¢æ•°ã®å¼•æ•°ã¨ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ä½™åˆ†ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã£ã¦ã‚‚å‹äº’æ›æ€§ãŒæˆç«‹ã™ã‚‹
    ãƒ»ãŸã ã—ã€ç›´æ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ã‚’æ¸¡ã™å ´åˆã¯ã€ä½™åˆ†ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
    ãƒ»ã“ã‚Œã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ãŒãã®å ´ã§ä½œæˆã•ã‚Œã‚‹ãŸã‚ã€å‹ãƒã‚§ãƒƒã‚¯ãŒå³å¯†ã«è¡Œã‚ã‚Œã‚‹ãŸã‚

    â–  æŒ™å‹•ä¾‹

    type Props = {
      a: string;
    }

    const func1 = (props: Props) => props.a

    const a = { a: "a", b: "b" }
    const b = { b: "b" }

    func1(a)                     // â­• å¤šå±æ€§ã®é–“æ¥ä»£å…¥
    func1({ a: "a", b: "b" })    // âŒ å¤šå±æ€§ã®ç›´æ¥ä»£å…¥
    func1(b)                     // âŒ å±æ€§ä¸è¶³

    â–  ä½™åˆ†å¼•æ•°ã®å—ã‘å…ˆè¿½åŠ 

    type PropsWithRest = {
      a: string;
      [x: string]: unknown      // ä½™åˆ†å¼•æ•°ã®å—ã‘å…ˆè¿½åŠ  
    }

    const func2 = (props: PropsWithRest) => props.a

    // å¤šå±æ€§ã®ç›´æ¥ä»£å…¥ OK!
    func2(a)                     // â­• å¤šå±æ€§ã®é–“æ¥ä»£å…¥
    func2({ a: "a", b: "b" })    // â­• å¤šå±æ€§ã®ç›´æ¥ä»£å…¥
    func2(b)                     // âŒ å±æ€§ä¸è¶³

- ENTRY:
  EXPLAIN: is (Type Predicate å‹è¿°èª)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»é–¢æ•°ãŒç‰¹å®šã®å‹ã‚’æŒã¤ã‹ã©ã†ã‹"åˆ¤å®š"ã™ã‚‹ãŸã‚ã ã‘ä½¿ç”¨
    ãƒ»é–¢æ•°ã®æˆ»ã‚Šå€¤ã®å‹ã¨ã—ã¦ã€Œprops is Typeã€ã®å½¢å¼ã‚’ä½¿ç”¨ã€æˆ»ã‚Šå€¤ã¯ boolean å‹
    ãƒ»å‹ã‚¬ãƒ¼ãƒ‰é–¢æ•°(Type Guard Function)ã¨ã‚‚å‘¼ã°ã‚Œã‚‹
    ãƒ»æ•…ã«ã€é–¢æ•°åã¯ isXXX ã¨ã™ã‚‹æ…£ç¿’ãŒã‚ã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    const isType = (param: any): param is Type => {
      // å‹ãƒã‚§ãƒƒã‚¯ã®ãƒ­ã‚¸ãƒƒã‚¯
      return æ¡ä»¶;
    }

    â–  ã‚µãƒ³ãƒ—ãƒ«

    type Employee = {
      id: number
    }

    type TempWorker = {
      sid: number
    }

    const isMember = (props: Employee | TempWorker): props is Employee => {
      return 'id' in props && typeof (props as Employee).id === "number"
    }

    const addMember = (props: Employee | TempWorker): string => {
      if (isMember(props)) {
        return "ABC"
      } else {
        return "XYZ"
      }
    }

    const result = addMember({ id: 123 })
    console.log(result)   // "ABC"

#-------------------------------
# Generics
#-------------------------------
- ENTRY:
  CATEGORY: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹

- ENTRY:
  EXPLAIN: å‹å®£è¨€
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã€æŸ”è»Ÿã§å†åˆ©ç”¨å¯èƒ½ãªå‹ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•
    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯ã€é–¢æ•°ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€ã‚¯ãƒ©ã‚¹ã€å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ä½¿ç”¨ã§ãã‚‹
    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã¯ã€ä»»æ„ã®æ•°ã¨å‹ã§å®šç¾©ã§ãã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    type Param<T> = { a: T }            // å˜ä¸€ãƒ‘ãƒ©ãƒ¡ã‚¿
    type Param<T, S> = { a: T, b: S }   // è¤‡æ•°ãƒ‘ãƒ©ãƒ¡ã‚¿

    const a: Param<number> = { a: 1 }
    const b: Param<string> = { a: "x" }

    const d: Param<number, string> = { a: 1, b: "x" }
    const e: Param<string, boolean> = { a: "x", b: true }

- ENTRY:
  EXPLAIN: extends (åˆ¶ç´„)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾ã—ã¦ç‰¹å®šã®å‹ã‚„å‹ã®é›†åˆã«åˆ¶ç´„ã‚’è¨­ã‘ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒæŒ‡å®šã•ã‚ŒãŸå‹ã‚„å‹ã®é›†åˆã«é©åˆã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹
    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒç‰¹å®šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    type Param<T extends ConstraintType> = { a: T }
    const a: Param<ValidType> = { a: ... }
    const b: Param<InvalidType> = { a: ... }   // âŒ InvalidType ã¯ ä¸é©åˆ

    â–  ã‚µãƒ³ãƒ—ãƒ«(Primitiveå‹åˆ¶ç´„)

    type TypeA<T extends number> = { a: T }

    const a1: TypeA<number> = { a: 1 }
    const a2: TypeA<string> = { a: "x" }       // âŒ string ã¯ number ã«ä¸é©åˆ

    â–  ã‚µãƒ³ãƒ—ãƒ«(Unionå‹åˆ¶ç´„)

    type ABC = "A" | "B" | "C"
    type TypeB<T extends ABC> = { a: T }

    const b1: TypeB<ABC> = { a: "A" }
    const b2: TypeB<string> = { a: "X" }       // âŒ string ã¯ ABC ã«ä¸é©åˆ

    â–  ã‚µãƒ³ãƒ—ãƒ«(Objectå‹åˆ¶ç´„)

    type Obj = {
      n: string
      a: number
    }
    type TypeC<T extends Obj> = T

    const c1: TypeC<Obj> = {
      n: "a",
      a: 1,
    }

    const c2: TypeC<{ n: string }> = {          // âŒ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ä¸è¶³
      n: "a",
    }

    â–  æ—¢å­˜ Object ã‹ã‚‰å‹å–å¾—ã—ã¦åˆ¶ç´„

    const obj = { n: "abc", a: 1 }

    type TypeD<T extends typeof obj> = T
    const d: TypeD<typeof obj> = { n: "a", a: 1 }

- ENTRY:
  EXPLAIN: extends (ä¸‰é …åˆ†å²)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾ã—ã¦æ¡ä»¶åˆ†å²ã‚’è¡Œã†ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹
    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒç‰¹å®šã®å‹ã«é©åˆã™ã‚‹ã‹ã©ã†ã‹ã«åŸºã¥ã„ã¦ã€ç•°ãªã‚‹å‹ã‚’è¿”ã™ã“ã¨ãŒã§ãã‚‹
    ãƒ»æ¡ä»¶åˆ†å²ã¯ã€å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ãŒç‰¹å®šã®å‹ã«é©åˆã™ã‚‹å ´åˆã¨ã—ãªã„å ´åˆã®2ã¤ã®ã‚±ãƒ¼ã‚¹ã«åˆ†ã‘ã‚‰ã‚Œã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    type Param<T> = T extends ConditionType ? TrueType : FalseType
    const a: Param<ValidType> = ...          // TrueType
    const b: Param<InvalidType> = ...        // FalseType

    â–  ã‚µãƒ³ãƒ—ãƒ«

    type A = { a: string }
    type B = { a: string }
    type C = { a: string; b: number }

    type AB = A extends B ? number : string  // ä¸‰é …åˆ†å²: number
    type BC = B extends C ? number : string  // ä¸‰é …åˆ†å²: string

    type Y<T> = T extends true ? 1 : 0       // ä¸‰é …åˆ†å²

    type Z<T extends boolean>                // (å‰åŠ)å‹åˆ¶ç´„: T ã¯ Boolean
      = T extends true ? "a" : "b"           // (å¾ŒåŠ)ä¸‰é …åˆ†å²

- ENTRY:
  EXPLAIN: extends + never (ä¸‰é …åˆ†å²ã§å‹å¤‰æ›)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾ã—ã¦æ¡ä»¶åˆ†å²ã‚’è¡Œã„ã€ç‰¹å®šã®å‹ã«åŸºã¥ã„ã¦å‹å¤‰æ›ã‚’è¡Œã†æ–¹æ³•
    ãƒ»Unionå‹ã®å„è¦ç´ ã«å¯¾ã—ã¦å€‹åˆ¥ã«å‹å¤‰æ›ã‚’é©ç”¨ã™ã‚‹å ´åˆã«æœ‰åŠ¹

    â–  åŸºæœ¬æ§‹æ–‡

    type Param<T> = T extends ConditionType ? TrueType : never

    const a: Param<ValidType> = ...          // TrueType
    const b: Param<InvalidType> = ...        // never

    â–  ã‚µãƒ³ãƒ—ãƒ«

    type ToString<T> = T extends number ? string : never

    type A = ToString<number>                // string
    type B = ToString<string>                // never
    type C = ToString<number | string>       // string  (Unionåˆ†è§£é©ç”¨)

    type MakeArray<T>
      = T extends any ? T[] : never          // è¦ç´ ã‚’é…åˆ—ã«å¤‰æ›
    type X1 = MakeArray<string>              // string[]
    type X2 = MakeArray<string | number>     // string[]|number[] æƒ³å®šå¤–

    type MakeArrayBetter<T>
      = [T] extends [any] ? T[] : never       // æ”¹å–„
    type Y = MakeArrayBetter<string | number> // (string|number)[] æƒ³å®šé€šã‚Š

- ENTRY:
  EXPLAIN: extends + infer (ä¸‰é …åˆ†å²ã§å†…åŒ…ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå–ã‚Šå‡ºã—)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾ã—ã¦æ¡ä»¶åˆ†å²ã‚’è¡Œã„ã€ç‰¹å®šã®å‹ã‹ã‚‰å†…åŒ…ã•ã‚Œã¦ã„ã‚‹å‹ã‚’æŠ½å‡ºã™ã‚‹æ–¹æ³•
    ãƒ»infer ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€æ¡ä»¶åˆ†å²å†…ã§æ–°ã—ã„å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å°å…¥ã§ãã‚‹
    ãƒ»ä¸»ã«ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å‹ã®å†…åŒ…å‹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨

    â–  åŸºæœ¬æ§‹æ–‡

    type Param<T> = T extends ContainerType<infer U> ? U : never
    const a: Param<ValidType> = ...          // U

    â–  ã‚µãƒ³ãƒ—ãƒ«

    ãƒ»é…åˆ—ã®è§£åŒ…

      type UnwrapArray<T> = T extends Array<infer U> ? U : T
      type A = UnwrapArray<string[]>          // string
      type B = UnwrapArray<number[]>          // number

    ãƒ»Promiseã®è§£åŒ…

      type UnwrapPromise<T> = T extends Promise<infer U> ? U : T
      type C = UnwrapPromise<Promise<string>>  // string

    ãƒ»é–¢æ•°ã®æˆ»ã‚Šå€¤å‹ã‚’æŠ½å‡º

      type UnwrapFunctionReturnType<T> = T extends (...args: any[]) => infer U ? U : T
      type D = UnwrapFunctionReturnType<() => number> // number

    ãƒ»ReturnType ã‚’æŠ½å‡ºã™ã‚‹ (æˆ»ã‚Šå€¤å‹ã®æŠ½å‡º)

      type ExtractReturn<T> = T extends (...args: any[]) => infer R ? R : never
      type R1 = ExtractReturn<() => string>        // string
      type R2 = ExtractReturn<(x:number)=>Promise<number>> // Promise<number>

    ãƒ»æœ€åˆã®å¼•æ•°å‹ã‚’æŠ½å‡ºã™ã‚‹ (é–¢æ•°ã‚·ã‚°ãƒãƒãƒ£ã‹ã‚‰ç¬¬1å¼•æ•°ã‚’å–å¾—)

      type FirstArg<T> = T extends (a: infer A, ...args: any[]) => any ? A : never
      type A1 = FirstArg<(x: number, y: string) => void> // number

    ãƒ»é…åˆ—/ã‚¿ãƒ—ãƒ«è¦ç´ ã®å–ã‚Šå‡ºã— (é…åˆ—è¦ç´ ã‚„ã‚¿ãƒ—ãƒ«ã®å…ˆé ­/æ®‹ã‚Šã‚’å–å¾—)

      type ElementOf<T> = T extends (infer U)[] ? U : T
      type E1 = ElementOf<string[]>           // string

      type Head<T> = T extends [infer H, ...any[]] ? H : never
      type Tail<T> = T extends [any, ...infer R] ? R : never
      type H1 = Head<[1, 2, 3]>                // 1
      type T1 = Tail<[1, 2, 3]>                // [2, 3]

    ãƒ»ãƒã‚¹ãƒˆã—ãŸ Promise ã‚’å†å¸°çš„ã«å±•é–‹ã™ã‚‹

      type DeepAwait<T> = T extends Promise<infer U> ? DeepAwait<U> : T
      type D1 = DeepAwait<Promise<Promise<string>>>    // string

    ãƒ»å¿œç”¨ä¾‹: é–¢æ•°é…åˆ—ã‹ã‚‰æˆ»ã‚Šå€¤ã®ãƒ¦ãƒ‹ã‚ªãƒ³ã‚’å–å¾—ã™ã‚‹

      type ReturnsOf<T extends any[]> 
        = T[number] extends (...args: any[]) => infer R ? R : never
      type RUnion 
        = ReturnsOf<[() => number, () => string]>       // number | string

    â–  æ‚ªä¾‹(inferä¸è¦ãªã®ã«ä½¿ç”¨)

      type WrongConvert<T extends any> = T extends infer U ? [U] : never
      => type RightConvert<T> = T extends [T] : never   // inferä¸è¦
      => type RightConvert<T> = [T]                     // ã•ã‚‰ã«ç°¡ç•¥åŒ–

    â–  æ‚ªä¾‹(inferã®å¤šç”¨)

      type OverInfer<T> = T extends Array<infer U>
        ? U extends Promise<infer V>
          ? V
          : U
        : T
      => type BetterInfer<T> 
        = T extends Array<Promise<infer V>> ? V : T extends Array<infer U> ? U : T
      => type BestInfer<T>
        = T extends Array<infer U> ? U extends Promise<infer V> ? V : U : T

- ENTRY:
  EXPLAIN: extends + infer (æ–‡å­—åˆ—æŠ½å‡º)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒªãƒ†ãƒ©ãƒ«ã®è§£æã€éƒ¨åˆ†æŠ½å‡º
    ãƒ»å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã«å¯¾ã—ã¦æ¡ä»¶åˆ†å²ã‚’è¡Œã„ã€ç‰¹å®šã®æ–‡å­—åˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰éƒ¨åˆ†æ–‡å­—åˆ—ã‚’æŠ½å‡ºã™ã‚‹æ–¹æ³•
    ãƒ»infer ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€æ¡ä»¶åˆ†å²å†…ã§æ–°ã—ã„å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’å°å…¥ã§ãã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    type Param<T> = T extends `prefix${infer U}suffix` ? U : never
    const a: Param<ValidType> = ...          // U

    â–  ã‚µãƒ³ãƒ—ãƒ«

    ãƒ»æ–‡å­—åˆ—ã‚’ãƒ‘ã‚¹ã‚«ãƒ«ã‚±ãƒ¼ã‚¹ã«å¤‰æ›´
    type PascalCase<S extends string> = S extends `${infer H}${infer T}`
      ? `${Capitalize<H>}${Lowercase<T>}`
      : S
    type G = PascalCase<"ABC">               //"Abc"

    ãƒ»ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ãƒ‰ãƒ¡ã‚¤ãƒ³éƒ¨åˆ†ã‚’æŠ½å‡º
    type EmailDomain<T extends string> = T extends `${string}@${infer D}` ? D : never
    type D1 = EmailDomain<"example@example.com">     //"example.com"

- ENTRY:
  EXPLAIN: é–¢æ•°å‹(éReact)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»éReact (æ±ç”¨ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚„ãƒ©ã‚¤ãƒ–ãƒ©ãƒª) å‘ã‘ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°å‹ã®åŸºæœ¬ã¨ä¾‹

    â–  åŸºæœ¬æ§‹æ–‡

    function identity<T>(value: T): T { return value }
    const identity = <T>(value: T): T => value         // ã‚¢ãƒ­ãƒ¼é–¢æ•°
    type Identity = <T>(value: T) => T                // é–¢æ•°å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹

    const num = identity<number>(123)
    const str = identity<string>("abc")
    const bool = identity(true)                          // å‹æ¨è«–

    const arrowNum: Identity = <T>(value: T): T => value
    const arrowStr = arrowNum<string>("xyz")

    const funcNum: Identity = function<T>(value: T): T { return value }
    const funcStr = funcNum<string>("lmn")

    â–  è¤‡æ•°å‹ãƒ‘ãƒ©ãƒ¡ã‚¿

    function pair<T, U>(first: T, second: U): [T, U] {
      return [first, second]
    }

    const p1 = pair<number, string>(1, "a")
    const p2 = pair(true, 3.14)   // å‹æ¨è«–

    â–  åˆ¶ç´„ä»˜ãã‚¸ã‚§ãƒãƒªãƒƒã‚¯

    ãƒ»ç‰¹å®šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«åˆ¶ç´„
    function pluck = function<T, K extends keyof T>(obj: T, key: K): T[K] {
      return obj[key]
    }

    const person = { name: "Alice", age: 30 }
    const name = pluck(person, "name")          // string
    const age = pluck(person, "age")            // number
    // const invalid = pluck(person, "address") // âŒ ã‚¨ãƒ©ãƒ¼: 'address' ã¯ 'person' ã«å­˜åœ¨ã—ãªã„

    â–  ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹ãƒ‘ãƒ©ãƒ¡ã‚¿

    function createArray<T = string>(length: number, value: T): T[] {
      return Array.from({ length }, () => value)
    }

    const strArray = createArray(3, "hello")    // string[]
    const numArray = createArray<number>(2, 42) // number[]

    â–  å¯å¤‰é•·å¼•æ•°(ã‚¿ãƒ—ãƒ«ã‚’ä¿æŒ)

    function makeTuple<T extends any[]>(...args: T): T {
      return args
    }

    const tuple1 = makeTuple(1, "a", true)          // [number, string, boolean]
    const tuple2 = makeTuple<string[]>(["x", "y"])  // [string[]]

    â–  é«˜éšé–¢æ•° (HOF)

    function withLogging<T extends (...args: any[]) => any>(fn: T): T {
      return function(...args: Parameters<T>): ReturnType<T> {
        console.log("Arguments:", args)
        const result = fn(...args)
        console.log("Result:", result)
        return result
      } as T
    }

    const add = (a: number, b: number): number => a + b
    const loggedAdd = withLogging(add)

    â–  é–¢æ•°å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’ä½¿ã£ãŸå®Ÿç”¨çš„ãªä¾‹

    type FuncWithLogging<T extends (...args: any[]) => any> = (
      ...args: Parameters<T>
    ) => ReturnType<T>

    function withLoggingAlias<T extends (...args: any[]) => any>(
      fn: T
    ): FuncWithLogging<T> {
      return function(...args: Parameters<T>): ReturnType<T> {
        ...
      } as FuncWithLogging<T>    <-- å‹ã‚­ãƒ£ã‚¹ãƒˆãŒå¿…è¦
    }

- ENTRY:
  EXPLAIN: é–¢æ•°å‹(React)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç”¨ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°å‹ã®æ›¸å¼
    ãƒ»TypeScriptã®å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã«ã‚«ãƒ³ãƒã‚’ä»˜ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹
    ãƒ»ã“ã‚Œã¯ã€JSXæ§‹æ–‡ã¨å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã®åŒºåˆ¥ã‚’æ˜ç¢ºã«ã™ã‚‹ãŸã‚
    ãƒ»Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒJSXå†…ã§ä½¿ç”¨ã•ã‚Œã‚‹å ´åˆã€å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã®çµ‚ç«¯ã‚’ç¤ºã™ãŸã‚ã«ã‚«ãƒ³ãƒãŒå¿…è¦

    â–  åŸºæœ¬æ§‹æ–‡

    const Component = <T,>(props: PropsType<T>): React.ReactNode => { ... }
    const Component = <T, S>(props: PropsType<T, S>): React.ReactNode => { ... }
    const Component = <T=DefaultType,>(props: PropsType<T>): React.ReactNode => { ... }
    const Component = <T extends ConstraintType>(props: PropsType<T>): React.ReactNode => { ... }

    const Component = <T,>(a: T): React.ReactNode => { ... }
    const Component = <T, S>(a: T, b: S): React.ReactNode => { ... }
    const Component = <T=string,>(a: T): React.ReactNode => { ... }
    const Component = <T extends number>(a: T): React.ReactNode => { ... }

    â–  å˜ä¸€å‹ãƒ‘ãƒ©ãƒ¡ã‚¿

    type Props<T> = {
      items: T[];
      renderItem: (item: T) => React.ReactNode;
    }

    const GenericList = <T,>({ items, renderItem }: Props<T>): React.ReactNode => {
      return ( ... )
    }

    â–  è¤‡æ•°å‹ãƒ‘ãƒ©ãƒ¡ã‚¿

    type Props<T, S> = {
      items: T[];
      selectedItem: S;
      renderItem: (item: T, isSelected: boolean) => React.ReactNode;
    }
    const GenericList = <T, S>({ items, selectedItem, renderItem }: Props<T, S>): React.ReactNode => {
      return ( ... )
    }

    â–  ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹ãƒ‘ãƒ©ãƒ¡ã‚¿

    type Props<T = string> = {
      items: T[];
      renderItem: (item: T) => React.ReactNode;
    }
    const GenericList = <T = string>({ items, renderItem }: Props<T>): React.ReactNode => {
      return ( ... )
    }

    â–  å¯å¤‰é•·å¼•æ•°(ã‚¿ãƒ—ãƒ«ã‚’ä¿æŒ)

    function makeTuple<T extends any[]>(...args: T): T {
      return args
    }

    const t1 = makeTuple(1, "a", true)       // type: [number, string, boolean]
    const t2 = makeTuple(1, ["x", "y"])      // type: [number, string[]]

    ãƒ»ã‚¿ãƒ—ãƒ«ã®è¦ç´ å‹ã ã‘å–ã‚Šå‡ºã™ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

    type ElementOfTuple<T extends any[]> = T extends (infer U)[] ? U : never
    type E1 = ElementOfTuple<typeof t1>        // number | string | boolean
    type E2 = ElementOfTuple<typeof t2>        // number | string[]

    â–  é«˜éšã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ (HOC)

    type WithThemeProps = { theme?: string }

    function withTheme<P extends object>(Component: React.ComponentType<P & WithThemeProps>) {
      return (props: P) => {
        const theme = "dark"
        return <Component {...(props as P)} theme={theme} />
      }
    }

    const Button: React.FC<{ label: string } & WithThemeProps>
      = ({ label, theme }) => <button>{label} - {theme}</button>

    const ThemedButton = withTheme(Button)

    â–  é–¢æ•°å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’ä½¿ã£ãŸå®Ÿç”¨çš„ãªä¾‹

    ãƒ»æ±ç”¨ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
    type Callback<T extends any[] = any[], R = void> = (...args: T) => R

    ãƒ»ç‰¹å®šã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®šç¾©ã—ã¦ä½¿ã†
    type ClickHandler = Callback<[MouseEvent], void>

    const onClick: ClickHandler = (e) => { console.log(e.type) }

    ãƒ»éåŒæœŸé–¢æ•°ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹
    type AsyncFn<TArgs extends any[] = any[], R = unknown> = (...args: TArgs) => Promise<R>

    const fetchJson: AsyncFn<[string], unknown> = async (url) => {
      const res = await fetch(url)
      return res.json()
    }

    ãƒ»HOF ã¨çµ„ã¿åˆã‚ã›ãŸã‚¨ã‚¤ãƒªã‚¢ã‚¹åˆ©ç”¨ä¾‹
    type FnWithParams<T extends (...args: any[]) => any> 
      = (...args: Parameters<T>) => ReturnType<T>

    function wrapWithDefault<T extends (...args: any[]) => any>
      (fn: T, ...defaults: Partial<Parameters<T>>) : FnWithParams<T> {
      return ((...args: any[]) => fn(...args)) as FnWithParams<T>
    }

    const sum = (a: number, b: number, c: number): number => a + b + c
    const sumWithDefault = wrapWithDefault(sum, 1, 2)       // a=1, b=2 ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåŒ–
    const result = sumWithDefault(3)                        // c=3 æŒ‡å®š 

      â€» ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯å¯èª­æ€§ã¨å†åˆ©ç”¨æ€§ã‚’é«˜ã‚ã‚‹ã€‚è¤‡é›‘ã«ãªã‚Šã™ããŸã‚‰åˆ†è§£

#-------------------------------
# Class
#-------------------------------
- ENTRY:
  CATEGORY: Class

- ENTRY:
  EXPLAIN: ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ç‰¹æ®Šãªãƒ¡ã‚½ãƒƒãƒ‰
    ãƒ»ã‚¯ãƒ©ã‚¹åã¨åŒã˜åå‰ã§å®šç¾©ã•ã‚Œã€new ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹
    ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å†…ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã®åˆæœŸåŒ–ã‚„å¿…è¦ãªã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å‡¦ç†ã‚’è¡Œã†

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      constructor(param1: Type1, param2: Type2) {
        // åˆæœŸåŒ–ã‚³ãƒ¼ãƒ‰
      }
    }

    const instance = new ClassName(value1, value2)

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class Person {
      name: string
      age: number

      constructor(name: string, age: number) {
        this.name = name
        this.age = age
      }
    }

    const alice = new Person("Alice", 30)
    console.log(alice.name) // "Alice"
    console.log(alice.age)  // 30

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å®£è¨€
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚¯ãƒ©ã‚¹å†…ã§å®šç¾©ã•ã‚Œã‚‹å¤‰æ•°(ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£)ã®å®£è¨€æ–¹æ³•ã¨ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
    ãƒ»TypeScriptã§ã¯ã€ã‚¯ãƒ©ã‚¹å¤‰æ•°ã«å¯¾ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ä¿®é£¾å­ã‚’ä½¿ç”¨ã—ã¦ã€å¤‰æ•°ã®å¯è¦–æ€§ã‚’åˆ¶å¾¡
    ãƒ»ã‚¢ã‚¯ã‚»ã‚¹ä¿®é£¾å­ã«ã¯ã€publicã€privateã€protectedã®3ç¨®é¡

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      defaultVar: Type;                     // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ public
      public publicVar: Type;               // ã©ã“ã‹ã‚‰ã§ã‚‚ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      private privateVar: Type;             // ã‚¯ãƒ©ã‚¹å†…ã‹ã‚‰ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      protected protectedVar: Type;         // ã‚¯ãƒ©ã‚¹å†…ãŠã‚ˆã³ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      noInitialVar: Type;                   // âŒ åˆæœŸåŒ–çœç•¥
      noNullInitialVar!: Type;              // â­• åˆæœŸåŒ–çœç•¥ (énullã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

      constructor(param: Type) {
        this.defaultVar = param;
        this.publicVar = param;
        this.privateVar = param;
        this.protectedVar = param;
        this.noInitialVar;                  // âŒ ã‚¨ãƒ©ãƒ¼: åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„
        // noNullInitialVar ã¯åˆæœŸåŒ–çœç•¥å¯èƒ½
      }
    }

    const instance = new ClassName(value);
    console.log(instance.defaultVar);       // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    console.log(instance.publicVar);        // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    console.log(instance.privateVar);       // âŒ ã‚¨ãƒ©ãƒ¼: privateVar ã¯ private
    console.log(instance.protectedVar);     // âŒ ã‚¨ãƒ©ãƒ¼: protectedVar ã¯ protected
    console.log(instance.noNullInitialVar); // ğŸš« ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã ãŒ undefined(Runtimeã‚¨ãƒ©ãƒ¼èª˜ç™ºå¯èƒ½)

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å®£è¨€(ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‘ãƒ©ãƒ¡ã‚¿ãƒ»ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒ‘ãƒ©ãƒ¡ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ä¿®é£¾å­ã‚’ä»˜ä¸ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å®£è¨€ã¨åˆæœŸåŒ–ã‚’åŒæ™‚å®Ÿè¡Œ
    ãƒ»ã“ã‚Œã«ã‚ˆã‚Šã€å†—é•·ãªã‚³ãƒ¼ãƒ‰ã‚’çœç•¥ã—ã€ã‚¯ãƒ©ã‚¹ã®å¯èª­æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      constructor(
        public publicVar: Type,             // public ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
        private privateVar: Type,           // private ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
        protected protectedVar: Type        // protected ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      ) {}
    }

    const instance = new ClassName(value1, value2, value3);
    console.log(instance.publicVar);        // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    console.log(instance.privateVar);       // âŒ ã‚¨ãƒ©ãƒ¼: privateVar ã¯ private
    console.log(instance.protectedVar);     // âŒ ã‚¨ãƒ©ãƒ¼: protectedVar ã¯ protected

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class Employee {
      public name: string;                  // å…¬é–‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      private id: number;                   // éå…¬é–‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      protected department: string;         // ä¿è­·ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      public readonly hireDate: Date;       // èª­ã¿å–ã‚Šå°‚ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£

      constructor(name: string, id: number, department: string, hireDate: Date) {
        this.name = name;
        this.id = id;
        this.department = department;
        this.hireDate = hireDate;
      }

      public getDetails(): string {
        return `Name: ${this.name}, Department: ${this.department}`;
      }
    } 

    const emp = new Employee("Bob", 12345, "Engineering", new Date("2020-01-15"));
    console.log(emp.name);                  // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    // console.log(emp.id);                 // âŒ ã‚¨ãƒ©ãƒ¼: id ã¯ private
    // console.log(emp.department);         // âŒ ã‚¨ãƒ©ãƒ¼: department ã¯ protected
    console.log(emp.hireDate);              // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    console.log(emp.getDetails());          // â­• ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å®£è¨€(ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãªã—)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å®šç¾©ã›ãšã«ã‚¯ãƒ©ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®£è¨€ãŠã‚ˆã³åˆæœŸåŒ–ã™ã‚‹æ–¹æ³•
    ãƒ»ã‚¯ãƒ©ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å®£è¨€æ™‚ã«åˆæœŸåŒ–ã§ãã‚‹
    ãƒ»ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒä¸è¦ãªå ´åˆã€ã‚³ãƒ¼ãƒ‰ã‚’ç°¡æ½”ã«ä¿ã¤ã“ã¨ãŒã§ãã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      public var1: Type = initialValue1;      // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å®£è¨€ã¨åˆæœŸåŒ–
      private var2: Type = initialValue2;     // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      protected var3: Type = initialValue3;   // ãƒ—ãƒ­ãƒ†ã‚¯ãƒ†ãƒƒãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      noInitialVar: Type;                     // âŒ åˆæœŸåŒ–çœç•¥
      noNullInitialVar!: Type;                // â­• åˆæœŸåŒ–çœç•¥ (énullã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)
    }

    const instance = new ClassName();
    console.log(instance.var1);               // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    // console.log(instance.var2);            // âŒ ã‚¨ãƒ©ãƒ¼: var2 ã¯ private
    // console.log(instance.var3);            // âŒ ã‚¨ãƒ©ãƒ¼: var3 ã¯ protected

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class Counter {
      public count: number = 0;               // å…¬é–‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      private step: number = 1;               // éå…¬é–‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£

      public increment(): void {
        this.count += this.step;
      }

      public setStep(newStep: number): void {
        this.step = newStep;
      }
    }

    const counter = new Counter();
    console.log(counter.count);             // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    counter.increment();
    counter.setStep(5);

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ readonly
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚¯ãƒ©ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’èª­ã¿å–ã‚Šå°‚ç”¨ã«ã™ã‚‹ãŸã‚ã®ä¿®é£¾å­
    ãƒ»readonly ä¿®é£¾å­ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯åˆæœŸåŒ–å¾Œã«å¤‰æ›´ã§ããªããªã‚‹
    ãƒ»åˆæœŸåŒ–ã¯ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å®£è¨€æ™‚ã¾ãŸã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å†…ã§ã®ã¿è¡Œã†ã“ã¨ãŒã§ãã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      public readonly readOnlyVar: Type;   // èª­ã¿å–ã‚Šå°‚ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£

      constructor(param: Type) {
        this.readOnlyVar = param;
      }
    }

    const instance = new ClassName(value);
    console.log(instance.readOnlyVar);     // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    instance.readOnlyVar = newValue;       // âŒ ã‚¨ãƒ©ãƒ¼: readOnlyVar ã¯ readonly

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class Circle {
      public readonly radius: number;       // èª­ã¿å–ã‚Šå°‚ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£

      constructor(radius: number) {
        this.radius = radius;
      }

      public getArea(): number {
        return Math.PI * this.radius * this.radius;
      }
    }

    const circle = new Circle(5);
    console.log(circle.radius);             // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    console.log(circle.getArea());         // â­• ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
    // circle.radius = 10;                  // âŒ ã‚¨ãƒ©ãƒ¼: radius ã¯ readonly

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ åˆæœŸåŒ–çœç•¥
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚¯ãƒ©ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®åˆæœŸåŒ–ã‚’çœç•¥ã™ã‚‹æ–¹æ³•
    ãƒ»TypeScriptã§ã¯ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒæœªåˆæœŸåŒ–ã®ã¾ã¾ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ããŸã‚ã«ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã‚¨ãƒ©ãƒ¼ã‚’å ±å‘Šã™ã‚‹
    ãƒ»åˆæœŸåŒ–ã‚’çœç•¥ã™ã‚‹ã«ã¯ã€énullã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³æ¼”ç®—å­(!)ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå¾Œã§åˆæœŸåŒ–ã•ã‚Œã‚‹ã“ã¨ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ä¼ãˆã‚‹

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      public uninitializedVar!: Type;      // åˆæœŸåŒ–çœç•¥ (énullã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

      constructor() {
        this.uninitializedVar = initialValue;
      }
    }

    const instance = new ClassName();
    console.log(instance.uninitializedVar); // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class User {
      public name!: string;                // åˆæœŸåŒ–çœç•¥
      public age!: number;                 // åˆæœŸåŒ–çœç•¥

      constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
      }
    }

    const user = new User("Alice", 30);
    console.log(user.name);                // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    console.log(user.age);                 // â­• ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ ã‚¢ã‚¯ã‚»ã‚µ (getter/setter)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚¯ãƒ©ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«å¯¾ã—ã¦ã‚«ã‚¹ã‚¿ãƒ ã®å–å¾—(getter)ãŠã‚ˆã³è¨­å®š(setter)ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®šç¾©ã™ã‚‹æ–¹æ³•
    ãƒ»getterã¯ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å€¤ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã€setterã¯ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å€¤ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰
    ãƒ»getterã¨setterã¯ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãŒã€å®Ÿéš›ã«ã¯ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å‹•ä½œã™ã‚‹
    ãƒ»ãƒãƒ¼ã‚¸ãƒ§ãƒ³4.3ä»¥é™ã§åˆ©ç”¨å¯èƒ½

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      private _value: Type;

      constructor(param: Type) {
        this._value = param;
      }

      get value(): Type {
        return this._value;
      }

      set value(newValue: Type) {
        this._value = newValue;
      }
    }

    const instance = new ClassName(value);
    console.log(instance.value);           // â­• getter ã‚¢ã‚¯ã‚»ã‚¹
    instance.value = newValue;             // â­• setter ã‚¢ã‚¯ã‚»ã‚¹

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class Rectangle {
      private _width: number;
      private _height: number;

      constructor(width: number, height: number) {
        this._width = width;
        this._height = height;
      }

      get width(): number {
        return this._width;
      }

      set width(newWidth: number) {
        if (newWidth <= 0) {
          throw new Error("Width must be positive");
        }
        this._width = newWidth;
      }

      get height(): number {
        return this._height;
      }

      set height(newHeight: number) {
        if (newHeight <= 0) {
          throw new Error("Height must be positive");
        }
        this._height = newHeight;
      }

      get area(): number {
        return this._width * this._height;
      }
    }

- ENTRY:
  EXPLAIN: ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ è‡ªå‹• accessor
  BODY: |
    â–  æ¦‚è¦

    ãƒ»TypeScript 4.3ä»¥é™ã§å°å…¥ã•ã‚ŒãŸã€è‡ªå‹•çš„ã«getterã¨setterã‚’ç”Ÿæˆã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ä¿®é£¾å­
    ãƒ»accessor ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®£è¨€ã™ã‚‹ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒè‡ªå‹•çš„ã«å¯¾å¿œã™ã‚‹getterã¨setterã‚’ç”Ÿæˆ
    ãƒ»ã‚³ãƒ¼ãƒ‰ã®å†—é•·æ€§ã‚’æ¸›ã‚‰ã—ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã‚’ç°¡ç´ åŒ–
    ãƒ»(çŸ­æ‰€)ã‚«ã‚¹ã‚¿ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹å ´åˆã¯æ‰‹å‹•ã§getterã¨setterã‚’å®šç¾©

    â–  åŸºæœ¬æ§‹æ–‡

    class ClassName {
      accessor autoValue: Type;            // è‡ªå‹• accessor

      constructor(param: Type) {
        this.autoValue = param;
      }
    }

    const instance = new ClassName(value);
    console.log(instance.autoValue);       // â­• getter ã‚¢ã‚¯ã‚»ã‚¹
    instance.autoValue = newValue;         // â­• setter ã‚¢ã‚¯ã‚»ã‚¹

    â–  ã‚µãƒ³ãƒ—ãƒ«

    class Person {
      accessor name: string;                // è‡ªå‹• accessor
      accessor age: number;                 // è‡ªå‹• accessor

      constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
      }
    }

    const person = new Person("Alice", 30);
    console.log(person.name);              // â­• getter ã‚¢ã‚¯ã‚»ã‚¹
    console.log(person.age);               // â­• getter ã‚¢ã‚¯ã‚»ã‚¹
    person.name = "Bob";                   // â­• setter ã‚¢ã‚¯ã‚»ã‚¹
    person.age = 35;                       // â­• setter ã‚¢ã‚¯ã‚»ã‚¹

- ENTRY:
  EXPLAIN: extends ã‚¯ãƒ©ã‚¹ç¶™æ‰¿
  BODY: |
    â–  æ¦‚è¦

    ãƒ»æ—¢å­˜ã®ã‚¯ãƒ©ã‚¹ã‚’åŸºã«ã—ã¦æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿
    ãƒ»æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã¯ã€åŸºåº•ã‚¯ãƒ©ã‚¹(ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹)ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç¶™æ‰¿ã€ç‹¬è‡ªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã§ãã‚‹
    ãƒ»ã‚³ãƒ¼ãƒ‰ã®å†åˆ©ç”¨æ€§ã‚’é«˜ã‚ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã®åŸºæœ¬æ¦‚å¿µã€Œis-aã€é–¢ä¿‚ã‚’è¡¨ç¾

    â–  åŸºæœ¬æ§‹æ–‡

    class BaseClass {
      baseProperty: Type;

      constructor(param: Type) {
        this.baseProperty = param;
      }

      baseMethod(): void {
        // åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰
      }
    }

    class DerivedClass extends BaseClass {
      derivedProperty: Type;

      constructor(baseParam: Type, derivedParam: Type) {
        super(baseParam); // åŸºåº•ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
        this.derivedProperty = derivedParam;
      }

      derivedMethod(): void {
        // æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰
      }
    }

    const instance = new DerivedClass(baseValue, derivedValue);
    console.log(instance.baseProperty);     // â­• åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    console.log(instance.derivedProperty);  // â­• æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    instance.baseMethod();                  // â­• åŸºåº•ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰
    instance.derivedMethod();               // â­• æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰

    â–  ã‚µãƒ³ãƒ—ãƒ«(Company/Employee)

    class Company {
      name: string;

      constructor(name: string) {
        this.name = name;
      }

      getCompanyInfo(): string {
        return `Company Name: ${this.name}`;
      }
    }

    class Employee extends Company {
      employeeId: number;

      constructor(name: string, employeeId: number) {
        super(name); // Companyã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å‘¼ã³å‡ºã—
        this.employeeId = employeeId;
      }

      getEmployeeInfo(): string {
        return `Employee ID: ${this.employeeId}, ${this.getCompanyInfo()}`;
      }
    }

    const emp = new Employee("TechCorp", 101);
    console.log(emp.getEmployeeInfo());

- ENTRY:
  EXPLAIN: abstract ã‚¯ãƒ©ã‚¹ç¶™æ‰¿å°‚ç”¨
  BODY: |
    â–  æ¦‚è¦

    ãƒ»`abstract` ã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã€æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ã™ã¹ãæŠ½è±¡ãƒ¡ãƒ³ãƒãƒ¼ï¼ˆãƒ¡ã‚½ãƒƒãƒ‰ï¼ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼‰å®£è¨€
    ãƒ»æŠ½è±¡ã‚¯ãƒ©ã‚¹è‡ªä½“ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ä¸å¯
    ãƒ»æŠ½è±¡ãƒ¡ãƒ³ãƒã¯æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã§å¿…ãšå®Ÿè£…ã™ã‚‹å¿…è¦ã‚ã‚Š

    ãƒ»è¨­è¨ˆä¸Šã®å¥‘ç´„ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰ã‚’æä¾›
    ãƒ»ãƒ¡ãƒ³ãƒãƒ¼ã¯ `protected`/`public` ã‚’ä»˜ã‘ã‚‰ã‚Œã€`private` ã®æŠ½è±¡ã¯ç„¡æ„å‘³
    ãƒ»ä½¿ã„éãã‚‹ã¨ç¶™æ‰¿éšå±¤ãŒç¡¬ããªã‚‹ãŸã‚ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨ã®ä½¿ã„åˆ†ã‘ã‚’æ¤œè¨
      æ„å‘³: æŠ½è±¡ã‚¯ãƒ©ã‚¹ã¯ã€Œéƒ¨åˆ†çš„ã«å®Ÿè£…ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã€ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã€Œå®Œå…¨ã«æœªå®Ÿè£…ã®å¥‘ç´„ã€

    â–  åŸºæœ¬æ§‹æ–‡

    abstract class Base {
      abstract doWork(): string
      protected name: string
      constructor(name: string) { this.name = name }
      describe() { return `${this.name}: ${this.doWork()}` }
    }

    class Derived extends Base {
      private value: number
      constructor(name: string, value: number) {
        super(name)
        this.value = value
      }
      doWork(): string { return `value=${this.value}` }
    }

    const base = new Base()               // âŒ ã‚¨ãƒ©ãƒ¼: æŠ½è±¡ã‚¯ãƒ©ã‚¹ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ä¸å¯
    const d = new Derived("D", 10)
    console.log(d.describe(), d.doWork())

    â–  ã‚¸ã‚§ãƒãƒªãƒƒã‚¯æŠ½è±¡ã‚¯ãƒ©ã‚¹

    abstract class Repository<T> {
      abstract getById(id: string): Promise<T>
      abstract save(entity: T): Promise<void>
    }

    // å®Ÿè£…ä¾‹
    type User = { id: string; name: string }
    class UserRepo extends Repository<User> {
      async getById(id: string) { return { id, name: "unauthorized" } }
      async save(entity: User) { /* persist */ }
    }

- ENTRY:
  EXPLAIN: interface ã‚¯ãƒ©ã‚¹å®Ÿè£…å¥‘ç´„
  BODY: |
    â–  æ¦‚è¦

    ãƒ»`interface` ã¯ã‚¯ãƒ©ã‚¹ãŒå®Ÿè£…ã™ã¹ãå¥‘ç´„ï¼ˆãƒ¡ã‚½ãƒƒãƒ‰ï¼ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã‚·ã‚°ãƒãƒãƒ£ï¼‰ã‚’å®šç¾©
    ãƒ»ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è‡ªä½“ã¯å®Ÿè£…ã‚’æŒãŸãšã€ã‚¯ãƒ©ã‚¹ã¯ `implements` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…
    ãƒ»è¤‡æ•°ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’åŒæ™‚ã«å®Ÿè£…å¯èƒ½

    ãƒ»æŸ”è»Ÿãªè¨­è¨ˆãŒå¯èƒ½ã€ç¶™æ‰¿éšå±¤ã‚’ç¡¬ãã—ãªã„
    ãƒ»æŠ½è±¡ã‚¯ãƒ©ã‚¹ã¨ç•°ãªã‚Šã€çŠ¶æ…‹ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å€¤ï¼‰ã‚’æŒãŸãªã„
    ãƒ»ã‚¯ãƒ©ã‚¹è¨­è¨ˆã®å¥‘ç´„ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ä½¿ç”¨

    â–  åŸºæœ¬æ§‹æ–‡

    interface IWorker {
      doWork(): string
    }

    class Worker implements IWorker {
      doWork(): string {
        return "Working..."
      }
    }

    const w = new Worker()
    console.log(w.doWork())

    â–  è¤‡æ•°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…

    interface IReader {
      read(): string
    }

    interface IWriter {
      write(data: string): void
    }

    class FileHandler implements IReader, IWriter {
      read(): string {
        return "File data"
      }
      write(data: string): void {
        console.log(`Writing: ${data}`)
      }
    }

    const fh = new FileHandler()
    console.log(fh.read())
    fh.write("New data")

- ENTRY:
  EXPLAIN: static ã‚¯ãƒ©ã‚¹é™çš„ãƒ¡ãƒ³ãƒ(ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»`static` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã€ã‚¯ãƒ©ã‚¹ãƒ¬ãƒ™ãƒ«ã§å…±æœ‰ã•ã‚Œã‚‹ãƒ¡ãƒ³ãƒãƒ¼ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰ã‚’å®šç¾©
    ãƒ»é™çš„ãƒ¡ãƒ³ãƒãƒ¼ã¯ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã¯ãªãã€ã‚¯ãƒ©ã‚¹è‡ªä½“ã«å±ã™ã‚‹
    ãƒ»é™çš„ãƒ¡ãƒ³ãƒãƒ¼ã¯ `ClassName.member` ã®å½¢å¼ã§ã‚¢ã‚¯ã‚»ã‚¹

    ãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã‚„å®šæ•°ã‚’ã‚¯ãƒ©ã‚¹ã«é–¢é€£ä»˜ã‘ã‚‹å ´åˆã«ä¾¿åˆ©
    ãƒ»ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ã«ç•°ãªã‚‹çŠ¶æ…‹ã‚’æŒãŸãªã„å…±é€šã®æ©Ÿèƒ½ã‚’æä¾›
    ãƒ»ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£…ã«ã‚‚åˆ©ç”¨å¯èƒ½

    â€» ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³: ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒ1ã¤ã ã‘å­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã€ãã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã™ã‚‹ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³

    â€» ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã€ä»–ã®static ãƒ¡ãƒ³ãƒãƒ¼ä»¥å¤–ã‚’æ··ãœã‚‹æ–¹æ³•ã¯ã©ã†ã‹?

    â–  ã‚µãƒ³ãƒ—ãƒ«1

    class Logger {
      private static _instance?: Logger
      private buffer: string[] = []           // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹çŠ¶æ…‹ï¼ˆé staticï¼‰
      static readonly VERSION = "1.0.0"      // ã‚¯ãƒ©ã‚¹å®šæ•° (static)

      private constructor() {}

      static get instance(): Logger {
        if (!this._instance) this._instance = new Logger()
        return this._instance
      }

      log(msg: string) { this.buffer.push(msg) }    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰
      flush() { console.log(this.buffer.join("\n")); this.buffer = [] }
      static globalInfo() { return `Logger v${this.VERSION}` } // static ãƒ˜ãƒ«ãƒ‘
    }

    // ä½¿ã„æ–¹
    Logger.instance.log("hello")
    console.log(Logger.globalInfo())
    Logger.instance.flush()

    â–  ã‚µãƒ³ãƒ—ãƒ«2: å³æ™‚ç”Ÿæˆã§ export

    â€» ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ãŒ new ã‚’å¤–éƒ¨ã‹ã‚‰è¡Œã‚ã›ãªã„

    class Config {
      private constructor(public readonly env: string) {}
      get isProd() { return this.env === "production" } // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ getter
    }
    export const config = new Config(process.env.NODE_ENV ?? "development")

    â–  ã‚µãƒ³ãƒ—ãƒ«3: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«/ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³

    export const Service = (() => {
      let counter = 0                      // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®çŠ¶æ…‹
      function inc() { counter++; return counter }
      const NAME = "Service"               // å®šæ•°ï¼ˆstatic çš„ï¼‰
      return { inc, get count() { return counter }, NAME }
    })()

    â€» æ³¨æ„ç‚¹
    ãƒ»çŠ¶æ…‹ï¼ˆmutableï¼‰ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å´ã«ç½®ã(static ã« mutable ã‚’ç½®ãã¨ãƒ†ã‚¹ãƒˆã‚„åˆæœŸåŒ–ãŒå›°é›£)
    ãƒ»é™çš„ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚„å®šæ•°ã¯ staticï¼ˆã¾ãŸã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰ã§å•é¡Œãªã—
    ãƒ»ã‚µãƒ–ã‚¯ãƒ©ã‚¹åŒ–ã‚„ DI ã‚’è€ƒãˆã‚‹ãªã‚‰ private constructor ã‚’é¿ã‘ã€ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°ï¼‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒæŸ”è»Ÿã€‚

- ENTRY:
  EXPLAIN: å‚è€ƒ DI (ä¾å­˜æ€§æ³¨å…¥)
  BODY: |
    â–  æ¦‚è¦

    ãƒ»DI (Dependency Injection) ã¯ã€ã‚¯ãƒ©ã‚¹ã®ä¾å­˜é–¢ä¿‚ã‚’å¤–éƒ¨ã‹ã‚‰æ³¨å…¥ã™ã‚‹ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
    ãƒ»ã‚¯ãƒ©ã‚¹ãŒç›´æ¥ä¾å­˜ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è‡ªåˆ†ã§ç”Ÿæˆã›ãšã€å¤–éƒ¨ã‹ã‚‰æä¾›ã•ã‚Œã‚‹
    ãƒ»ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¯ãƒ©ã‚¹ã®çµåˆåº¦ãŒä½ããªã‚Šã€ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã¨æŸ”è»Ÿæ€§ãŒå‘ä¸Š
    ãƒ»nestjs ã‚„ Angular ãªã©ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§åºƒãåˆ©ç”¨

    â–  åŸºæœ¬æ§‹æ–‡

    interface IService {
      doSomething(): void
    }
    class Consumer {
      private service: IService

      constructor(service: IService) {
        this.service = service
      }

      execute() {
        this.service.doSomething()
      }
    }

    class ServiceA implements IService {
      doSomething() {
        console.log("ServiceA doing something")
      }
    }
    class ServiceB implements IService {
      doSomething() {
        console.log("ServiceB doing something")
      }
    }

    // ä½¿ã„æ–¹
    const serviceA = new ServiceA()
    const consumerA = new Consumer(serviceA)
    consumerA.execute()
    const serviceB = new ServiceB()
    const consumerB = new Consumer(serviceB)
    consumerB.execute()

    â–  ã‚³ãƒ³ãƒ†ãƒŠä¾‹

    interface Service {
      doSomething(): void
    }

    class ServiceA implements Service {
      doSomething() { console.log("ServiceA doing something") }
    }

    class ServiceB implements Service {
      doSomething() { console.log("ServiceB doing something") }
    }

    class ServiceContainer {
      private services = new Map<string, Service>()

      register(name: string, service: Service) {
        this.services.set(name, service)
      }

      get(name: string): Service | undefined {
        return this.services.get(name)
      }
    }

    // ä½¿ã„æ–¹
    const container = new ServiceContainer()
    container.register("A", new ServiceA())
    container.register("B", new ServiceB())
    const serviceA = container.get("A")
    serviceA?.doSomething()

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯
  BODY: |
    â–  æ¦‚è¦

    ãƒ»ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹ã¯ã€å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã‚¯ãƒ©ã‚¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®å‹ã‚’æŸ”è»Ÿã«å®šç¾©ã§ãã‚‹
    ãƒ»ã‚¯ãƒ©ã‚¹å®šç¾©æ™‚ã«å‹ãƒ‘ãƒ©ãƒ¡ã‚¿ã‚’æŒ‡å®šã—ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–æ™‚ã«å…·ä½“çš„ãªå‹ã‚’æä¾›
    ãƒ»ã“ã‚Œã«ã‚ˆã‚Šã€åŒã˜ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ç•°ãªã‚‹å‹ã§å†åˆ©ç”¨å¯èƒ½

    â–  åŸºæœ¬æ§‹æ–‡

    class GenericClass<T> {
      private value: T;

      constructor(value: T) {
        this.value = value;
      }

      getValue(): T {
        return this.value;
      }
    }

    const instance1 = new GenericClass<number>(123);
    console.log(instance1.getValue()); // 123

    const instance2 = new GenericClass<string>("abc");
    console.log(instance2.getValue()); // "abc"

    â–  è¤‡æ•°å‹ãƒ‘ãƒ©ãƒ¡ã‚¿

    class Pair<T, U> {
      private first: T;
      private second: U;

      constructor(first: T, second: U) {
        this.first = first;
        this.second = second;
      }

      getFirst(): T {
        return this.first;
      }

      getSecond(): U {
        return this.second;
      }
    }

    const pair = new Pair<number, string>(1, "one");
    console.log(pair.getFirst());  // 1
    console.log(pair.getSecond()); // "one"

    â–  ãƒªã‚¢ãƒ«ãªèª²é¡Œã®ã‚µãƒ³ãƒ—ãƒ«

    class Repository<T> {
      private items: T[] = [];

      add(item: T): void {
        this.items.push(item);
      }

      getAll(): T[] {
        return this.items;
      }

      findById(id: number): T | undefined {
        return this.items.find((item: any) => item.id === id);
      }
    }

    interface User {
      id: number;
      name: string;
    }

    const userRepo = new Repository<User>();
    userRepo.add({ id: 1, name: "Alice" });
    userRepo.add({ id: 2, name: "Bob" });
    console.log(userRepo.getAll());
    console.log(userRepo.findById(1));
