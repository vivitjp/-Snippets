---
#-------------------------------
# TypeScript 2024
#-------------------------------
- ENTRY:
  CATEGORY: TypeScript å‹

- ENTRY:
  EXPLAIN: å‹(ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹)
  BODY: |
    â–  ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹
    b:boolean   = true;                      // Booleanå‹
    s:string    = "abc";                     // æ–‡å­—åˆ—å‹
    n:number    = 1;                         // æ•°å‹
    b:bigint    = 10n;                       // BigIntå‹(ES2020)
    y:symbol    = Symbol();                  // ã‚·ãƒ³ãƒœãƒ«å‹
    u:undefined = undefined;                 // undefinedå‹
    l:null      = null;                      // nullå‹

    â–  é–¢æ•°å‹
    const f:Function = ()=>{}
    const f:Function = ()=>void              // voidå‹

    â–  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹
    a:object={}                              // ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ä»¥å¤–:{},[],()=>{}
    b:Object={}                              // null,undefinedä»¥å¤–å…¨éƒ¨:å¿Œé¿!
    c:{} = {}                                // â‰’Object

    â–  å…¨èƒ½å‹
    const a:any = 10;
    const i:number = a;                      // (å±é™º)ä»£å…¥OK
    const s:string = a;                      // (å±é™º)ä»£å…¥OK
    const o:object = a;                      // (å±é™º)ä»£å…¥OK

    â–  unknownå‹
    const a:unknown = 10;
    const i:number = a;                      // (å®‰å…¨)Error
    const s:string = a;                      // (å®‰å…¨)Error
    const o:object = a;                      // (å®‰å…¨)Error

    if(typeof(a)==="string")                 // å‹Check:v5.3
      const s:string = a;                    // (å®‰å…¨)ä»£å…¥å¯

    â–  neverå‹                                // Genericã§å¤šç”¨ã•ã‚Œã‚‹ 
    type A={ a:"A" }
    type B={ a:"B" }

    const f=(props:A|B)=>{
      switch (props.a) {
        case "A": return ...
        case "B": return ...
        default: let _ng:never = props       // è­¦å‘Š

- ENTRY:
  EXPLAIN: Primitive & Builtin ãƒªã‚¹ãƒˆ
  BODY: |
    type Primitive = number | string | boolean | bigint | symbol | undefined | null
    type Builtin = Primitive | Function | Date | Error | RegExp

- ENTRY:
  EXPLAIN: å‹(AND/OR)
  BODY: |
    type P = { name:string, age: number }
    type A = { city:string, zip: string }

    â–  AND[ & ] ğŸ›‘ä¸¡æ–¹ã‚’æº€ãŸã™

    const NG: P & A = { name: "Eve", age: 18 }                          // âŒ ä¸è¶³
    const NG: P & A = { city: "Paris", zip:"03" }                       // âŒ ä¸è¶³
    const NG: P & A = { name: "Eve", age: 18, city: "Paris" }           // âŒ ä¸è¶³
    const OK: P & A = { name: "Eve", age: 18, city: "Paris", zip:"03" } // â­•ä¸¡æ–¹ã‚’æº€ãŸã™

    â–  OR[ | ] ğŸ›‘ã©ã¡ã‚‰ã‹ä¸€æ–¹ã‚’æº€ãŸã™(æ’ä»–çš„ORã§ã¯ãªã„ã®ã§ä¸¡æ–¹ã§ã‚‚OK)

    const OK: P | A = { name: "Eve", age: 18 }                          // â­• P ã‚’æº€ãŸã™
    const OK: P | A = { city: "Paris", zip:"03" }                       // â­• A ã‚’æº€ãŸã™
    const OK: P | A = { name: "Eve", age: 18, city: "Paris" }           // â­• å°‘ãªãã¨ã‚‚ P ã‚’æº€ãŸã™
    const OK: P | A = { name: "Eve", age: 18, city: "Paris", zip:"03" } // â­• ä¸¡æ–¹ã‚’æº€ãŸã™
    const NG: P | A = { name: "Eve", city:"Eve" }                       // âŒ æ··ç”¨
    const NG: P | A = { city: "Paris", age: 18 }                        // âŒ æ··ç”¨

    â–  XOR ğŸ›‘æ’ä»–çš„OR(Utilityæ´»ç”¨)

    type XOR<T> = { [X in keyof T]?: never | undefined; }

    type XP = P & XOR<A>
    type XA = A & XOR<P>

    const OK: XP | XA = { name: "Eve", age: 18 }                          // â­• P ã‚’æº€ãŸã™
    const OK: XP | XA = { city: "Paris", zip:"03" }                       // â­• A ã‚’æº€ãŸã™
    const NG: XP | XA = { name: "Eve", age: 18, city: "Paris" }           // âŒ æ’ä»–çš„ OR
    const NG: XP | XA = { name: "Eve", age: 18, city: "Paris", zip:"03" } // âŒ æ’ä»–çš„ OR
    const NG: XP | XA = { name: "Eve", city:"Eve" }                       // âŒ æ··ç”¨
    const NG: XP | XA = { city: "Paris", age: 18 }                        // âŒ æ··ç”¨

- ENTRY:
  EXPLAIN: å®šæ•° & widening & narrowing
  BODY: |
    â–  å®šæ•°åŒ– (const)

    ãƒ»const å®£è¨€ã¯ãƒªãƒ†ãƒ©ãƒ«å‹ã¨ã—ã¦æ¨è«–ã•ã‚Œã‚‹
    ãƒ»let å®£è¨€ã¯ä¸€èˆ¬çš„ãªå‹ã¨ã—ã¦æ¨è«–ã•ã‚Œã‚‹

    â–  widening & narrowing

    ãƒ»Widening: å‹ãŒä¸€èˆ¬åŒ–ã•ã‚Œã‚‹ (let å®£è¨€ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£)
    ãƒ»Narrowing: å‹ãŒç‰¹å®šåŒ–ã•ã‚Œã‚‹ (const å®£è¨€ã‚„ as const ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

    â–  ã‚µãƒ³ãƒ—ãƒ«

    let a = 1                                // a:numberå‹
    const a = 1                              // a:1å‹
    const a = {a:1}                          // widening: {a:number}å‹
    const b = {a:1} as const                 // narrowing: {readonly a:1}å‹
    type A = { readonly a:number }           // èª­å–å°‚ç”¨

- ENTRY:
  EXPLAIN: interface vs type
  BODY: |
    interface A { a:number, x?:string }
    interface B { b:number }                 // {b}
    interface B { c:number }                 // ãƒãƒ¼ã‚¸{b,c}
    interface C extends A, B {}              // {}å¿…è¦
    => const c:C ={ a:1, b:2, c:3 }

    type A = { a: number, x?:string }
    type B = A & { b: number }               // intersect
    const b:B = { a: 1, b: 2 }               // å‹é©ç”¨

- ENTRY:
  EXPLAIN: å‹æŒ‡å®š(å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)ã¨ satisfies
  BODY: |
    type A = { a: number; b: string | number }

    const a1: A = { a: 1, b: 2 }
    const a2: A = { a: 1, b: "2" }
    const a3 = { a: 1, b: 2 } as A           //å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
    [NG] const a4 = { a: "1", b: 2 } as A    //ã‚¨ãƒ©ãƒ¼: é–“é•ã£ãŸå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
    [NG] const a5 = <A>{ a: 1, b: 2 }        //ã‚¨ãƒ©ãƒ¼: é–“é•ã£ãŸå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®ä½¿ã„æ–¹(<A>)

    type B = { a: number; b: number }

    const b = { a: 1, b: "2" } as B          // ã‚¨ãƒ©ãƒ¼: é–“é•ã£ãŸå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
    const b = { a: 1 } as unknown as B       // å¼·åˆ¶(å¼·åˆ¶å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³) ğŸ”´ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„

    â–  satisfies(å‹æŒ‡å®š:v4.9)                  // Widening(stringåŒ–)ã‚’é˜²ããªã©

    const a6 = {
      a: 1, b: 2
    } satisfies A                            //{ a: number; b: number; }

    const a7 = {
      a: 1, b: 2
    } as const satisfies A                   //{ readonly a: 1; readonly b: 2; }

- ENTRY:
  EXPLAIN: Keyå–å¾—
  BODY: |
    â–  é…åˆ—ã‹ã‚‰å‹ä½œæˆ
    const x = ["A", "B", "C"] as const

    type Keys = (typeof x)[number]           // "A"|"B"|"C"
    type Y = typeof x[0|1]                   // "A" | "B"

    â–  é…åˆ—ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ä½œæˆ
    const keys = ["A", "B", "C"] as const 
    type Keys = { [K in typeof keys[number]] : number }

    const values:Keys = { "A": 1, "B": 2, "C": 3 }

    â–  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‹ä½œæˆæ™‚(constç„¡)
    const o = { a: "A", b: "B" }

    type X = typeof o                        // {a:number;b:number;}
    type K = keyof X                         // "a" | "b"
    type Y = keyof typeof o                  // "a" | "b"
    type B = (typeof o)[keyof typeof o]      // string <= Widening

    â–  ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‹ä½œæˆæ™‚(constæœ‰)
    const o = { a: "A", b: "B" } as const

    type X = typeof o                        // { readonly a:"A"; readonly b:"B"; } â­•
    type K = keyof X                         // "a" | "b"
    type Y = keyof typeof o                  // "a" | "b"
    type B = (typeof o)[keyof typeof o]      // "A" | "B"

    â–  é…åˆ—ã‹ã‚‰ENUMä½œæˆ
    const array = ["A", "B", "C", "D"] as const
    const ENUM = makeEnum(array);

    function makeEnum<T extends readonly string[]>(é…åˆ—: T) {
      return é…åˆ—.filter(Boolean).reduce(
      (acc, cur) => ({ ...acc, [cur]: cur }),
      {} as {[key in typeof é…åˆ—[number]]: string}
      );
    }

- ENTRY:
  EXPLAIN: å‹å–å¾—ã¨KV(MappedType & Record<> æ¯”è¼ƒ)
  BODY: |
    â–  Objectå‹å®£è¨€

    type Section = { tech: string, sales: string }
    type Person = { name:string, age: number }

    â–  MappedType + Record<>

    type SecPersonA = {[P in keyof Section]?: Partial<Record<keyof Person, Function>> }

      â€» Record<Partial<keyof Person>, Function> ã¯ Record<keyof Person, Function> ã¨åŒã˜
         Partial ã®æ„å‘³ãŒãªããªã‚‹ãŸã‚æ³¨æ„

    const secPersonA1:SecPersonA  = {
        tech: {name:()=>{}, age:()=>{}},
        sales: {name:()=>{}}
    }

    const secPersonA2:SecPersonA  = {
        tech: {name:()=>{}, age:()=>{}},
        //sales: {name:()=>{}} éƒ¨åˆ†ä½¿ç”¨OK
    }

    â–  Record<> + Record<>

    type SecPersonB = Partial<Record<keyof Section, Partial<Record<keyof Person, Function>>>>

    const secPersonB1:SecPersonB  = {
        tech: {name:()=>{}, age:()=>{}},
        sales: {name:()=>{}}
    }

    const secPersonB2:SecPersonB  = {
        tech: {name:()=>{}, age:()=>{}},
        //sales: {name:()=>{}} éƒ¨åˆ†ä½¿ç”¨OK
    }

    â–  Record<> + Objectå‹å®£è¨€{}
    type SecPersonC = Partial<Record<keyof Section, {func?:Function, name?:string, }>>

    const secPersonC1:SecPersonC  = {
        tech: {name:"john", func:()=>{}},
        sales: {func:()=>{}}
    }

- ENTRY:
  EXPLAIN: æ·»å­—ã‚¢ã‚¯ã‚»ã‚¹
  BODY: |
    type T = { a:{ x:number } }
    const a: T["a"]      = { x: 123 }
    const b: T["a"]["x"] = 123

- ENTRY:
  EXPLAIN: å‹å†…ã®å‹æµç”¨
  BODY: |
    type T = { a:string, b:number }
    type A = T["a"];                         // string
    type B = T["a"|"b"];                     // string|number

- ENTRY:
  EXPLAIN: Objectå‹ã®KeyæŒ‡å®š
  BODY: |
    type S
      = { [ index: string ]: number }        // *åç§°ä»»æ„
      = Record<string, number>               // Utility
      = Record<PropertyKey, number>          * PropertyKey=string,number,symbol
    const c:S = { a:1, b:2, c:3 }

- ENTRY:
  EXPLAIN: Mapped Types([key in T])
  BODY: |
    type A = number | string
    type X = { [key in A]: number }

    type B = { a: number; b: string }
    type Y = { [key in keyof B]: number }         //{ a:number, b:number }

    const o: B = { a: 1, b: "a" }
    type Z = { [key in keyof typeof o]: number }  //{ a:number, b:number }

- ENTRY:
  EXPLAIN: MappedType & Record<> æ¯”è¼ƒ
  BODY: |
    type Sample = "A" | "B"
    type ObjA = {[name in Sample]: number}
    type ObjB = Record<Sample, number>

    const objA1:ObjA = { "A": 1 }
    const objA2:ObjA = { "A": 1, "B": 2 }

    const objB1:ObjB = { "A": 1 }
    const objB2:ObjB = { "A": 1, "B": 2 }

- ENTRY:
  EXPLAIN: ã‚¨ã‚¤ãƒªã‚¢ã‚¹
  BODY: |
    type X<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }
    type A = X<{ a: string }>                //{ getA:() => string }

- ENTRY:
  EXPLAIN: åˆ—æŒ™ä½“
  BODY: |
    enum ColorNo {
      Red = 1,                               // ColorNo.Red = 1
      Green,                                 // ColorNo.Green = 2
      Blue,                                  // ColorNo.Blue = 3
    }

    enum ColorName {
      Red = "red",                           // ColorName.Red = "red"
      Blue = "blue",                         // ColorName.Blue = "blue"
    }

#-------------------------------
# Generics
#-------------------------------
- ENTRY:
  CATEGORY: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹(å‹å®£è¨€)
  BODY: |
    type G<T> = { a: T }
    const a:G<number> = { a: 1 }
    const b:G<string> = { a: "x" }

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹(åˆ¶ç´„)
  BODY: |
    â–  åŸºç¤
    type A<T extends number> = { a: T }
    const a: A<number> = { a: 1 }

    â–  å®šæ•°é¸æŠ
    type ABC = "A" | "B" | "C"
    type B<T extends ABC> = { a: T }
    const b: B<ABC> = { a: "A" }

    â–  Objectå‹åˆ¶ç´„
    type Obj = {
      n: string
      a: number
    }
    type C<T extends Obj> = T
    const c: C<Obj> = {
      n: "a",
      a: 1,
    }

    â–  æ—¢å­˜ Objectå‹å–å¾—ã—ã¦åˆ¶ç´„
    const obj = { n: "abc", a: 1 }

    type D<T extends typeof obj> = T
    const d: D<Obj> = { n: "a", a: 1 }

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹(ä¸‰é …åˆ†å²)
  BODY: |
    â–  ä¸‰é …åˆ†å² extends(=if)
    type A = { a: string }
    type B = { a: string }
    type C = { a: string; b: number }

    type AB = A extends B ? number : string  //ä¸‰é …åˆ†å²: number
    type BC = B extends C ? number : string  //ä¸‰é …åˆ†å²: string

    type Y<T> = T extends true ? 1 : 0       // ä¸‰é …åˆ†å²

    type Z<T extends boolean>                // (å‰åŠ)å‹åˆ¶ç´„: T ã¯ Boolean
      = T extends true ? "a" : "b"           // (å¾ŒåŠ)ä¸‰é …åˆ†å²

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹(å˜ç´”å‹å¤‰æ›)
  BODY: |
    â–  ä¸‰é …åˆ†å²(:never) extends
    type MakeArray<T>
      = T extends any ? T[] : never          //è¦ç´ ã‚’é…åˆ—ã«å¤‰æ›
    type X1 = MakeArray<string>              // string[]
    type X2 = MakeArray<string | number>     // string[]|number[] æƒ³å®šå¤–

    type MakeArrayBetter<T>
      = [T] extends [any] ? T[] : never      //æ”¹å–„
    type Y = MakeArrayBetter<string | number> // (string|number)[] æƒ³å®šé€šã‚Š

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹(å†…éƒ¨å‹å–å¾—ã¨å¤‰æ›)
  BODY: |
    â–  ä¸‰é …åˆ†å²(:infarã§å†…åŒ…ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å–ã‚Šå‡ºã—)

    //æ‚ªä¾‹(inferä¸è¦ãªã®ã«ä½¿ç”¨)
    type WrongConvert<T extends any>
      = T extends infer U ? [U] : never
    => Constraining the generic type `T` to `any` does nothing and is unnecessary

    type RipPromise<T extends Promise<any>>  // Promiseã‚’é™¤å»
      = T extends Promise<infer U> ? U : never
    type X = RipPromise<Promise<string>>     //string

    // ä¾‹: é–¢æ•°ã®æˆ»ã‚Šå€¤å–å¾—
    type ReturnType<T>
      = T extends (...args: any[]) => infer R ? R : any
    type Y = ReturnType<() => string>        // string

    // ä¾‹: é…åˆ—ã®ç¬¬1è¦ç´ ãŒæ•°ãªã‚‰å–å¾—
    type FirstElemIfNum<T>
      = T extends [infer U extends number, ...unknown[]] ? U : never
    type Z = FirstElemIfNum<[1, 2, 3]>       // 1 : æœ€åˆã®è¦ç´ 

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹(æ–‡å­—åˆ—åˆ†å‰²)
  BODY: |
    // â–  extends => æ–‡å­—åˆ—åˆ†å‰²
    // ä¾‹: æ–‡å­—åˆ—ã‚’ãƒ‘ã‚¹ã‚«ãƒ«ã‚±ãƒ¼ã‚¹ã«å¤‰æ›´
    type PascalCase<S extends string> = S extends `${infer H}${infer T}`
      ? `${Capitalize<H>}${Lowercase<T>}`
      : S
    type G = PascalCase<"ABC">               //"Abc"

#-------------------------------
# Function
#-------------------------------
- ENTRY:
  CATEGORY: é–¢æ•°

- ENTRY:
  EXPLAIN: é–¢æ•°(å¼•æ•°å‹,æˆ»ã‚Šå€¤å‹)
  BODY: |
    const f:Function = (a:number) => a       // é–¢æ•°å‹

    type G = {(a:number): void}              // å¾“æ¥é–¢æ•°å‹
    type A = (a:number) => void              // Arrowé–¢æ•°å‹
    const f: A = () => 1                     // ãƒ‘ãƒ©ãƒ¡ã‚¿å°‘ãªã„å ´åˆã¯PASS!
    const res = f()                          // å¼•æ•°ãªã—:NG
    const res = f(1)                         // å¼•æ•°ã‚ã‚Š:OK

    type E = () => void                      // æˆ»ã‚Šå€¤void
    [NG] const f:E = (a:number) => a         // ãƒ‘ãƒ©ãƒ¡ã‚¿å°‘ãªã„å ´åˆã¯NG
    [NG] const res = f(1)                    // æˆ»ã‚Šå€¤:number

- ENTRY:
  EXPLAIN: é–¢æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
  BODY: |
    function F(a:string):void
    function F(a:string[]):void
    function X(a:string|string[]):void
    {
      if(typeof a==="string") {...} else {...}
    }

    â–  é–¢æ•°å‹å®£è¨€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
    type W = {
      (a:number): number;
      (a:string): number;
    }
    const f:W = (a:number|string):number =>{
      if(typeof a==="string") {...} else {...}
    }

- ENTRY:
  EXPLAIN: é–¢æ•°Callbackå¼•æ•°ã®ãƒ‘ãƒ©ãƒ¡ã‚¿æ•°
  BODY: |
    const f = (x: (a: number) => void) => {}
    f(() => {})                              // ãƒ‘ãƒ©ãƒ¡ã‚¿å°‘ãªã„å ´åˆã¯PASS!
    f((a: number) => {})                     // ãƒ‘ãƒ©ãƒ¡ã‚¿æ•°ä¸€è‡´: OK
    f((a: number, b: number) => {})          // ãƒ‘ãƒ©ãƒ¡ã‚¿æ•°å¤š: NG

    const f = (cb: (...a: number[]) => number, num: number[]) => cb(...num)
    const cb = (a: number, b: number, ...c:number[]): number => a * b
    f(cb, [2])                               // NaN
    f(cb, [2, 3])                            // 6
    f(cb, [2, 3, 4])                         // 6

- ENTRY:
  EXPLAIN: é–¢æ•°å¼•æ•° Sub/Super Set
  BODY: |
    type Sub = { x:number; y:number }
    let sub = (p: Sub) => {...}

    type Super = { x:number; y:number; z:number }
    let super = (p: Super) => {...}

    super = sub                              // å¤š <- å°‘: OK
    sub = super                              // å°‘ <- å¤š: NG(æ—§OK)

- ENTRY:
  EXPLAIN: ã‚³ãƒ³ãƒ‘ãƒ‹ã‚ªãƒ³(å¼•æ•°å‹ã¨é–¢æ•°åŒå)
  BODY: |
    â–  React Moduleã®å‘½åè¦å‰‡
    export type A = { name:string }
    export const A = (props:A):JSX.Element => {...}

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°ãƒ‘ãƒ©ãƒ¡ã‚¿
  BODY: |
    â–  Reactã§ã®æ›¸å¼(,ä»˜ã)
    const g1 = <T,>(a: T): void          => { console.log(a) }
    const g2 = <T,>(a: T): T             => { return a }
    const g3 = <T, S>(a: T, b: S): T | S => { return 1 ? a : b }
    const g4 = <T=number,>(a: T)         => { console.log(a) }
    const g5 = <T extends number>(a: T)  => { console.log(a) }

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°å‹
  BODY: |
    type A1<T> = {(a: T[]): T}               // ä¸€èˆ¬é–¢æ•°
    type A2<T> = (a: T[]) => T               // Arrowé–¢æ•°
    type A3 = {                              // é–¢æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
      A: <T>(a: T[]) => {...}; 
      B: <T>(b: T[]) => {...};
    }

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯JSXé–¢æ•°
  BODY: |
    type A<T> = { a: T }

    const A = <T extends PropertyKey>({ a }: P<T>) => {
      return <>{a}</>
    }
    const B = () => <A<number> a={123} />

- ENTRY:
  EXPLAIN: é–¢æ•°ã®å¼•æ•°åˆ¶é™
  BODY: |
    const f1 = (props: { a: string }) => props.a

    // å¤šå±æ€§ã®é–“æ¥ä»£å…¥ OK
    const a = { a: "a", b: "b" }
    f1(a)

    // å¤šå±æ€§ã®ç›´æ¥ä»£å…¥ NG
    f1({ a: "a", b: "b" })

    //ä½™åˆ†å¼•æ•°ã®å—ã‘å…ˆè¿½åŠ 
    type X = { a: string; [x: string]: unknown }
    const f2 = (props: X) => props.a

    // å¤šå±æ€§ã®ç›´æ¥ä»£å…¥ OK!
    f2({ a: "a", b: "b" })

- ENTRY:
  EXPLAIN: å‹ã‚¬ãƒ¼ãƒ‰ã¨å‹æƒ³å®š
  BODY: |
    type ABC = { a: number }
    type XYZ = { x: number }

    // å‹ã‚¬ãƒ¼ãƒ‰é–¢æ•°
    const isABC1 = (props: ABC | XYZ) => {
      return "a" in props && typeof props.a === "number"
    }

    // å‹ã‚¬ãƒ¼ãƒ‰é–¢æ•°:NG (ä¸ååˆ†ãªå‹check)
    const isABC2 = (props: ABC | XYZ) => {
      return typeof props.a === "number"     //Error
    }

    // å‹ã‚¬ãƒ¼ãƒ‰é–¢æ•°:Type Predicate
    //ã€Œprops is ABCã€ã¯æˆ»ã‚Šå€¤ã®å‹ã§ã¯ãªã„ => å¿…ãš boolean ã‚’è¿”ã™ã“ã¨
    const isABC3 = (props: ABC | XYZ): props is ABC => {
      return !!(props as ABC).a
    }

#-------------------------------
# Class
#-------------------------------
- ENTRY:
  CATEGORY: Class

- ENTRY:
  EXPLAIN: ã‚¯ãƒ©ã‚¹å¤‰æ•°
  BODY: |
    interface A {
      c: number // å¤‰æ•°ã¯publicã®ã¿
    }

    // Access Modifier
    // private      ã‚¹ã‚³ãƒ¼ãƒ—: ãã®Class
    // protected    ã‚¹ã‚³ãƒ¼ãƒ—: ãã®Classã¨ç¶™æ‰¿å…ˆClassã®ã¿
    // public       ã‚¹ã‚³ãƒ¼ãƒ—: ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

    class Abc implements A {
      private _a = 0                         // _ã®æ…£ç¿’:åˆæœŸå€¤è¦
      protected b = 0                        // åˆæœŸå€¤è¦
      c = 0                                  // default: Public
      [NG] d: number                         // åˆæœŸå€¤ãªã—
      readonly y: number = 0                 // å®šæ•°åŒ–
      accessor k: number = 0                 // set() & get() ä»£æ›¿: v4.9
    }

    const abc = new Abc()
    abc.c = 1       // public
    abc.k = 1       // Auto accessor
    [NG] abc._a     // private
    [NG] abc.b      // protected
    [NG] abc.y = 1  // Readonly

- ENTRY:
  EXPLAIN: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¯ãƒ©ã‚¹
  BODY: |
    interface A<T> {
      a: T
    }
    interface B<T> extends A<T> {
      b: T
    }
    class A implements B<number> {
      b = 0
      a = 0
    }

- ENTRY:
  EXPLAIN: ã‚¯ãƒ©ã‚¹ç¶™æ‰¿
  BODY: |
    class Base {
      baseA: number
      constructor(a: number) {
        this.baseA = a
      }
    }

    class Derived extends Base {
      b = 0
      constructor(a: number, b: number) {
        super(a)
        this.b = b
      }
    }

    const A = new Derived(1, 2)
    console.log(A.baseA, A.b)

- ENTRY:
  EXPLAIN: ã‚¯ãƒ©ã‚¹ç¶™æ‰¿å°‚ç”¨
  BODY: |
    abstract class Base {
      baseA: number
      abstract baseB: number //ç¶™æ‰¿å°‚ç”¨
      constructor(a: number) {
        this.baseA = a
        // this.baseB = 1 ä»£å…¥ä¸å¯
      }
    }

    class Derived extends Base {
      b = 0
      baseB = 1 //å®Ÿè£…å¿…é ˆ
      constructor(a: number, b: number) {
        super(a)
        this.b = b
        this.baseB = 0
      }
    }

    //[NG] const B = new Base(1)
    const A = new Derived(1, 2)
    console.log(A.baseA, A.b, A.baseB)

- ENTRY:
  EXPLAIN: ã‚¯ãƒ©ã‚¹
  BODY: |
    class ClassA {
      private _a = 0
      accessor _b = 0                        // è‡ªå‹• accessor
      
      constructor(a: number) { this._a = a } // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
      
      c(x: number) { return (this._a = +x) } //ãƒ¡ã‚½ãƒƒãƒ‰

      get a() { return this._a }             // ãƒãƒ‹ãƒ¥ã‚¢ãƒ« accessor
      set a(x: number) { this._a = x }
    }

    const classA = new ClassA(1)             // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
    classA.a = 5                             // ãƒãƒ‹ãƒ¥ã‚¢ãƒ« accessor
    classA._b = 5                            // è‡ªå‹• accessor
    classA.c(3)                              // publicé–¢æ•°

- ENTRY:
  EXPLAIN: static ã‚¯ãƒ©ã‚¹
  BODY: |
    class A {
      static a: number                       // åˆæœŸå€¤ä¸è¦
      static { this.a = 1 }                  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
      static f(x: number) { this.a = x }     //ãƒ¡ã‚½ãƒƒãƒ‰
    }

    A.a = 2                                  // Staticå€¤(ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ä¸è¦)
    A.f(3)                                   // Staticé–¢æ•°(ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ä¸è¦)

#-------------------------------
# By Version
#-------------------------------
- ENTRY:
  CATEGORY: New Versionã®æ›´æ–°æ©Ÿèƒ½

- ENTRY:
  EXPLAIN: |
    v5.3 é™çš„/å‹•çš„ import type
  BODY: |
    import o from "a.json" with {type:"json"}

    const o = await import("a.json", { with:{type:"json"} });

- ENTRY:
  EXPLAIN: |
    v5.3: unkonwnå‹ check
  BODY: |
    const value: unknown = "a"
    if(typeof(value)==="string")
      const s:string = value;                // (å®‰å…¨)ä»£å…¥

- ENTRY:
  EXPLAIN: |
    v5.2 Instanceå‰Šé™¤æ™‚å®Ÿè¡Œ
  BODY: |
    class AFile implements Disposable {
      ...
      //class instance 
      [Symbol.dispose]() { 
        //instanceå‰Šé™¤æ™‚ã®å®Ÿè¡Œå®Ÿè£…
      }
    }

    //tryCatch ã‚µãƒ³ãƒ—ãƒ«
    const file = new AFile(".file");
    try { ... }
    catch { ... }
    finally { 
      file[Symbol.dispose]()
    }

- ENTRY:
  EXPLAIN: |
    v5.2 Functionå‰Šé™¤æ™‚ã®å®Ÿè¡Œ
  BODY: |
    â–  åŒæœŸ
    function log(id:string): Disposable {
      ...
      return { 
        [Symbol.dispose]() { 
          //ãƒ¡ã‚½ãƒƒãƒ‰å‰Šé™¤æ™‚ã®å®Ÿè¡Œå®Ÿè£…
        }
      }
    }

    â–  éåŒæœŸ
    function log(id:string): AsyncDisposable {
      ...
      return {
        async [Symbol.asyncDispose]() {
          await someMethod();
        }
      }
    }

- ENTRY:
  EXPLAIN: |
    v5.2 Decorator Metadata
  BODY: |
    interface X {
      name: string;
      metadata: Record<PropertyKey, unknown>;
    }

    function setMetadata(_target:any, x:X){
      x.metadata[x.name] = true;
    }

    class AClass {
      @setMetadata
      foo = 123;

      @setMetadata
      accessor bar = "hello!";

      @setMetadata
      baz() { }
    }

    const md = AClass[Symbol.metadata];
     = { "bar":true,"baz":true,"foo":true }

- ENTRY:
  EXPLAIN: |
    v5.2 Tuple
  BODY: |
    type T1<T> = [T, T]                      // no-named
    type T2<T> = [f:T, s:T]                  // named
    type T3<T> = [f:T, s:T, rest:...T[]]

    type X = [a:string, b:string]
    type Y = [number, number]
    type Z = [...Label, ...NoLabel]
    = [number, number, string, string]

- ENTRY:
  EXPLAIN: |
    v5.1 Function Returns Undefined
  BODY: |
    å‰²æ„›

- ENTRY:
  EXPLAIN: ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—
  BODY: |
    ã‚¯ãƒ©ã‚¹å®£è¨€  Class Decorators
    ãƒ¡ã‚½ãƒƒãƒ‰    Method Decorators
    ã‚¢ã‚¯ã‚»ã‚µ    Accessor Decorators
    ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£  Property Decorators
    ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿  Parameter Decorators

- ENTRY:
  EXPLAIN: |
    v5.0 å³æ™‚é–¢æ•°ã«ã‚ˆã‚‹å®šç¾©
  BODY: |
    â–  è¨­å®šãŒä¸å¿…è¦
    tsconfig.json
      "experimentalDecorators": false        // true ã§ã‚¨ãƒ©ãƒ¼

    â–  å³æ™‚é–¢æ•°ã«ã‚ˆã‚‹å®šç¾©
    function decoLog(orgMethod:any, _context:any){
      return (function(this: any, ...args:any[]){
        console.log(_context)             
        // Print:2
        // {
        //   "kind": "method",
        //   "name": "get",
        //   "static": false,
        //   "private": false,
        //   "access": {},
        //   "metadata": undefined
        // } 
        const result = orgMethod.call(this, ...args)
        return result;
      })()
    }

    class A{
      a: string;
      constructor(a:string){ this.a = a }
      @decoLog
      get(A:string){
        console.log(`Hi ${this?.a || "Oops"}`) 
        // Print:1 "Hi Oops"
        // Print:4 "Hi John"
      }
    }

    const p = new A("John");
    console.log("Instance")
    // Print:3 "Instance"
    p.get("ABC")
    console.log("Method Called")
    // Print:5 "Method Called"

- ENTRY:
  EXPLAIN: |
    v5.0 ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ«é †
  BODY: |
    â–  è¨­å®š
    tsconfig.json
      "experimentalDecorators": true

    â–  ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ«é †
    function first() {
      console.log("first(): factory evaluated");
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("first(): called");
      };
    }

    function second() {
      console.log("second(): factory evaluated");
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("second(): called");
      };
    }

    class ExampleClass {
      accessor name: string = ""
      @first()  // ã‚³ãƒ¼ãƒ«é †2
      @second() // ã‚³ãƒ¼ãƒ«é †1
      method(name: string) { this.name = name }
    }

- ENTRY:
  EXPLAIN: |
    v5.0 ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ»å®šæ•°
  BODY: |
    type A = { a: readonly string[] };

    const func = <T extends A>(obj: T): T["a"] => {
      return obj.a;
    };
    const res1 = func({ a: ["A", "B"] });    // string[]

    â–  Genericå®šæ•°
    const cFunc = <const T extends A>(obj: T): T["a"] => {
      return obj.a;
    };
    const res2 = cFunc({ a: ["A", "B"] });   // readonly ["A", "B"]

- ENTRY:
  EXPLAIN: |
    v4.9 Wideningé˜²æ­¢
  BODY: |
    â–  Wideningé˜²æ­¢
    type A = { x:string; y:number; }
    const a1: A
     = { x: "X", y: 1 } as const             //{ x:string; y:number; }
    const a2
     = { x: "X", y:1 } as const satisfies A  //{readonly x:"X", readonly y:1}

    â–  Tupleã®å‹ä¿å­˜(Wideningé˜²æ­¢)
    type Colors = "a"|"b"
    type RGB = [r:number,g:number,b:number]  //Tuple

    const x: Record<Colors, string|RGB> = {  // Widening!!
      a: [255,0,255],                        // string | RGB
      b: "#00ff00",                          // string | RGB
    }

    const y = {                              // Widening!!
      a: [255,0,255],                        // number[]
      b: "#00ff00",                          // string *
    } satisfies Record<Colors, unknown>

    const z = {                              // Wideningé˜²æ­¢
      a: [255,0,255],                        // [number,number,number]
      b: "#00ff00",                          // string
    } satisfies Record<Colors, string|RGB>

    [NG] const c = z.a.at(0);                // é…åˆ—at():NG
    const c = z.a[0];                        // æ·»å­—å‡¦ç†:OK

- ENTRY:
  EXPLAIN: |
    v4.9 ã‚¢ã‚¯ã‚»ãƒƒã‚µ
  BODY: |
    class X {
      accessor a: string;                    // accessor
      constructor(a: string){
        this.a = a
      }                                      // get,set å®šç¾©ä¸è¦
    }
    const x = new X("a")
    const res = x.a                          // get getA()
    x.a = "b"                                // set setA()

- ENTRY:
  EXPLAIN: |
    v4.9 NaNã®æŒ™å‹•
  BODY: |
    NaN == NaN, NaN === NaN                  // Before: false
    NaN == NaN, NaN === NaN                  // After : true

- ENTRY:
  EXPLAIN: |
    v4.8 Unknownå‹
  BODY: |
    const x:unknown
    const y:{}|null|undefined
    x = y;                                   // Before: OK
    y = x;                                   // After : OK
