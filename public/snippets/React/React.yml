---
#-------------------------------
# React Version History
#-------------------------------
- ENTRY:
  CATEGORY: バージョン履歴

- ENTRY:
  EXPLAIN: バージョン 19
  BODY: |
    ■ Version 19 (2024年12月予定)

    - Server Components and Actions
      - Server Actions: サーバーサイドでのフォーム処理
      - useActionState: アクションの状態管理
      - useFormStatus: フォームのステータス取得
      - useOptimistic: 楽観的更新
    - React Compiler: 自動メモ化によるパフォーマンス最適化
    - Improved Hydration: ハイドレーションの改善
    - New Hooks: useEvent (イベントハンドラのメモ化)
    - Concurrent Features の安定化
    - パフォーマンスの最適化とバグ修正

- ENTRY:
  EXPLAIN: バージョン 18
  BODY: |
    ■ Version 18 (2022年3月)

    - Concurrent Features (並行機能)
      - startTransition: 緊急性の低い更新を遅らせる
      - useDeferredValue: 値の更新を遅らせる
    - Automatic Batching: 複数の状態更新を自動的にバッチ処理
    - Suspense on the Server: サーバーサイドでの Suspense サポート
    - New Client and Server Rendering APIs
      - createRoot: 新しいルートAPI
      - hydrateRoot: ハイドレーションの改善
    - Strict Mode の改善: 副作用の検出強化

- ENTRY:
  EXPLAIN: バージョン 17
  BODY: |
    ■ Version 17 (2020年10月)

    - New JSX Transform: JSX の変換を改善（React のインポート不要）
    - Event Delegation の改善: イベント処理の効率化
    - Suspense for Code Splitting の改善
    - Concurrent Mode の実験的サポート
    - React DevTools Profiler の改善

- ENTRY:
  EXPLAIN: バージョン 16
  BODY: |
    ■ Version 16.8 (2019年2月) - Hooks の導入

    - useState: 関数コンポーネントでの状態管理
    - useEffect: 副作用の処理
    - useContext: コンテキストの使用
    - その他の Hooks: useReducer, useCallback, useMemo, useRef, etc.

    ■ Version 16.3 (2018年3月)

    - Context API の改善
    - createRef と forwardRef の導入
    - StrictMode の導入

    ■ Version 16.0 (2017年9月) - Fiber アーキテクチャ

    - Error Boundaries: エラーハンドリング
    - Portals: DOM ツリー外へのレンダリング
    - Fragments: 不要なラッパー要素の回避
    - Render Props パターン

#-------------------------------
# Basic Components
#-------------------------------
- ENTRY:
  CATEGORY: コンポーネントとPropsの型

- ENTRY:
  EXPLAIN: 関数コンポーネント
  BODY: |
    ■ 関数コンポーネントの基本構文

    ・単純な関数として定義
    ・JSX を直接返す
    ・TypeScript では React.FC または直接の関数型を使用

    // React.FC
    const Greeting: React.FC<{ name: string }> = ({ name }) => {
      return <h1>Hello, {name}!</h1>;
    };

    // 直接の関数型
    const Greeting = ({ name }: { name: string }) => {
      return <h1>Hello, {name}!</h1>;
    };

    ■ Props の扱い

    ・引数として受け取り、分割代入で使用
    ・children は特別な prop として扱われる

    interface Props {
      title: string;
      children?: React.ReactNode;
    }

    const Card: React.FC<Props> = ({ title, children }) => (
      <div className="card">
        <h2>{title}</h2>
        <div className="content">{children}</div>
      </div>
    );

    // 使用例
    <Card title="My Card">
      <p>This is the content.</p>
    </Card>

    ■ defaultProps

    ・デフォルトパラメータを使用
    ・または DefaultProps ユーティリティ型

    const Button = ({ 
      text = 'Click me', 
      onClick 
    }: { 
      text?: string; 
      onClick: () => void; 
    }) => (
      <button onClick={onClick}>{text}</button>
    );

    // または
    type ButtonProps = {
      text: string;
      onClick: () => void;
    };

    const Button: React.FC<ButtonProps> = ({ text, onClick }) => (
      <button onClick={onClick}>{text}</button>
    );

    Button.defaultProps = {
      text: 'Click me'
    };

- ENTRY:
  EXPLAIN: クラスコンポーネント
  BODY: |
    ■ クラスコンポーネントの基本構文

    ・React.Component を継承したクラスとして定義
    ・render() メソッドで JSX を返す
    ・TypeScript ではジェネリクスで Props と State の型を指定

    interface Props {
      title: string;
    }

    interface State {
      count: number;
    }

    class Counter extends React.Component<Props, State> {
      constructor(props: Props) {
        super(props);
        this.state = {
          count: 0
        };
      }

      render() {
        return (
          <div>
            <h1>{this.props.title}</h1>
            <p>Count: {this.state.count}</p>
            <button onClick={this.handleClick}>Increment</button>
          </div>
        );
      }

      private handleClick = () => {
        this.setState({ count: this.state.count + 1 });
      };
    }

    ■ State の管理

    ・this.state でアクセス
    ・this.setState() で更新（非同期）
    ・関数型更新で前の state に依存

    this.setState((prevState) => ({
      count: prevState.count + 1
    }));

    ■ ライフサイクルメソッド

    ・componentDidMount: コンポーネントがマウントされた後
    ・componentDidUpdate: 更新された後
    ・componentWillUnmount: アンマウントされる前

    class Example extends React.Component {
      componentDidMount() {
        console.log('Component mounted');
      }

      componentDidUpdate(prevProps, prevState) {
        console.log('Component updated');
      }

      componentWillUnmount() {
        console.log('Component will unmount');
      }

      render() {
        return <div>Example</div>;
      }
    }

    ■ Props の扱い

    ・this.props でアクセス（読み取り専用）
    ・デフォルト props は static defaultProps で設定

    class Greeting extends React.Component<{ name: string }> {
      static defaultProps = {
        name: 'World'
      };

      render() {
        return <h1>Hello, {this.props.name}!</h1>;
      }
    }

    ■ イベントハンドラー

    ・クラスメソッドとして定義
    ・this のバインドが必要（アロー関数推奨）

    class Button extends React.Component {
      private handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
        console.log('Button clicked', event);
      };

      render() {
        return <button onClick={this.handleClick}>Click me</button>;
      }
    }

- ENTRY:
  EXPLAIN: children
  BODY: |
    ■ 概要

    ・コンポーネントの子要素を表す特別な prop
    ・PropsWithChildren ユーティリティ型を使用して children を含む Props 型を定義

    ■ React.PropsWithChildren

    type Props = {
      title: string
      // children: React.ReactNode  // 宣言不要
    }

    export const LayoutReactChildren = ({
      title,
      children,
    }: React.PropsWithChildren<Props>): React.ReactElement => {
      return (
        <div>
          <div> {title} </div>
          {children}
        </div>
      )
    }

    ■ Table コンポーネント(children)

    export type Data = {
      name: string
      age: number
    }

    export const Table = ({ data }: { data: Data[] }) => {
      return (
        <>
          {data.map((d) => (
            <div>
              <div> {d.name} </div>
              <div> {d.age} </div>
            </div>
          ))}
        </>
      )
    }

    ■ 使用例: index.tsx

    import { Data, TableA } from "./TableA"
    import { LayoutReactChildren } from "./LayoutReactChildren"

    const data: Data[] = [
      { name: "Alice", age: 30 },
      { name: "Bob", age: 25 },
    ]

    export const ReactChildren: React.FC = () => {
      return (
        <LayoutReactChildren title="User List">
          <TableA data={data} />
          {/* <TableB data={data} /> 状況によって B を選択   */}
        </LayoutReactChildren>
      )
    }

- ENTRY:
  EXPLAIN: children(with)
  BODY: |
    ■ 概要

    ・children with パターン
    ・レイアウトコンポーネントが子コンポーネントをラップするための方法

    ■ Layout: Layout.tsx

    export const Layout = (
      props: React.PropsWithChildren<unknown>
    ): React.ReactElement => {
      return (
        <div>
          <Text> User List </Text>
          {props.children}
        </div>
      )
    }

    Layout.with = (Component: React.ComponentType) => {
      return () => (
        <Layout>
          <Component />
        </Layout>
      )
    }

    ■ Table コンポーネント(children)

    export type Data = {
      name: string
      age: number
    }

    export const Table = ({ data }: { data: Data[] }) => {
      return (
        <>
          {data.map((d) => (
            <div>
              <div> {d.name} </div>
              <div> {d.age} </div>
            </div>
          ))}
        </>
      )
    }

    ■ 使用例: index.tsx

    import { Data, TableA } from "./TableA"
    import { Layout } from "./Layout"

    const data: Data[] = [
      { name: "Alice", age: 30 },
      { name: "Bob", age: 25 },
    ]

    export const ReactChildrenWith = Layout.with(() => (
      <TableA data={data} />
    ))

- ENTRY:
  EXPLAIN: HTML要素
  BODY: |
    ■ React.ComponentProps

    type InputProps = React.ComponentProps<'input'>  // HTML要素のProps型取得

    const TextInput = (props: InputProps) => {
      return <input {...props} />
    }

    ■ React.ComponentPropsWithRef

    type InputProps = React.ComponentPropsWithRef<'input'>

    const TextInput = React.forwardRef<HTMLInputElement, InputProps>((props, ref) => (
      <input ref={ref} {...props} />
    ))

    TextInput.displayName = 'TextInput'

    ■ React.forwardRef

    const MyBtn = React.forwardRef<
      HTMLButtonElement,
      React.ComponentPropsWithRef<'button'>
    >(
      (props, ref) => <button ref={ref} {...props} />
    )

    MyBtn.displayName = 'MyBtn'

- ENTRY:
  EXPLAIN: ジェネリック
  BODY: |
    ■ ジェネリックコンポーネント

    type Item<T> = { value: T }

    const ItemView = <T,>({ item }: { item: Item<T> }) => (
      <div>{String(item.value)}</div>
    )

    ■ ポリモーフィック（as プロパティ）コンポーネント & React.ElementType

    ・汎用的なコンポーネントを作成、異なるHTML要素や他のコンポーネントとしてレンダリング可能にする

    type PolymorphicProps<C extends React.ElementType, P> =
      P & { as?: C } & Omit<React.ComponentPropsWithRef<C>, keyof P | 'as'>

    const Box = <C extends React.ElementType = 'div'>(props: PolymorphicProps<C, { variant?: string }>) => {
      const { as: Component = 'div', variant, ...rest } = props as any
      return <Component {...rest} />
    }

    ・使用例

    <Box variant="primary" />                  // divとしてレンダリング
    <Box as="section" variant="secondary" />   // sectionとしてレンダリング
    <Box as={MyBtn} onClick={() => {}} />      // MyBtnコンポーネントとしてレンダリング

- ENTRY:
  EXPLAIN: 識別共用体
  BODY: |
    ■ 識別共用体（Discriminated Union）で安全に切り替える

    type AnchorProps = { as: 'a'; href: string }
    type ButtonProps = { as?: 'button'; onClick?: () => void }
    type LinkOrButton = (AnchorProps | ButtonProps) & { children?: React.ReactNode }

    const LinkOrButtonComp = (props: LinkOrButton) =>
      props.as === 'a'
        ? <a href={props.href}>{props.children}</a>
        : <button onClick={props.onClick}>{props.children}</button>

    <LinkOrButtonComp as="a" href="https://example.com">リンク</LinkOrButtonComp>
    <LinkOrButtonComp onClick={() => alert('Clicked!')}>ボタン</LinkOrButtonComp>

- ENTRY:
  EXPLAIN: 高階コンポーネント(HOC)
  BODY: |
    ■ 高階コンポーネント（Higher-Order Component）の基本概念

    ・コンポーネントを受け取り、新しいコンポーネントを返す関数
    ・ロジックの再利用やクロスカッティング機能の実装に使用
    ・React では Hooks の普及により使用頻度が減少したが、まだ有効

    ■ 基本的な HOC の作成

    // WrappedComponent はラップされるコンポーネント
    function withLogger<T extends {}>(WrappedComponent: React.ComponentType<T>) {
      
      return (props: T) => {            // 新しいコンポーネントを返す
        useEffect(() => {
          console.log('Component mounted');
          return () => console.log('Component unmounted');
        }, []);
        
        return <WrappedComponent {...props} />;  // 元のコンポーネントに props を渡す
      };
    }

    ■ TypeScript での型付け

    ・ジェネリクスを使用して props の型を保持
    ・WrappedComponent の型を React.ComponentType<T> で指定

    interface WithLoadingProps {
      isLoading: boolean;
    }

    function withLoading<T extends {}>(
      WrappedComponent: React.ComponentType<T>
    ) {
      return (props: T & WithLoadingProps) => {
        const { isLoading, ...restProps } = props;

        if (isLoading) {
          return <div>Loading...</div>;
        }

        return <WrappedComponent {...(restProps as T)} />;
      };
    }

    ■ HOC の使用例

    // 基本的な使用
    const EnhancedComponent = withLogger(MyComponent);

    // 複数の HOC を組み合わせる
    const SuperComponent = withLogger(withLoading(MyComponent));

    // または compose を使用
    import { compose } from 'redux';

    const SuperComponent = compose(
      withLogger,
      withLoading
    )(MyComponent);

    ■ 一般的な HOC パターン

    ・withRouter: React Router の history/location/match を注入
    ・withStyles: CSS-in-JS ライブラリのスタイルを注入
    ・connect: Redux の state/dispatch を注入
    ・withTranslation: 国際化ライブラリの翻訳関数を注入

    ■ HOC の注意点

    ・props の命名衝突に注意
    ・ref の転送が必要な場合は React.forwardRef を使用
    ・displayName を設定してデバッグを容易に

    function withLogger<T extends {}>(WrappedComponent: React.ComponentType<T>) {
      const WithLoggerComponent = (props: T) => {
        // ... ロジック
        return <WrappedComponent {...props} />;
      };

      WithLoggerComponent.displayName = `withLogger(${WrappedComponent.displayName || WrappedComponent.name})`;

      return WithLoggerComponent;
    }

- ENTRY:
  EXPLAIN: レンダープロップ
  BODY: |
    ■ レンダープロップ（Render Prop）パターン

    ・コンポーネントが関数を prop として受け取り、その関数内でレンダリングを行う
    ・ロジックの共有と再利用を実現
    ・children を関数として使用する場合も含む

    ■ 基本的な使用例

    interface MouseTrackerProps {
      children: (position: { x: number; y: number }) => React.ReactNode;
    }

    const MouseTracker: React.FC<MouseTrackerProps> = ({ children }) => {
      const [position, setPosition] = useState({ x: 0, y: 0 });

      const handleMouseMove = (event: React.MouseEvent) => {
        setPosition({
          x: event.clientX,
          y: event.clientY
        });
      };

      return (
        <div onMouseMove={handleMouseMove}>
          {children(position)}
        </div>
      );
    };

    // 使用例
    <MouseTracker>
      {({ x, y }) => (
        <div>
          マウス位置: {x}, {y}
        </div>
      )}
    </MouseTracker>

    ■ render prop の命名

    ・children 以外にも render や renderProp などの名前を使用可能

    interface DataFetcherProps<T> {
      url: string;
      render: (data: T | null, loading: boolean, error: Error | null) => React.ReactNode;
    }

    const DataFetcher = <T,>({ url, render }: DataFetcherProps<T>) => {
      const [data, setData] = useState<T | null>(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<Error | null>(null);

      useEffect(() => {
        fetch(url)
          .then(res => res.json())
          .then(setData)
          .catch(setError)
          .finally(() => setLoading(false));
      }, [url]);

      return <>{render(data, loading, error)}</>;
    };

    // 使用例
    <DataFetcher
      url="/api/data"
      render={(data, loading, error) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error.message}</div>;
        return <div>Data: {JSON.stringify(data)}</div>;
      }}
    />

    ■ TypeScript での型付け

    ・render prop の型を明確に定義
    ・ジェネリクスを使用して柔軟性を持たせる

    type RenderProp<T> = (data: T) => React.ReactNode;

    interface GenericRenderPropComponentProps<T> {
      data: T;
      render: RenderProp<T>;
    }

    const GenericRenderPropComponent = <T,>({ data, render }: GenericRenderPropComponentProps<T>) => {
      return <>{render(data)}</>;
    };

    ■ Render Props vs Hooks

    ・Render Props: コンポーネント間でロジックを共有
    ・Hooks: 関数コンポーネント内でロジックを共有
    ・Hooks が推奨される場合が多いが、Render Props も有効

    // Hooks バージョン
    const useMousePosition = () => {
      const [position, setPosition] = useState({ x: 0, y: 0 });

      const handleMouseMove = useCallback((event: React.MouseEvent) => {
        setPosition({
          x: event.clientX,
          y: event.clientY
        });
      }, []);

      return { position, handleMouseMove };
    };

    const MouseTrackerWithHook = ({ children }: { children: React.ReactNode }) => {
      const { position, handleMouseMove } = useMousePosition();

      return (
        <div onMouseMove={handleMouseMove}>
          {children}
          <div>Position: {position.x}, {position.y}</div>
        </div>
      );
    };

    ■ 注意点

    ・render prop が変更されるたびに再レンダリングが発生
    ・パフォーマンス最適化として useCallback を使用
    ・複雑なネストを避けるために Hooks を検討

#-------------------------------
# Reactの型
#-------------------------------
- ENTRY:
  CATEGORY: ノード・要素の型

- ENTRY:
  EXPLAIN: React.ReactNode
  BODY: |
    ■ 用途

    ・Reactコンポーネントの子要素の型を表す
    ・文字列、数値、React要素、配列、null、undefinedなどを含む

    ■ 型定義

    type ReactNode =
      | ReactElement
      | string
      | number
      | boolean
      | null
      | undefined
      | ReactNodeArray
      | ReactPortal

    ■ 使用例

    const MyComponent: React.FC<{ children: React.ReactNode }> = ({ children }) => (
      <div>{children}</div>
    )

- ENTRY:
  EXPLAIN: React.ReactElement
  BODY: |
    ■ 用途

    ・JSXから生成される React 要素の型。コンポーネントの戻り値として使われる。

      ※ React.ReactNodeとの違い
      ・ReactElement は具体的な要素を表す
      ・ReactNode は要素、文字列、数値、null などの集合体

    ■ 概念的な定義

    type ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> = {
      type: T
      props: P
      key: React.Key | null
    }

    ■ 使用例

    const el: React.ReactElement = <div>Hello</div>

#-------------------------------
# Reactの型: ref 周り
#-------------------------------
- ENTRY:
  CATEGORY: ref系の型

- ENTRY:
  EXPLAIN: React.RefObject
  BODY: |
    ■ 用途

    ・`useRef` などで返される不変の参照オブジェクトの型。`.current` に要素や値を保持する。

    ■ 型

    interface RefObject<T> {
      readonly current: T | null
    }

    ■ 使用例

    const ref = useRef<HTMLInputElement | null>(null)
    ref.current?.focus()
    React.RefObject<T>

- ENTRY:
  EXPLAIN: React.MutableRefObject
  BODY: |
    ■ 用途

    ・`.current` を自由に更新できる可変参照オブジェクトの型。`useRef(initial)` の戻り値の典型型。

    ■ 型

    interface MutableRefObject<T> {
      current: T
    }

    ■ 使用例

    const countRef = useRef<number>(0)
    countRef.current += 1
    React.MutableRefObject<T>

- ENTRY:
  EXPLAIN: React.Ref
  BODY: |
    ■ 用途

    ・コンポーネントや要素の参照を表す汎用型。コールバック ref や RefObject を受け取れるユニオン型。

    ■ 型の例

    type Ref<T> = RefCallback<T> | RefObject<T> | null

    ■ 使用例

    const forwardRefComp = React.forwardRef<HTMLButtonElement, Props>((props, ref) => (
      <button ref={ref} />
    ))
    React.Ref<T>

- ENTRY:
  EXPLAIN: React.RefAttributes
  BODY: |
    ■ 用途

    ・ジェネリックコンポーネントに `ref` を型付けして渡すための補助型。`forwardRef` と組み合わせて使う。

    ■ 使用例

    type Props = { value: string } & React.RefAttributes<HTMLDivElement>
    React.RefAttributes

- ENTRY:
  EXPLAIN: React.PropsWithRef/PropsWithoutRef
  BODY: |
    ■ 用途

    ・`PropsWithRef` は ref を含めた Props のユーティリティ、`PropsWithoutRef` は ref を除外した Props 型を作る。

    ■ 使用例

    type InputProps = React.ComponentPropsWithRef<'input'>
    type CleanProps = React.PropsWithoutRef<InputProps>

#-------------------------------
# Reactの型: HTML/DOM/SVG属性型
#-------------------------------
- ENTRY:
  CATEGORY: HTML/DOM/SVG属性型

- ENTRY:
  EXPLAIN: HTMLAttributes
  BODY: |
    ■ 用途

    ・ほとんどの HTML 要素に共通するプロパティ（`className` / `style` / `onClick` 等）をまとめた型。

    ■ 使用例

    type DivProps = React.HTMLAttributes<HTMLDivElement>
    const Comp = (props: DivProps) => <div {...props} />

- ENTRY:
  EXPLAIN: DOMAttributes
  BODY: |
    ■ 用途

    ・DOM イベントハンドラ（`onClick` / `onChange` / `onMouseEnter` 等）の型定義を含む基底型。

    ■ 使用例

    type Clickable = { onClick?: React.MouseEventHandler }
    const Btn = ({ onClick }: Clickable) => <button onClick={onClick} />

- ENTRY:
  EXPLAIN: InputHTMLAttributes
  BODY: |
    ■ 用途

    ・`<input>` 要素固有の属性型（`type` / `value` / `onChange` / `placeholder` 等）を定義する。

    ■ 使用例

    const TextInput = (props: React.InputHTMLAttributes<HTMLInputElement>) => (
      <input {...props} />
    )

- ENTRY:
  EXPLAIN: ButtonHTMLAttributes
  BODY: |
    ■ 用途

    ・`<button>` 要素固有の属性型（`type` / `disabled` / `onClick` 等）。

    ■ 使用例

    const MyButton = (props: React.ButtonHTMLAttributes<HTMLButtonElement>) => (
      <button {...props} />
    )

- ENTRY:
  EXPLAIN: AnchorHTMLAttributes
  BODY: |
    ■ 用途

    ・`<a>` 要素固有の属性型（`href` / `target` / `rel` 等）。

    ■ 使用例

    const Link = (props: React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
      <a {...props} />
    )

- ENTRY:
  EXPLAIN: SVGProps
  BODY: |
    ■ 用途

    ・SVG 要素に渡せる属性の型。`width`/`height`/`fill`/`stroke` 等を含む。

    ■ 使用例

    const Icon = (props: React.SVGProps<SVGSVGElement>) => (
      <svg {...props} viewBox="0 0 24 24">...</svg>
    )

#-------------------------------
# Reactの型: その他のユーティリティ型
#-------------------------------

- ENTRY:
  CATEGORY: その他のユーティリティ型

- ENTRY:
  EXPLAIN: React.ComponentProps
  BODY: |
    ■ 用途

    ・HTML 要素の Props 型を取得

    ■ 使用例

    type InputProps = React.ComponentProps<'input'>  // HTMLInputElement の Props 型

    const TextInput = (props: InputProps) => {
      return <input {...props} />
    }

- ENTRY:
  EXPLAIN: React.ComponentPropsWithRef
  BODY: |
    ■ 用途

    ・ref を含む Props 型を取得

    ■ 使用例

    type ButtonProps = React.ComponentPropsWithRef<'button'>

    const MyButton = React.forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => (
      <button ref={ref} {...props} />
    ))

- ENTRY:
  EXPLAIN: React.ComponentPropsWithoutRef
  BODY: |
    ■ 用途

    ・ref を除外した Props 型を取得

    ■ 使用例

    type CleanButtonProps = React.ComponentPropsWithoutRef<'button'>

- ENTRY:
  EXPLAIN: React.CSSProperties
  BODY: |
    ■ 用途

    ・スタイルオブジェクトの型

    ■ 使用例

    const style: React.CSSProperties = {
      color: 'red',
      fontSize: '14px'
    }

- ENTRY:
  EXPLAIN: React.ReactFragment
  BODY: |
    ■ 用途

    ・`<></>` や `<React.Fragment>` の型

    ■ 使用例

    const fragment: React.ReactFragment = <><div>1</div><div>2</div></>

- ENTRY:
  EXPLAIN: React.ReactPortal
  BODY: |
    ■ 用途

    ・`ReactDOM.createPortal` の戻り値型

    ■ 使用例

    import { createPortal } from 'react-dom'

    const portal: React.ReactPortal = createPortal(<div>Portal</div>, document.body)

- ENTRY:
  EXPLAIN: React.Key
  BODY: |
    ■ 用途

    ・リストアイテムの key の型

    ■ 使用例

    const items: Array<{ key: React.Key; value: string }> = [
      { key: '1', value: 'item1' }
    ]

- ENTRY:
  EXPLAIN: React.RefCallback
  BODY: |
    ■ 用途

    ・コールバック ref の型

    ■ 使用例

    const refCallback: React.RefCallback<HTMLDivElement> = (element) => {
      if (element) {
        console.log(element.offsetHeight)
      }
    }

#-------------------------------
# 他機能
#-------------------------------
- ENTRY:
  CATEGORY: 他機能

- ENTRY:
  EXPLAIN: Error Boundaries
  BODY: |
    ■ 用途

    ・コンポーネントツリーの JavaScript エラーをキャッチし、フォールバック UI を表示

    ■ 実装例

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props)
        this.state = { hasError: false }
      }

      static getDerivedStateFromError(error) {
        return { hasError: true }
      }

      componentDidCatch(error, errorInfo) {
        console.log(error, errorInfo)
      }

      render() {
        if (this.state.hasError) {
          return <h1>Something went wrong.</h1>
        }

        return this.props.children
      }
    }

- ENTRY:
  EXPLAIN: Portals
  BODY: |
    ■ 用途

    ・DOM ツリーの外側に子要素をレンダリング

    ■ 使用例

    import { createPortal } from 'react-dom'

    const Modal = ({ children }) => {
      return createPortal(
        children,
        document.getElementById('modal-root')
      )
    }

- ENTRY:
  EXPLAIN: React.lazy
  BODY: |
    ■ 用途

    ・コンポーネントの遅延読み込み

    ■ 使用例

    const LazyComponent = React.lazy(() => import('./LazyComponent'))

    const App = () => (
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    )

- ENTRY:
  EXPLAIN: React.memo
  BODY: |
    ■ 用途

    ・コンポーネントのメモ化

    ■ 使用例

    const MyComponent = React.memo(({ value }) => {
      return <div>{value}</div>
    })

- ENTRY:
  EXPLAIN: React.forwardRef
  BODY: |
    ■ 用途

    ・ref を子コンポーネントに転送

    ■ 使用例

    const FancyButton = React.forwardRef((props, ref) => (
      <button ref={ref} className="FancyButton">
        {props.children}
      </button>
    ))

- ENTRY:
  EXPLAIN: React.StrictMode
  BODY: |
    ■ 用途

    ・開発時に潜在的な問題を検出

    ■ 使用例

    <React.StrictMode>
      <App />
    </React.StrictMode>

- ENTRY:
  EXPLAIN: React.Suspense
  BODY: |
    ■ 用途

    ・遅延コンポーネントのローディング状態を処理

    ■ 使用例

    <React.Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </React.Suspense>

#-------------------------------
# Hooks
#-------------------------------
- ENTRY:
  CATEGORY: Main Hooks

- ENTRY:
  EXPLAIN: Hooks 一覧
  BODY: |
    ・useState                    状態管理 (React 16.8)
    ・useEffect                   副作用処理 (React 16.8)
    ・useCallback                 関数のメモ化 (React 16.8)
    ・useMemo                     値のメモ化 (React 16.8)
    ・useRef                      参照の保持 (React 16.8)
    ・useImperativeHandle         親コンポーネントからの操作 (React 16.8)
    ・useLayoutEffect             レイアウト効果 (React 16.8)
    ・useContext                  コンテキスト管理 (React 16.8)
    ・useReducer                  状態管理（Redux風） (React 16.8)
    ・useTransition               遷移状態管理 (React 18)
    ・useDeferredValue            遅延値管理 (React 18)
    ・useId                       一意ID生成 (React 18)
    ・useSyncExternalStore        外部ストア同期 (React 18)
    ・useInsertionEffect          CSS-in-JS ライブラリ向けスタイル注入 (React 18)
    ・useActionState              アクション状態管理 (React 19)
    ・useFormStatus               フォームステータス取得 (React 19)
    ・useOptimistic               楽観的更新 (React 19)
    ・useEvent                    イベントハンドラメモ化 (React 19)

- ENTRY:
  EXPLAIN: useState
  BODY: |
    ■ 目的

    ・関数コンポーネントで状態を管理

    ■ 基本

    const [state, setState] = useState(initialState)

    ■ 型指定

    const [xxx, setXxx] = useState<string>("")
    const [xxx, setXxx] = useState<number>(0)
    const [xxx, setXxx] = useState<boolean>(false)
    const [xxx, setXxx] = useState<Map<string, any>>()
    const [xxx, setXxx] = useState<Set<string>>()

    ■ 関数で初期値設定

    const [count, setCount] = useState<number>(() => {
      const initialCount = computeInitialCount()
      return initialCount
    })

    ■ オブジェクト・配列の更新

    setState(prevState => ({
      ...prevState,
      key: newValue
    }))

    setState(prevState => [
      ...prevState,
      newItem
    ])

    ■ 注意点

    ・状態の直接変更は避ける（イミュータブルに更新）

- ENTRY:
  EXPLAIN: useEffect
  BODY: |
    ■ 目的

    ・副作用の処理（データ取得、イベントリスナー登録、DOM操作など）

    ■ 基本

    useEffect(() => {
      // 処理

      return () => {
        // クリーンアップ処理（オプション）
      }
    }, [依存変数])  // 依存配列

    ■ 依存配列の有無

    useEffect(() => { ... })            // 毎レンダリング時に実行
    useEffect(() => { ... }, [])        // マウント時に一度だけ実行
    useEffect(() => { ... }, [var1])    // var1 が変化した時に実行

    ■ クリーンアップ処理サンプル: Timeoutコールバック

    useEffect(() => {
      let timeoutId: NodeJS.Timeout | null = null

      timeoutId = setTimeout(() => {
        // 処理
      }, 1000)

      return () => {
        if (timeoutId) clearTimeout(timeoutId)
      }
    }, [])

    ■ 非同期 (async/await)

    useEffect(() => {
      const asyncMethod = async () => {
        try {
          const xxx = await getXxx(xxxId)
          setXxx(xxx)
        } catch (err) { ... }
      }

      asyncMethod()
    }, [])

    ■ 即時関数 (async/await)

    useEffect(() => {
      (async () => {
        try {
          const xxx = await getXxx(xxxId)
          setXxx(xxx)
        } catch (err) { ... }
      })()
    }, [])

    ■ AbortController (v18)

    useEffect(() => {
      const controller = new AbortController()
      const signal = controller.signal

      fetch(URL, { signal })
        .then((res) => res.json())
        .then((json) => setXxx(json))
        .catch((err) => {
          if (err.name === 'AbortError') {
            console.log('Fetch aborted')
          } else {
            // その他のエラー処理
          }
        })

      return () => {
        controller.abort()  // フェッチを中止
      }
    }, [])

- ENTRY:
  EXPLAIN: useLayoutEffect
  BODY: |
    ■ 目的

    ・DOMの変更を同期的に行う
    ・レンダリング前に副作用を実行
    ・レイアウトの計算やスタイルの適用に使用
    ・視覚的な不整合を防ぐ

    ■ 基本

    useLayoutEffect(() => {
      // 処理
    }, [])  // 依存配列

    ■ useEffect との違い

    ・useEffect は非同期に実行され、レンダリング後に副作用を処理
    ・useLayoutEffect は同期的に実行され、レンダリング【前】に副作用を処理
    ・DOMの読み取りや書き込みが必要な場合は useLayoutEffect を使用

    ■ サンプル

    import React, { useLayoutEffect, useRef, useState } from 'react'  
    export const LayoutEffectExample = () => {
      const divRef = useRef<HTMLDivElement | null>(null)
      const [width, setWidth] = useState(0)

      useLayoutEffect(() => {
        if (divRef.current) {
          const rect = divRef.current.getBoundingClientRect()
          setWidth(rect.width)
        }
      }, [])

      return (
        <div>
          <div ref={divRef} style={{ width: '50%' }}>
            幅を測定する要素
          </div>
          <p>要素の幅: {width}px</p>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: useCallback
  BODY: |
    ■ 用途

    ・関数をメモ化し、再生成を防ぐ
    ・子コンポーネントへの不必要な再レンダリング防止
    ・パフォーマンス最適化
    ・依存変数が変化した時のみ関数を再生成
    ・イベントハンドラやコールバック関数の安定化
    ・子コンポーネントに渡す関数が毎回新しい参照になるのを防ぐ

    ■ 基本

    const memoizedCallback = useCallback(() => {
      // 処理
    }, [依存変数])  // 依存配列がない場合は初回のみ生成

    ■ 引数・戻り値あり

    const memoizedCallbackWithArg = useCallback((param: string) => {
      return param * 2
    }, [依存変数])

    ■ サンプル

    const handleChangeText = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.currentTarget.value
        setText(value)
      },
      []
    )

    <input
      type="text"
      onChange={handleChangeText}
      value={text}
      placeholder="name"
    />

- ENTRY:
  EXPLAIN: useMemo
  BODY: |
    ■ 基本

    const memoizedValue = useMemo(() => {
      // 計算コストの高い処理
      return computeExpensiveValue(a, b)
    }, [a, b])  // 依存変数が変化した時に再計算

    ■ オブジェクト/配列のメモ化

    const memoizedObject = useMemo(() => ({
      key1: value1,
      key2: value2,
    }), [value1, value2])

    ■ 関数のメモ化

    const memoizedCallback = useMemo(() => {
      return () => {
        doSomething(a, b)
      }
    }, [a, b])

    ■ コンポーネントのメモ化

    const MemoizedComponent = useMemo(() => {
      return <MyComponent prop1={value1} prop2={value2} />
    }, [value1, value2])

    ■ 副作用がある場合は useEffect を使う

    useEffect(() => {
      // 副作用のある処理
      performSideEffect(data)
    }, [data])

    ■ 副作用: データの取得

    useEffect(() => {
      fetchData().then(data => setData(data))
    }, [])

    ■ 副作用: 直接的なDOM操作

    useEffect(() => {
      const element = document.getElementById('my-element')
      if (element) {  
        element.style.backgroundColor = 'yellow'
      }     
    }, [])

    ■ 副作用: WebSocketやイベントリスナーの設定

    useEffect(() => {
      const handleResize = () => { ... }
      window.addEventListener('resize', handleResize)
      return () => {
        window.removeEventListener('resize', handleResize)
      }
    }, [])

- ENTRY:
  EXPLAIN: useRef
  BODY: |
    ■ 目的

    ・DOM要素や任意の値への参照を保持
    ・再レンダリングを引き起こさない可変の値を保持

    ■ 基本

    const ref = useRef<型>(初期値)

    ・null あり
    const ref = useRef<HTMLInputElement | null>(null)

    ・null なし
    const ref = useRef<HTMLInputElement>(null!)  // 非 null アサーション
    ※ 非 null アサーションは、初期レンダリング時に要素が存在しない場合にエラーになる可能性があるため注意

    ■ サンプル: Inputフォーカス

    export const FocusInput = () => {
      const inputRef = useRef<HTMLInputElement | null>(null)

      const handleFocus = () => {
        inputRef.current?.focus()
      }

      return (
        <>
          <input ref={inputRef} defaultValue="hello" />
          <button onClick={handleFocus}>Focus</button>
        </>
      )
    }

    ■ サンプル: submit 時に値を読む（フォーム操作）

    export const ReadValueForm = () => {
      const inputRef = useRef<HTMLInputElement | null>(null)

      const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault()
        const val = inputRef.current?.value ?? ""
        // console.log("value:", val)
      }

      return (
        <form onSubmit={handleSubmit}>
          <input ref={inputRef} />
          <button type="submit">Submit</button>
        </form>
      )
    }

- ENTRY:
  EXPLAIN: useRef サンプル(配列, コールバックref, カスタムHook)
  BODY: |
    ■ createRef を配列で保持（要素数が固定または初期化時に決まる場合）

    export const FixedRefs = () => {
      const count = 3
      const refs = useRef<Array<React.RefObject<HTMLInputElement>>>(() =>
        Array.from({ length: count }, () => createRef<HTMLInputElement>())
      )()
      const focusSecond = () => refs[0]?.current && refs[1].current?.focus()

      return (
        <>
          {refs.map((r, i) => <input key={i} ref={r} defaultValue={`#${i}`} />)}
          <button onClick={focusSecond}>Focus #1</button>
        </>
      )
    }

    ■ コールバック ref を使う（可変長リストで型がシンプル）

    export const CallbackRefs = ({ items }: { items: string[] }) => {
      const refs = useRef<Array<HTMLInputElement | null>>([])

      return (
        <>
          {items.map((it, i) => (
            <input
              key={i}
              defaultValue={it}
              ref={(el) => (refs.current[i] = el)}
            />
          ))}
          <button onClick={() => refs.current[0]?.focus()}>Focus first</button>
        </>
      )
    }

    ■ useCallback で安全にセット（レンダリングごとの再生成を抑制）

    export const StableSetterRefs = ({ items }: { items: string[] }) => {
      const refs = useRef<(HTMLInputElement | null)[]>([])
      const setRef = useCallback((el: HTMLInputElement | null, idx: number) => {
        refs.current[idx] = el
      }, [])

      return (
        <>
          {items.map((it, i) => (
            <input key={i} defaultValue={it} ref={(el) => setRef(el, i)} />
          ))}
          <button onClick={() => refs.current[items.length - 1]?.focus()}>Focus last</button>
        </>
      )
    }

    ■ カスタムHook: 型付きユーティリティ関数

    type InputRef = HTMLInputElement | null

    export const useInputRefs = (count: number) => {
      const refs = useRef<InputRef[]>([])
      const getRef = (i: number) => (el: HTMLInputElement | null) => (refs.current[i] = el)
      return { refs, getRef }
    }

    ・使い方
    const { refs, getRef } = useInputRefs(items.length)
    <input ref={getRef(i)} />

- ENTRY:
  EXPLAIN: useRef サンプル(ファイルアップロード)
  BODY: |
    import { Box, Button, Flex } from "@chakra-ui/react";
    import { ChangeEvent, Dispatch, SetStateAction, useRef, useState } from "react";

    type Props = {
      setSavedData: Dispatch<SetStateAction<string | undefined>>;
      type?: string;
    };

    export const FileUploadButton = ({
      setSavedData,
      type = ".txt",
    }: Props) => {
    }) => {
      const refInput = useRef<HTMLInputElement>(null);
      const handleButton = () => {
        refInput.current?.click();
      };
      const [msg, setMsg] = useState("");

      const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
        if (!e.target.files || e.target.files.length === 0) {
          console.error("保存データファイル選択");
          return;
        }

        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
          const content = event.target?.result;
          try {
            setSavedData(content as string);
            setMsg("ロードされました");
          } catch (error) {
            console.error(error);
            setMsg("ロード失敗しました");
          }
        };
        reader.readAsText(file);
      };

      return (
        <Flex alignItems={"center"}>
          <Button onClick={handleButton}>保存データファイル使用</Button>
          <input
            ref={refInput}
            hidden={true}
            type="file"
            accept={type}
            onChange={handleFileChange}
          />
          <Box ml={5}>{msg}</Box>
        </Flex>
      );
    };

- ENTRY:
  EXPLAIN: forwardRef
  BODY: |
    ■ 用途

      親コンポーネントから子コンポーネントのDOM要素にアクセス

    ■ 基本

    const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (
      <button ref={ref} className="FancyButton">
        {props.children}
      </button>
    ))  

    ■ サンプル (入力要素にフォーカス)

    type Props = {
      text: string
      setText: React.Dispatch<React.SetStateAction<string>>
      title: string
    } & React.ComponentPropsWithRef<"input">

    export const InputRef = forwardRef<HTMLInputElement, Props>(
      ({ text, setText, title, ...args }, ref) => {
        const id = useId()

        const handleChangeText = (e: React.ChangeEvent<HTMLInputElement>) => {
          const value = e.currentTarget.value
          setText(value)
        }

        return (
          <div>
            <label htmlFor={id}>{title}</label>
            <input {...args} id={id} ref={ref} onChange={handleChangeText} />
          </div>
        )
      }
    )

    // 使用例
    const ParentComponent = () => {
      const [text, setText] = useState("")
      const inputRef = useRef<HTMLInputElement | null>(null)

      const handleFocus = () => {
        inputRef.current?.focus()
      }

      return (
        <>
          <InputRef
            ref={inputRef}
            text={text}
            setText={setText}
            title="名前"
            placeholder="name"
          />
          <button onClick={handleFocus}>Focus Input</button>
        </>
      )
    }

- ENTRY:
  EXPLAIN: useReducer
  BODY: |
    ■ 用途

    ・複雑な状態管理や複数の状態変化ロジックをまとめる

    ■ 基本

    const [state, dispatch] = useReducer(reducer, initialState)

    const reducer = (state, action) => {
      switch (action.type) {
        case 'ACTION_TYPE':
          return { ...state, key: action.payload }
        default:
          return state
      }
    } 

    ■ サンプル (flip関数)

    const [isTrue, flipFlag] = useReducer((flag: boolean) => !flag, false)

    ■ サンプル (カウンター)

    const initialState = { count: 0 }
    const reducer = (state: typeof initialState, action: { type: string; payload?: number }) => {
      switch (action.type) {
        case 'increment':
          return { count: state.count + 1 }
        case 'decrement':
          return { count: state.count - 1 }
        case 'set':
          return { count: action.payload ?? state.count }
        default:
          return state
      }
    }

    const Counter = () => {
      const [state, dispatch] = useReducer(reducer, initialState)

      return (
        <div>
          <p>Count: {state.count}</p>
          <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
          <button onClick={() => dispatch({ type: 'increment' })}>+</button>
          <button onClick={() => dispatch({ type: 'set', payload: 10 })}>Set to 10</button>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: useContext
  BODY: |
    ■ 目的

    ・コンポーネントツリー全体でデータを共有
    ・props drilling（深い階層へのprops伝搬）を回避
    ・グローバルな状態管理に利用可能

    ■ 基本

    // コンテキストの型定義
    const MyContext = createContext<ContextType>(defaultValue)

    // コンテキストの利用
    const contextValue = useContext(MyContext)

    ■ サンプル(基本)

    const ThemeContext = createContext<string>('light')

    // コンテキストプロバイダー
    const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
      const [theme, setTheme] = useState<string>('light')

      return (
        <ThemeContext.Provider value={theme}>
          {children}
        </ThemeContext.Provider>
      )
    }

    // コンテキストの消費
    const ThemedComponent: React.FC = () => {
      const theme = useContext(ThemeContext)

      return <div>Current theme: {theme}</div>
    }

- ENTRY:
  EXPLAIN: useContext サンプル(実装ファイルPATH)
  BODY: |
    ■ 実装ファイルの構造とPATH

    ・型定義ファイル: src/types/contextTypes.ts

      - コンテキストで使用する型を定義
      - 例: interface User { id: number; name: string }

    ・コンテキスト定義ファイル: src/contexts/UserContext.tsx

      - createContext でコンテキストを作成
      - Provider コンポーネントを実装
      - useContext のカスタムHookを提供

    ・ルートAPP設定: src/App.tsx

      - プロバイダーをルートに配置
      - 複数のコンテキストをネスト可能

    ・利用側コンポーネント: src/components/UserProfile.tsx

      - useContext またはカスタムHookで値を取得

    ■ 型定義の実装 (src/types/contextTypes.ts)

    export interface User {
      id: number
      name: string
      email: string
    }

    export interface AuthContextType {
      user: User | null
      login: (user: User) => void
      logout: () => void
    }

    ■ プロバイダーの実装 (src/contexts/AuthContext.tsx)

    import React, { createContext, useContext, useState, ReactNode } from 'react'
    import { AuthContextType, User } from '../types/contextTypes'

    const AuthContext = createContext<AuthContextType | undefined>(undefined)

    export const useAuth = () => {
      const context = useContext(AuthContext)
      if (!context) {
        throw new Error('useAuth must be used within an AuthProvider')
      }
      return context
    }

    interface AuthProviderProps {
      children: ReactNode
    }

    export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
      const [user, setUser] = useState<User | null>(null)

      const login = (userData: User) => {
        setUser(userData)
      }

      const logout = () => {
        setUser(null)
      }

      const value: AuthContextType = {
        user,
        login,
        logout,
      }

      return (
        <AuthContext.Provider value={value}>
          {children}
        </AuthContext.Provider>
      )
    }

    ■ ルートAPPでの設定 (src/App.tsx)

    import React from 'react'
    import { AuthProvider } from './contexts/AuthContext'
    import { ThemeProvider } from './contexts/ThemeContext'
    import AppContent from './components/AppContent'

    const App: React.FC = () => {
      return (
        <AuthProvider>
          <ThemeProvider>
            <AppContent />
          </ThemeProvider>
        </AuthProvider>
      )
    }

    export default App

    ■ 利用側の実装 (src/components/UserProfile.tsx)

    import React from 'react'
    import { useAuth } from '../contexts/AuthContext'

    const UserProfile: React.FC = () => {
      const { user, logout } = useAuth()

      if (!user) {
        return <div>Please log in</div>
      }

      return (
        <div>
          <h1>Welcome, {user.name}!</h1>
          <p>Email: {user.email}</p>
          <button onClick={logout}>Logout</button>
        </div>
      )
    }

    export default UserProfile

    ■ ネストされたコンテキストの設定例 (src/App.tsx の変種)

    // 複数のプロバイダーを組み合わせる場合
    const App: React.FC = () => {
      return (
        <ErrorBoundary>
          <AuthProvider>
            <ThemeProvider>
              <Router>
                <AppContent />
              </Router>
            </ThemeProvider>
          </AuthProvider>
        </ErrorBoundary>
      )
    }

    ■ コンポーネント外での利用 (カスタムHook経由)

    // src/hooks/useAuth.ts (別ファイルでも可)
    import { useAuth } from '../contexts/AuthContext'

    export const useCurrentUser = () => {
      const { user } = useAuth()
      return user
    }

    // 利用側
    const MyComponent = () => {
      const user = useCurrentUser()
      // ...
    }

- ENTRY:
  EXPLAIN: useId
  BODY: |
    ■ 用途

    ・コンポーネントごとに一意のIDを生成
    ・フォーム要素のラベルやARIA属性に使用
    ・サーバーサイドレンダリング(SSR)とクライアントサイドレンダリング(CSR)で一貫性のあるIDを提供
    ・React 18以降で利用可能

    ■ 基本

    const id = useId();

    ■ サンプル

    export const UseIdExample = () => {
      const inputId = useId();

      return (
        <div>
          <label htmlFor={inputId}>Name:</label>
          <input id={inputId} type="text" />
        </div>
      );
    };

- ENTRY:
  EXPLAIN: useImperativeHandle
  BODY: |
    ■ 目的

    ・親コンポーネントから子コンポーネントのインスタンスメソッドにアクセス
    ・React.forwardRef と組み合わせて使用
    ・React のバージョンは16.8以降が必要
    ・一般的には避け、代わりに props や state を使用することが推奨される

    ■ ユースケース

    ・子コンポーネントの特定のメソッドを親に公開したい場合
    ・フォーカス制御やアニメーションのトリガーなど、DOM操作が必要な場合

    ■ 注意点

    ・ref を通じて公開するメソッドのみを定義
    ・依存配列を適切に設定して再作成を防ぐ
    ・過度な使用はコンポーネントの結合度を高める

    ■ 基本

    useImperativeHandle(ref, () => ({
      methodName: () => {
        // 公開するメソッドの実装
      }
    }), [dependencies])

    ■ サンプル

    import React, { useImperativeHandle, useRef, forwardRef } from "react"

    export type ImperativeHandleRef = {
      focusInput: () => void
      getValue: () => string
    }

    export const ImperativeHandle = forwardRef<ImperativeHandleRef>((props, ref) => {
      const inputRef = useRef<HTMLInputElement>(null)

      useImperativeHandle(ref, () => ({
        focusInput: () => {
          inputRef.current?.focus()
        },
        getValue: () => {
          return inputRef.current?.value || ''
        }
      }), [])

      return <input ref={inputRef} />
    })

    // 使用例
    const ParentComponent = () => {
      const ref = useRef<ImperativeHandleRef>(null)

      const handleFocus = () => {
        ref.current?.focusInput()
      }

      const handleGetValue = () => {
        const value = ref.current?.getValue()
        console.log(value)
      }

      return (
        <div>
          <ImperativeHandle ref={ref} />
          <button onClick={handleFocus}>Focus</button>
          <button onClick={handleGetValue}>Get Value</button>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: useSuspense
  BODY: |
    ■ 用途

    ・非同期データの取得やコンポーネントの遅延読み込み時にローディングUIを表示
    ・React 18以降で利用可能
    ・Suspenseコンポーネント内で使用

    ■ 基本

    import React, { Suspense } from "react"

    const LazyComponent = React.lazy(() => import("./LazyComponent"))

    export const UseSuspense = () => {
      return (
        <Suspense fallback={<div>Loading...</div>}>
          <LazyComponent />
        </Suspense>
      )
    }

    ■ コンポーネントの遅延読み込み

    import React from "react"

    export const LazyComponent = () => {
      return <div>This is a lazy loaded component.</div>
    }

    ■ 非同期データの取得

    import React, { useEffect, useState } from "react"

    export const LazyComponent = () => {
      const [data, setData] = useState<string | null>(null)

      useEffect(() => {
        // 擬似的な非同期データ取得
        const timer = setTimeout(() => {
          setData("Fetched Data")
        }, 2000)

        return () => clearTimeout(timer)
      }, [])

      if (!data) {
        return <div>Loading data...</div>
      }

      return <div>Data: {data}</div>
    }

- ENTRY:
  EXPLAIN: useTransition
  BODY: |
    ■ 用途

    ・UI の遷移状態を管理し、緊急性の低い更新を遅らせる
    ・React 18 以降で利用可能

    ■ 基本

    import { useTransition } from 'react';

    const [isPending, startTransition] = useTransition();

    startTransition(() => {
      // 緊急性の低い更新
      setState(newValue);
    });

    ■ サンプル

    const SearchComponent = () => {
      const [query, setQuery] = useState('');
      const [results, setResults] = useState([]);
      const [isPending, startTransition] = useTransition();

      const handleChange = (e) => {
        const value = e.target.value;
        setQuery(value);

        startTransition(() => {
          // 検索結果の更新を遅らせる
          const filtered = expensiveSearch(value);
          setResults(filtered);
        });
      };

      return (
        <div>
          <input value={query} onChange={handleChange} />
          {isPending && <div>Loading...</div>}
          <ul>
            {results.map(item => <li key={item.id}>{item.name}</li>)}
          </ul>
        </div>
      );
    };

- ENTRY:
  EXPLAIN: useDeferredValue
  BODY: |
    ■ 用途

    ・値の更新を遅らせ、緊急性の低い部分のレンダリングを遅らせる
    ・React 18 以降で利用可能

    ■ 基本

    import { useDeferredValue } from 'react';

    const deferredValue = useDeferredValue(value);

    ■ サンプル

    const SearchResults = ({ query }) => {
      const deferredQuery = useDeferredValue(query);

      // 遅延されたクエリで検索を実行
      const results = useMemo(() => {
        return expensiveSearch(deferredQuery);
      }, [deferredQuery]);

      return (
        <ul>
          {results.map(item => <li key={item.id}>{item.name}</li>)}
        </ul>
      );
    };

    const SearchComponent = () => {
      const [query, setQuery] = useState('');

      return (
        <div>
          <input value={query} onChange={e => setQuery(e.target.value)} />
          <SearchResults query={query} />
        </div>
      );
    };

- ENTRY:
  EXPLAIN: useSyncExternalStore
  BODY: |
    ■ 用途

    ・外部ストア（Redux, Zustand など）と同期
    ・React 18 以降で利用可能

    ■ 基本実装

    import { useSyncExternalStore } from 'react';

    const state = useSyncExternalStore(
      subscribe,                        // ストアの変更を購読する関数
      getSnapshot,                      // 現在の状態を取得する関数
      getServerSnapshot?                // サーバーサイドレンダリング用の関数（オプション）
    );

      ・subscribe

        const subscribe = (callback) => {
          const unsubscribe = store.subscribe(callback);
          return unsubscribe;
        };

      ・getSnapshot

        const getSnapshot = () => {
          return store.getState();
        };

      ・getServerSnapshot (オプション)

        const getServerSnapshot = () => {
          return store.getState();
        };

    ■ サンプル実装(Redux ストアとの同期)

    const useStore = (selector) => {
      return useSyncExternalStore(
        store.subscribe,
        () => selector(store.getState())
      );
    };

    const Counter = () => {
      const count = useStore(state => state.count);

      return (
        <div>
          <div>Count: {count}</div>
          <button onClick={() => store.dispatch({ type: 'increment' })}>
            Increment
          </button>
        </div>
      );
    };

- ENTRY:
  EXPLAIN: useInsertionEffect
  BODY: |
    ■ 用途

    ・CSS-in-JS ライブラリ向けの Hook
    ・DOM 挿入前にスタイルを注入
    ・useLayoutEffect より前に実行
    ・React 18 以降で利用可能

    ■ 実装

    import { useInsertionEffect } from 'react';

    useInsertionEffect(() => {
      // DOM 挿入前に実行される
      // スタイルの注入などに使用
    }, [dependencies]);

    ■ サンプル

    const useCSS = (css: string) => {
      useInsertionEffect(() => {
        const style = document.createElement('style');
        style.textContent = css;
        document.head.appendChild(style);
        return () => {
          document.head.removeChild(style);
        };
      }, [css]);
    };

- ENTRY:
  EXPLAIN: useActionState
  BODY: |
    ■ 目的

    ・Server Actions の状態管理
    ・フォーム送信時の pending 状態やエラーハンドリング
    ・React 19 で導入

    ■ 基本

    const [state, action, isPending] = useActionState(async (previousState, formData) => {
      // Server Action の処理
      return newState
    }, initialState)

    ■ サンプル

    import { useActionState } from 'react'

    async function updateName(previousState, formData) {
      const name = formData.get('name')
      try {
        const updatedName = await updateNameOnServer(name)
        return { name: updatedName, error: null }
      } catch (error) {
        return { ...previousState, error: error.message }
      }
    }

    function NameForm() {
      const [state, action, isPending] = useActionState(updateName, { name: '', error: null })

      return (
        <form action={action}>
          <input name="name" defaultValue={state.name} />
          <button type="submit" disabled={isPending}>
            {isPending ? 'Updating...' : 'Update'}
          </button>
          {state.error && <p>Error: {state.error}</p>}
        </form>
      )
    }

- ENTRY:
  EXPLAIN: useFormStatus
  BODY: |
    ■ 目的

    ・フォームの現在のステータスを取得
    ・pending 状態やデータ取得
    ・React 19 で導入

    ■ 基本

    const { pending, data, method, action } = useFormStatus()

    ■ サンプル

    import { useFormStatus } from 'react'

    function SubmitButton() {
      const { pending } = useFormStatus()

      return (
        <button type="submit" disabled={pending}>
          {pending ? 'Submitting...' : 'Submit'}
        </button>
      )
    }

    function Form() {
      return (
        <form action={someAction}>
          <input name="name" />
          <SubmitButton />
        </form>
      )
    }

- ENTRY:
  EXPLAIN: useOptimistic
  BODY: |
    ■ 目的

    ・楽観的更新の実装
    ・UI を即座に更新し、バックエンドの応答を待つ
    ・React 19 で導入

    ■ 基本

    const [optimisticState, addOptimistic] = useOptimistic(initialState, (currentState, optimisticValue) => {
      // 楽観的更新のロジック
      return updatedState
    })

    ■ サンプル

    import { useOptimistic } from 'react'

    function TodoList({ todos, addTodo }) {
      const [optimisticTodos, addOptimisticTodo] = useOptimistic(
        todos,
        (currentTodos, newTodo) => [...currentTodos, { id: 'temp', text: newTodo, pending: true }]
      )

      const handleAddTodo = async (text) => {
        addOptimisticTodo(text)
        await addTodo(text)
      }

      return (
        <div>
          {optimisticTodos.map(todo => (
            <div key={todo.id} style={{ opacity: todo.pending ? 0.5 : 1 }}>
              {todo.text}
            </div>
          ))}
          <button onClick={() => handleAddTodo('New Todo')}>Add Todo</button>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: useEvent
  BODY: |
    ■ 目的

    ・イベントハンドラのメモ化
    ・依存配列なしで安定した参照を提供
    ・React 19 で導入（実験的）

    ■ 基本

    const handleEvent = useEvent((event) => {
      // イベント処理
    })

    ■ サンプル

    import { useEvent } from 'react'

    function MyComponent({ onChange }) {
      const handleChange = useEvent((e) => {
        onChange(e.target.value)
      })

      return <input onChange={handleChange} />
    }

#-------------------------------
# Custom & Render Hooks
#-------------------------------
- ENTRY:
  CATEGORY: カスタムHook

- ENTRY:
  EXPLAIN: カスタムHook
  BODY: |
    ■ 用途

      複数コンポーネントで共通のロジックを再利用

    ■ サンプル

    import { useCallback, useState } from "react"

    export type Xxx<T> = {
      init: T
    }

    export const useXxx = <T,>({ init }: Xxx<T>) => {
      const [value, setValue] = useState<typeof init>(init)

      const method = useCallback((val: typeof init) => {
        setValue(val)
      }, [])

      const JsxCompo = useCallback(() => {
        return <div>Hello</div>
      }, [])

      return { method, value, JsxCompo }
    }

- ENTRY:
  EXPLAIN: レンダーHooks
  BODY: |
    ■ 用途

      UI描画ロジックと状態管理ロジックをセットで再利用

    ■ サンプル

    import { useCallback, useMemo, useState } from "react"
    import { Checks } from "../components/Checks"

    type UseChecks = [boolean, () => JSX.Element]

    export const useChecks = (labels: string[]): UseChecks => {
      const [checkList, setCheckList] = useState(() => labels.map(() => false))

      const handleCheck = useCallback((target: number) => {
        setCheckList((checks) => checks.map((_, index: number) => index === target))
      }, [])

      const isAllChecked = useMemo(() => checkList.every((x) => x), [checkList] )

      const renderChecks = useCallback(() => (
        <Checks checkList={checkList} labels={labels} handler={handleCheck} />
      ), [checkList, labels, handleCheck])

      return [isAllChecked, renderChecks]
    }

- ENTRY:
  EXPLAIN: 各種Hookの長所・短所と実務上の注意点
  BODY: |
    ■ Custom Hooks

      長所

    ・再利用: コンポーネント間の状態・副作用ロジックの共有
    ・分離: UIとロジックの分離による薄いコンポーネント
    ・テスト容易: ロジック単体のユニットテストの実施
    ・型安全: ジェネリックを用いた型安全設計
    ・組合せ: 小さなHooksの組合せによる複雑振る舞いの構築

      短所

    ・抽象化過剰: 過度分割による追跡困難
    ・隠れた依存: 内部副作用やコンテキストの非可視化
    ・再レンダー問題: 毎回生成されるオブジェクト・関数による不要再レンダー => useCallback/useMemo必須
    ・依存配列リスク: useEffect等の依存漏れによるバグリスク

    ■ Render Hooks

      長所

    ・UIとロジックのセット再利用: 描画関数付きロジックの再利用
    ・配置柔軟性: 親側での描画位置・ラップの自由度
    ・複雑UI抽象化: 複数要素の合成コンポーネント提供

      短所

    ・パフォーマンス問題: 参照不安定による再レンダー増加
    ・可読性低下: JSXをHookから返すことによる実装フローの分かりにくさ 🔴
    ・テスト困難: UIとロジックの結合による単体テストの難易度上昇
    ・Hookルール違反リスク: レンダ関数内でのさらにHooks呼び出しの誤り

    ■ 実務上の注意点・推奨

    ・優先方針: ロジックはCustom Hooks、UIはコンポーネント合成
    ・返り値設計: state, handlers, helpersを中心とした返却設計
    ・安定化策: 関数・オブジェクトはuseCallback, useMemoでアイデンティティ安定化
    ・型付け: ジェネリックとReturnTypeで入力出力を明示
    ・命名規約: useXxx形式の単一責任命名
    ・テスト方針: 副作用はモック ロジックはユニットテスト, UIはRTLやスナップショットで検証
    ・代替検討: HOC, render, props, component compositionとの比較検討
    ・計測重視: React DevTools と Profilerによるレンダ回数測定と最適化判断

    ■ 結論

    ・基本方針: ロジックはCustom Hooksによる再利用、UIはコンポーネント合成による再利用
    ・Render Hooksは限定採用: 性能可読性のトレードオフを理解した上で利用

- ENTRY:
  EXPLAIN: 再レンダー問題
  BODY: |
    ■ 悪い例: メモ化された子（浅い比較: props の === を使う）

    const Child = React.memo(           // 🔴 Childは毎回レンダリングされる
      ({ onAction, options }: {
        onAction: () => void;           // 🔴 オブジェクトや関数は参照で比較
        options: { label: string }      //     毎回新しい参照になる
      }) => {
        const renders = useRef(0);
        console.log("Child render", ++renders.current);

        return (
          <div>
            <div>{options.label}</div>
            <button onClick={onAction}>Child Action</button>
          </div>
        );
      }
    );

    ■ 悪い例: カスタムHook（悪い実装：関数/オブジェクトを毎回生成して返す）

    function useBadCounter() {
      const [count, setCount] = useState(0);
      
      const handler = () => setCount((c) => c + 1);   // 🔴 useCallback必要

      const options = { label: `count=${count}` };    // 🔴 useMemo必要

      return { count, handler, options };
    }

    ■ 悪い例: 親コンポーネント

    export function ParentBad() {
      const { count, handler, options } = useBadCounter();  // 毎回新しい handler/options を受け取る
      
      console.log("ParentBad render count=", count);
      
      return (
        <div>
          <div>Parent count: {count}</div>
          <Child onAction={handler} options={options} />
        </div>
      );
    }
