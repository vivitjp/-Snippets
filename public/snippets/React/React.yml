---
#-------------------------------
# React Snippets
#-------------------------------

#-------------------------------
# Basic Components
#-------------------------------
- KEY: qw.コンポーネント.title
  CATEGORY: コンポーネント

- KEY: qw.コンポーネント.一般
  EXPLAIN: コンポーネント(一般)
  BODY: |
    ■ 関数コンポーネント (引数で型指定)

    type Props = { title: string }

    function Title({ title }: Props) {
      return <h1>{title}</h1>
    }

    ■ React.FC (React.FunctionComponent)

    type Props = { title: string }

    const TitleFC: React.FC<Props> = ({ title, children }) => (
      <h1>{title}{children}</h1>
    )

- KEY: qw.コンポーネント.children
  EXPLAIN: コンポーネント(children)
  BODY: |
    ■ children に引数を渡したい場合1

    type Props = {
      label: string;
      children: (value: string) => React.ReactNode
    }

    const LabeledWithArg: React.FC<Props> = ({ label, children }) => (
      <div>
        {label}
        {children("子要素の値")}
      </div>
    )

    ■ React.PropsWithChildren

    type Props = React.PropsWithChildren<{ label: string }>

    const Labeled: React.FC<Props> = ({ label, children }) => (
      <div>{label}{children}</div>
    )

- KEY: qw.コンポーネント.HTML要素
  EXPLAIN: コンポーネント(HTML要素)
  BODY: |
    ■ React.ComponentProps

    type InputProps = React.ComponentProps<'input'>  // HTML要素のProps型取得

    const TextInput = (props: InputProps) => {
      return <input {...props} />
    }

    ■ React.ComponentPropsWithRef

    type InputProps = React.ComponentPropsWithRef<'input'>

    const TextInput = React.forwardRef<HTMLInputElement, InputProps>((props, ref) => (
      <input ref={ref} {...props} />
    ))

    TextInput.displayName = 'TextInput'

    ■ React.forwardRef

    const MyBtn = React.forwardRef<
      HTMLButtonElement,
      React.ComponentPropsWithRef<'button'>
    >(
      (props, ref) => <button ref={ref} {...props} />
    )

    MyBtn.displayName = 'MyBtn'

- KEY: qw.コンポーネント.ジェネリック
  EXPLAIN: コンポーネント(ジェネリック)
  BODY: |
    ■ ジェネリックコンポーネント

    type Item<T> = { value: T }

    const ItemView = <T,>({ item }: { item: Item<T> }) => (
      <div>{String(item.value)}</div>
    )

    ■ ポリモーフィック（as プロパティ）コンポーネント

    ・汎用的なコンポーネントを作成、異なるHTML要素や他のコンポーネントとしてレンダリング可能にする

    type PolymorphicProps<C extends React.ElementType, P> =
      P & { as?: C } & Omit<React.ComponentPropsWithRef<C>, keyof P | 'as'>

    const Box = <C extends React.ElementType = 'div'>(props: PolymorphicProps<C, { variant?: string }>) => {
      const { as: Component = 'div', variant, ...rest } = props as any
      return <Component {...rest} />
    }

    ・使用例

    <Box variant="primary" />                  // divとしてレンダリング
    <Box as="section" variant="secondary" />   // sectionとしてレンダリング
    <Box as={MyBtn} onClick={() => {}} />      // MyBtnコンポーネントとしてレンダリング

- KEY: qw.コンポーネント.その他
  EXPLAIN: コンポーネント(その他)
  BODY: |
    ■ 識別共用体（Discriminated Union）で安全に切り替える

    type AnchorProps = { as: 'a'; href: string }
    type ButtonProps = { as?: 'button'; onClick?: () => void }
    type LinkOrButton = (AnchorProps | ButtonProps) & { children?: React.ReactNode }

    const LinkOrButtonComp = (props: LinkOrButton) =>
      props.as === 'a'
        ? <a href={props.href}>{props.children}</a>
        : <button onClick={props.onClick}>{props.children}</button>

    ■ 高階コンポーネント (HOC) の型

    function withExtra<P>(Comp: React.ComponentType<P>) {
      return (props: P & { extra?: string }) => <Comp {...props} />
    }

    ■ レンダープロップ（Render Prop）型

    type RenderProps = { children: (open: boolean) => JSX.Element }

    const Toggler = ({ children }: RenderProps) => {
      const [open, setOpen] = React.useState(false)
      return <div onClick={() => setOpen(v => !v)}>{children(open)}</div>
    }

#-------------------------------
# Handler
#-------------------------------
- KEY: qw.handler.category
  CATEGORY: ハンドラ

- KEY: qw.handle
  EXPLAIN: ハンドラ
  BODY: |
    ■ Submit

    const handleSubmit = useCallback(
      (e: React.FormEvent<HTMLFormElement>) => {
        console.log(`text: ${text}`)
        e.stopPropagation()
        e.preventDefault()
      },
      [text]
    )

    ■ button ハンドラ

    const handleClickButton = useCallback(
      (e: React.MouseEvent<HTMLButtonElement>) => {
        e.stopPropagation()
      },
      []
    )

    ■ Click Input ハンドラ

    const handleClickInputButton = useCallback(
      (e: React.MouseEvent<HTMLInputElement>) => {
        e.stopPropagation()
      },
      []
    )


    ■ Change Text ハンドラ

    const handleChangeText = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.currentTarget.value
        setText(value)
      },
      []
    )

    ■ Change Checkbox ハンドラ

    const handleChangeCheck = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.currentTarget.checked
        setIsChecked(value)
      },
      []
    )

    ■ Change Radio ハンドラ

    const handleChangeRadio = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = parseInt(e.currentTarget.value ?? "0")
        setRadio(value)
      },
      []
    )

    ■ Change Select ハンドラ

    const [selectedValue, setSelectedValue] = useState<number>(1)

    const handleChangeSelect = useCallback(
      (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = parseInt(e.currentTarget.value ?? 1)
        setSelectedValue(value)
      },
      []
    )

#-------------------------------
# Hooks
#-------------------------------
- KEY: qw.hooks.title
  CATEGORY: Hooks

- KEY: qw.hooks.useState
  EXPLAIN: useState
  BODY: |
    const [xxx, setXxx] = useState<string>("")
    const [xxx, setXxx] = useState<number>(0)
    const [xxx, setXxx] = useState<boolean>(false)
    const [xxx, setXxx] = useState<Map<string, any>>()
    const [xxx, setXxx] = useState<Set<string>>()

- KEY: qw.hooks.useEffect.基本
  EXPLAIN: useEffect(基本)
  BODY: |
    ■ 基本

    useEffect(() => {
      // 処理
    }, [])                // 初回レンダリング時のみ実行

    useEffect(() => {
      // 処理
    })                    // 毎回レンダリング時に実行

    useEffect(() => {
      // 処理
    }, [依存変数])         // 依存変数が変化した時に実行

    ■ Timeoutコールバック

    useEffect(() => {
      let timeoutId: NodeJS.Timeout | null = null

      timeoutId = setTimeout(() => {
        // 処理
      }, 1000)

      return () => {
        if (timeoutId) clearTimeout(timeoutId)
      }
    }, [])

- KEY: qw.hooks.useEffect.非同期
  EXPLAIN: useEffect(非同期)
  BODY: |
    ■ 非同期(async/await)

    useEffect(() => {
      const methodXxx = async () => {
        const xxx = await getXxx(xxxId)
      }
      methodXxx()
    }, [])

    ■ 即時関数

    useEffect(() => {
      (async (param:any) => {
        const xxx = await getXxx(xxxId)
      })(param)
    }, [])

    ■ 非同期(Promise.then)

    useEffect(() => {
      getXxx()
        .then((xxx) => { ... })
        .catch((err) => { ...  })
      return () => {
        ... // クリーンアップ処理
      }
    }, [])

- KEY: qw.hooks.useEffect.fetch
  EXPLAIN: useEffect(fetch/v18)
  BODY: |
    ■ fetch (v18)

    useEffect(() => {
      let isRead = false

      fetch(URL)
        .then((res) => res.json())
        .then((json) => {
          if (!isRead) setXxx(json)
        })
        .catch((err) => { ... })

      return () => {
        isRead = true
      }
    }, [])

#-------------------------------
# Hooks: useRef
#-------------------------------
- KEY: qw.useRef.input
  EXPLAIN: useRef
  BODY: |
    ■ Inputフォーカス

    import React, { useRef } from "react"

    export const FocusInput = () => {
      const inputRef = useRef<HTMLInputElement | null>(null)

      const handleFocus = () => {
        inputRef.current?.focus()
      }

      return (
        <>
          <input ref={inputRef} defaultValue="hello" />
          <button onClick={handleFocus}>Focus</button>
        </>
      )
    }

    ■ submit 時に値を読む（フォーム操作）

    import React, { useRef } from "react"

    export const ReadValueForm = () => {
      const inputRef = useRef<HTMLInputElement | null>(null)

      const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault()
        const val = inputRef.current?.value ?? ""
        // console.log("value:", val)
      }

      return (
        <form onSubmit={handleSubmit}>
          <input ref={inputRef} />
          <button type="submit">Submit</button>
        </form>
      )
    }

    ■ 非 null アサーションを使うパターン（注意）

    import React, { useEffect, useRef } from "react"

    export const AutoFocusInput = () => {
      // 初期は null(アクセス時に存在する前提)
      const inputRef = useRef<HTMLInputElement>(null!) 

      useEffect(() => {
        inputRef.current.focus()
      }, [])

      return <input ref={inputRef} />
    }

- KEY: qw.useRef.input
  EXPLAIN: useRefの配列
  BODY: |
    ■ createRef を配列で保持（要素数が固定または初期化時に決まる場合）

    import React, { createRef, useRef } from "react"

    export const FixedRefs = () => {
      const count = 3
      const refs = useRef<Array<React.RefObject<HTMLInputElement>>>(() =>
        Array.from({ length: count }, () => createRef<HTMLInputElement>())
      )()

      const focusSecond = () => refs[0]?.current && refs[1].current?.focus()

      return (
        <>
          {refs.map((r, i) => <input key={i} ref={r} defaultValue={`#${i}`} />)}
          <button onClick={focusSecond}>Focus #1</button>
        </>
      )
    }

    ■ コールバック ref を使う（可変長リストで型がシンプル）

    import React, { useRef } from "react"

    export const CallbackRefs = ({ items }: { items: string[] }) => {
      const refs = useRef<Array<HTMLInputElement | null>>([])

      return (
        <>
          {items.map((it, i) => (
            <input
              key={i}
              defaultValue={it}
              ref={(el) => (refs.current[i] = el)}
            />
          ))}
          <button onClick={() => refs.current[0]?.focus()}>Focus first</button>
        </>
      )
    }

    ■ useCallback で安全にセット（レンダリングごとの再生成を抑制）

    import React, { useRef, useCallback } from "react"

    export const StableSetterRefs = ({ items }: { items: string[] }) => {
      const refs = useRef<(HTMLInputElement | null)[]>([])
      const setRef = useCallback((el: HTMLInputElement | null, idx: number) => {
        refs.current[idx] = el
      }, [])

      return (
        <>
          {items.map((it, i) => (
            <input key={i} defaultValue={it} ref={(el) => setRef(el, i)} />
          ))}
          <button onClick={() => refs.current[items.length - 1]?.focus()}>Focus last</button>
        </>
      )
    }

    ■ 型付きユーティリティ関数で扱いやすくする

    type InputRef = HTMLInputElement | null

    export const useInputRefs = (count: number) => {
      const refs = useRef<InputRef[]>([])
      const getRef = (i: number) => (el: HTMLInputElement | null) => (refs.current[i] = el)
      return { refs, getRef }
    }

    // 使い方
    // const { refs, getRef } = useInputRefs(items.length)
    // <input ref={getRef(i)} />

#-------------------------------
# forwardRef
#-------------------------------

- KEY: qw.useRef.forwardRef
  EXPLAIN: forwardRef
  BODY: |
    ■ 用途

      親コンポーネントから子コンポーネントのDOM要素にアクセス

    ■ サンプル

    type Props = {
      text: string
      setText: React.Dispatch<React.SetStateAction<string>>
      title: string
    } & React.ComponentPropsWithRef<"input">

    export const InputRef = forwardRef<HTMLInputElement, Props>(
      ({ text, setText, title, ...args }, ref) => {
        const id = useId()

        ■ ハンドラ
        const handleChangeText = (e: React.ChangeEvent<HTMLInputElement>) => {
          const value = e.currentTarget.value
          setText(value)
        }

        return (
          <div>
            <label htmlFor={id}>{title}</label>
            <input {...args} id={id} ref={ref} onChange={handleChangeText} />
          </div>
        )
      }
    )

#-------------------------------
# Hooks: useReducer
#-------------------------------
- KEY: qw.hooks.useReducer
  EXPLAIN: useReducer
  BODY: |
    ■ 用途

      複雑な状態管理や複数の状態変化ロジックをまとめる

    ■ サンプル (flip関数)

    const [isTrue, flipFlag] = useReducer((flag: boolean) => !flag, false)


    ■ サンプル (カウンター)

    type Action = { type: "up" } | { type: "reset"; payload: { counter: number } }
    type State = { counter: number }

    const callback = (state: State, action: Action): State => {
      switch (action.type) {
        case "up":
          return { counter: state.counter + 1 }
        case "reset":
          return { counter: action.payload.counter }
      }
    }

    const UseReducer = () => {
      const [myCounter, dispatch] = useReducer(callback, { counter: 0 })
      const handleClickUp = () => {
        dispatch({ type: "up" })
      }
      const handleClickDown = () => {
        dispatch({ type: "reset", payload: { counter: 0 } })
      }

      return (
        <Section>
          <DivCell>{myCounter.counter}</DivCell>
          <Button onClick={handleClickUp}>Up</Button>
          <Button onClick={handleClickDown}>Reset</Button>
        </Section>
      )
    }

#-------------------------------
# Hooks: useContext
#-------------------------------
- KEY: qw.hooks.context
  EXPLAIN: useContext
  BODY: |
    ■ Context 定義と Provider

    import React, { createContext, useState, useContext, useEffect } from "react"
    import { useGetXXXHooks } from "../hooks/useGetXXXHooks"

    type DataType = {}
    type DataContextType = {
      data: DataType
      setData: (data: DataType) => void
    }

    const DataContext = createContext<DataContextType>({} as DataContextType)

    export const useContextHooks = () => {
      return useContext(DataContext)
    }

    export const ContextProvider = ({
      children,
    }: {
      children: React.ReactNode
    }) => {
      const { getData } = useGetXXXHooks()
      const [data, setData] = useState<DataType>()

      useEffect(() => {
        //getData(), setData()
      }, [])

      return (
        <DataContext.Provider value={{ data, setData }}>
          {children}
        </DataContext.Provider>
      )
    }

    ■ Usage ( ContextProvider でラップ )

    import { ContextProvider } from "....."

    export const UseContext = () => {
      return (
        <ContextProvider>
          <Component />
        </ContextProvider>
      )
    }

    ■ Component ( Context 利用例 )

    import { useContextHooks } from "....."
    export const Component = () => {
      const { data } = useContextHooks()
      return <Component data={data} />
    }

#-------------------------------
# Hooks: useId
#-------------------------------
  KEY: qw.useId
  EXPLAIN: useId ユニークID生成
  BODY: |
    const xxxid = React.useId()

#-------------------------------
# Custom Hooks
#-------------------------------
- KEY: qw.hooks.customHooks.title
  CATEGORY: |
    カスタムHook

- KEY: qw.Hooks.custom
  EXPLAIN: |
    カスタムHook: Closure
  BODY: |
    ■ 命名規則: useXxx

    import { useCallback, useState } from "react"

    export type Xxx<T> = {
      init: T
    }

    export const useXxx = <T,>({ init }: Xxx<T>) => {

      const [value, setValue] = useState<typeof init>(init)

      const method = useCallback((val: typeof init) => {
        setValue(val)
      }, [])

      const JsxCompo = useCallback(() => {
        return <div>Hello</div>
      }, [])

      return { method, value, JsxCompo }
    }

#-------------------------------
# Render Hooks
#-------------------------------
- KEY: qw.Hooks.customHooks.renderHooks
  EXPLAIN: |
    レンダーHooks
  BODY: |
    type UseChecks = [boolean, () => JSX.Element]

    // 注意: Hooks の宣言時にパラメタをもたせると動的変更に対処できない
    export const useChecks = (labels: readonly string[]): UseChecks => {
      const [checkList, setCheckList] = useState(() => labels.map(() => false))

      const handleCheck = (target: number) => {
        setCheckList((checks) => checks.map((_, index: number) => index === target))
      }

      const isAllChecked = checkList.every((x) => x)

      const renderChecks = () => (
        <Checks checkList={checkList} labels={labels} handler={handleCheck} />
      )

      return [isAllChecked, renderChecks]
    }
