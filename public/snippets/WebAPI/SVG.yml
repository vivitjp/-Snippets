---
#-------------------------------
# SVG
#-------------------------------
- KEY: svg.svg.category
  CATEGORY: SVG 基本

- KEY: svg.svg
  EXPLAIN: svgの属性
  BODY: |
    <svg 
      // x ={数値}  //親SVGに対する座標
      // y ={数値}  //親SVGに対する座標
      width ={数値}
      height ={数値}
      // viewBox ="0 0 W H" //表示範囲
      xmlns ="http://www.w3.org/2000/svg"
      preserveAspectRatio ="xMinYMin slice" //"slice"|"meet"
    > {children} </svg>

    ■ avg aspect比率
    preserveAspectRatio ="xMinYMin slice" //"slice"|"meet"

    ■ 共通属性(stroke/fill)
    stroke ="CSS色" //線色
    strokeWidth ="整数"
    strokeDasharray ="{数値} {数値}" //描 空
    strokeLinecap ="butt"|"round"|"square"
    strokeLinejoin ="arcs"|"bevel"|"miter"|"miter-clip"|"round"
    strokeOpacity ="0.1~1.0"
    fill ="CSS色"
    fillOpacity ="0.1~1.0"
    fillRule ="nonzero"|"evenodd"
    opacity ="0.1~1.0" //StrokeとFillを同時に
    shapeRendering ="CrispEdges"|"" //精密度(アンチエイリアス解除)

#-------------------------------
# テキスト要素
#-------------------------------

- KEY: svg.element.text
  EXPLAIN: text 要素
  BODY: |
    <text
      x ={数値} //X座標
      y ={数値} //Y座標
      fill ="CSS色"
      stroke ="CSS色"
      strokeWidth ={整数値}
      textAnchor ="start"|"middle"|"end"
      dominantBaseline =
        "text-after-edge"| //上: フォント空間最上
        "ideographic"|     //上: ひらがな，漢字，ハングル用
        "alphabetic"|      //上: アルファベット用
        "auto"|            //上: デフォルト
        "middle"|          //中央
        "central"|         //中央
        "mathematical"|    //下: 数値用
        "hanging"|         //下: ぶらさがり
        "text-before-edge" //下: フォント空間最下
      fontWeight ="normal"|"100-800" //SVGはCSSのような微妙な変化に未対応
      fontFamily ="sans-serif"|"serif"|"monospace",
      style ={{ fontSize: "18px" }} //CSSスタイル(fontサイズはここで指定)
      transform ={} //各種効果
      filter ={} //各種効果
    >
      テキスト
    </text>

#-------------------------------
# transform
#-------------------------------

# - KEY: svg.transform
#   EXPLAIN: transform
#   BODY: |

#-------------------------------
# PATH 要素
#-------------------------------

- KEY: svg.path.M
  EXPLAIN: path要素
  BODY: |
    ■ ディレクティブの大文字と小文字の違い
    大文字: 絶対座標
    小文字: 相対座標(前の座標からの相対位置)

    ■ 移動(M/m)
    <path d="M/m{MX},{MY}" />

      MX: 移動先X座標
      MY: 移動先Y座標

    ■ 弧(A/a)
    <path d="M{MX},{MY} A/a{HR},{VR} {angle} {flagLS} {flagClock} {X},{Y}" />

      MX: 移動先X座標
      MY: 移動先Y座標
      HR: 水平半径
      VR: 水直半径
      angle: {傾き}
      flagLS {1:長方向/0:短方向}
      flagClock {1:時計回/0:反時計回}
      X: {終点X座標}
      Y: {終点Y座標}

    ■ 線(L/l)
    <path d="M{MX},{MY} L/l{X},{Y}" />

      MX: 移動先X座標
      MY: 移動先Y座標
      X: 終点X座標
      Y: 終点Y座標

    ■ 水平線(H/h)
    <path d="M{MX},{MY} H/h{size}" />

      MX: 移動先X座標
      MY: 移動先Y座標
      size: 水平X座標移動距離

    ■ 垂直線(V/v)
    <path d="M{MX},{MY} V/v{size}" />

      MX: 移動先X座標
      MY: 移動先Y座標
      size: 水平Y座標移動距離

    ■ 3次ベジェ曲線(C/c)
    <path d="M{MX},{MY} C/c{X1},{Y1} {X2},{Y2} {X3},{Y3}" />

      MX: 移動先X座標
      MY: 移動先Y座標
      X1: 第1線X座標(MX-X1)
      Y1: 第1線Y座標(MY-Y1)
      X2: 第2線X座標(X1-X2)
      Y2: 第2線Y座標(Y1-Y2)
      X3: 第3線X座標(X2-X3)
      Y3: 第3線Y座標(Y2-Y3)

    ■ 3次ベジェ曲線(S/s)
    <path d="C/c{座標} S/s{X2},{Y2} {X3},{Y3}" />

      第1線: C{X3},{Y3}を軸にC/cの第3線を反転コピー(省略)
      X2: 第2線X座標(X1-X2)
      Y2: 第2線Y座標(Y1-Y2)
      X3: 第3線X座標(X2-X3)
      Y3: 第3線Y座標(Y2-Y3)

    ■ 2次ベジェ曲線(Q/q)
    <path d="M{MX},{MY} Q/q{X1},{Y1} {X2},{Y2}" />

      MX: 移動先X座標
      MY: 移動先Y座標
      X1: 第1線X座標(MX-X1)
      Y1: 第1線Y座標(MY-Y1)
      X2: 第2線X座標(X1-X2)
      Y2: 第2線Y座標(Y1-Y2)

    ■ 2次ベジェ曲線(T/t)
    <path d="C/c{座標} T/t{X2},{Y2}" />

      第1線: C{X3},{Y3}を軸にQ/qの第2線を反転コピー(省略)
      X2: 第2線X座標(X1-X2)
      Y2: 第2線Y座標(Y1-Y2)

#-------------------------------
# 他の要素
#-------------------------------

- KEY: svg.element.rectangle
  EXPLAIN: rectangle 要素
  BODY: |
    <rect
      x={X}
      y={Y}
      width={W}
      height={H}
      rx={RX} //角丸めX軸長
      ry={RY} //角丸めY軸長
    />

- KEY: svg.element.line
  EXPLAIN: line 要素
  BODY: |
    <line
      x1={X1} //開始点X座標
      y1={Y1} //開始点Y座標
      x2={X2} //終了点X座標
      y2={Y2} //終了点Y座標
    />

- KEY: svg.element.polyline
  EXPLAIN: polyline 要素
  BODY: |
    <polyline
      points={"X,Y X,Y X,Y X,Y,..."}
    />

- KEY: svg.element.polygon
  EXPLAIN: polygon 要素
  BODY: |
    <polygon
      points={"X,Y X,Y X,Y X,Y"} //4 sets
    />

- KEY: svg.element.circle
  EXPLAIN: circle 要素
  BODY: |
    <circle
      cx={CX} //円の中心X座標
      cy={CY} //円の中心Y座標
      r={R} //半径
    />

- KEY: svg.element.ellipse
  EXPLAIN: ellipse 要素
  BODY: |
    <ellipse
      cx={CX} //円の中心X座標
      cy={CY} //円の中心Y座標
      rx={RX} //X軸の半径
      ry={RY} //Y軸の半径
    />

- KEY: svg.element.image
  EXPLAIN: image 要素
  BODY: |
    <image
      width={W}
      height={H}
      href="URL"
      preserveAspectRatio={"xMinYMin meet"}
    />

#-------------------------------
# グループ
#-------------------------------

- KEY: svg.group
  EXPLAIN: group
  BODY: |
    <g id={id} fill={CSS色} stroke={CSS色}> //x, y, width, heightは無効
      <rect x={X} y={Y} width={W} height={H} />
      <rect x={X} y={Y} width={W} height={H} fill={CSS色} /> //色上書き
    </g>

#-------------------------------
# フィルタ
#-------------------------------

# - KEY: svg.filter
#   EXPLAIN: filter
#   BODY: |
#     <xxx
#     />

#-------------------------------
# クリップパス
#-------------------------------

- KEY: svg.clipPath
  EXPLAIN: clipPath
  BODY: |
    // const cpId = useId()
    <defs>
      <clipPath id={cpId}>
        <rect x={100} y={100} width={100} height={100} />
      </clipPath>
    </defs>
    <circle clipPath={`url(#${cpId})`} cx={X} cy={Y} r={R} />

#-------------------------------
# マスク(mask)
#-------------------------------

- KEY: svg.mask
  EXPLAIN: mask
  BODY: |
    // const maskId = useId()
    // fill= "#000"~"#FFF" //通過レベル
    // maskType= "luminance"(通過)|"alpha"
    <mask id={maskId} fill="#777"
      style={{ maskType: "luminance" } as CSSProperties} >
      <rect x={X} y={Y} width={W} height={H} />
    </mask>

    <circle mask={`url(#${maskId})`} cx={X} cy={Y} r={R} />

- KEY: svg.mask.imageByString
  EXPLAIN: maskで文字通過イメージ
  BODY: |
    // const id = useId()
    // fill= "#000"~"#FFF(100%)" //通過レベル
    <mask id={id}>
      <text x={X} y={Y} fill="#777"
        textAnchor="middle" dominantBaseline="central"
        style={{ fontSize: 数値, fontFamily: "monospace" }}
      >
        文字列
      </text>
    </mask>
    <image mask={`url(#${id})`}
      width={W} height={H}
      href="name.jpg"
      preserveAspectRatio={"xMinYMid slice"}
    />

#-------------------------------
# Use
#-------------------------------

- KEY: svg.use
  EXPLAIN: ノード複製
  BODY: |
    // const rectId = useId()
    <defs>
      <rect id={rectId} width={数値} height={数値} />
    </defs>
    <use href={`#${rectId}`} x={数値} y={数値} />

#-------------------------------
# 効果(effect)
#-------------------------------

- KEY: svg.effect.shadow
  EXPLAIN: effect シャドー
  BODY: |
    // const filterId = useId()
    // stdDeviation= 0~5...など
    <defs>
      <filter id={filterId}>
        <feDropShadow stdDeviation={数値} floodColor={CSS色} />
      </filter>
    </defs>
    <path filter={`url(#${filterId})`} d="PATH" />

- KEY: svg.effect.blur
  EXPLAIN: effect ぼかし
  BODY: |
    // const filterId = useId()
    // stdDeviation= 0~5...など
    <defs>
      <filter id={filterId}>
        <feGaussianBlur stdDeviation={2} />
      </filter>
    </defs>
    <image width={W} height={Y}
      href="name.jpg"
      filter={`url(#${filterId})`}
      preserveAspectRatio="xMinYMin meet"
    />

#-------------------------------
# グラデーション
#-------------------------------

- KEY: svg.gradation.radial
  EXPLAIN: radialGradient 円
  BODY: |
    // const filterId = useId()
    // offset: 0.0~1.0 / "0%"~"100%"
    <defs>
      <radialGradient id={filterId}>
        <stop offset={0}   stopColor={CSS色} />
        <stop offset={0.5} stopColor={CSS色} />
        <stop offset={1}   stopColor={CSS色} />
      </radialGradient>
    </defs>
    <circle cx={CX} cy={CY} r={R} fill={`url(#${filterId})`}/>

- KEY: svg.gradation.linear
  EXPLAIN: linearGradient 線
  BODY: |
    // const filterId = useId()
    // offset: 0.0~1.0 / "0%"~"100%"
    <defs>
      <linearGradient id={filterId}>
        <stop offset={0}   stopColor={CSS色} />
        <stop offset={0.5} stopColor={CSS色} />
        <stop offset={1}   stopColor={CSS色} />
      </linearGradient>
    </defs>
    <path d="PATH" fill={`url(#${filterId})`} />

- KEY: svg.gradation.linearGamma
  EXPLAIN: linearGradient 線(Gamma)
  BODY: |
    //const expoId = useId()
    //const filterId = useId()
    //exponent指数: 0.1~2.0
    <defs>
      <filter id={expoId}>
        <feComponentTransfer>
          <feFuncR type="gamma" exponent={0.5} />
          <feFuncG type="gamma" exponent={0.5} />
          <feFuncB type="gamma" exponent={0.5} />
        </feComponentTransfer>
      </filter>
      <linearGradient id={filterId}>
        <stop offset="0" stopColor={CSS色} />
        <stop offset="1" stopColor={CSS色} />
      </linearGradient>
    </defs>
    <path d="PATH" filter={`url(#${expoId})`} fill={`url(#${filterId})`} />

#-------------------------------
# ForeignObject
#-------------------------------

- KEY: svg.foreignObject
  EXPLAIN: foreignObject HTML使用
  BODY: |
    <foreignObject x={X} y={Y} width={W} height={H}
      requiredExtensions="http://www.w3.org/1999/xhtml"
    >
      <div>{text}</div>
    </foreignObject>

#-------------------------------
# event
#-------------------------------

- KEY: svg.event
  EXPLAIN: eventとpropagation
  BODY: |
    const handleMouse = (flag: boolean) => { }
    const handleClickInside = (e: React.MouseEvent<SVGCircleElement>) => {}
    const handleClickOutside = (e: React.MouseEvent<HTMLDivElement>) => {}

    <div onClick={handleClickOutside}> // 外部にPropagation
      <svg width={W} height={H}>
        <circle cx={CX} cy={CY} r={R} fill={CSS色}
          pointerEvents="fill"         // イベントターゲット
          onMouseEnter={() => handleMouse(true)}  //イベント
          onMouseLeave={() => handleMouse(false)} //イベント
          onClick={handleClickInside}  // 内部イベント
        />
      </svg>
    </div>

#-------------------------------
# 三角関数
#-------------------------------

- KEY: svg.trigonometric.atan2
  EXPLAIN: 三角関数 θ取得
  BODY: |
    const theta = Math.atan2(y,x)
    const w = Math.tan(theta) * H
    const H = Math.tan(theta) * W

#-------------------------------
# アニメーション
#-------------------------------

- KEY: svg.animation1.values
  EXPLAIN: Animation(values)
  BODY: |
    <animate
      attributeName="fill" //ターゲット属性(数値以外に適切)
      dur="数値s" // 持続時間
      repeatCount="indefinite"|"数値" // 反復回数
      values="white;blue;white"  //-- 属性値(from,to,byより優先)
      keyTimes="0;0.5;1" // valuesに対応する時間(0-1)
    />

- KEY: svg.animation2.from
  EXPLAIN: Animation(from/to-by)
  BODY: |
    <animate 
      attributeName="r" //ターゲット属性(数値に適切)
      from="0" //開始属性値(values属性があると無効)
      to="60" // 終了属性値(優先)
      または by="60" // ステップ属性値
      repeatCount="indefinite"|"数値" // 反復回数
      calcMode="linear"|"discrete"|"spline"|"paced"
    />

- KEY: svg.animation3.dur
  EXPLAIN: Animation(bur持続時間)
  BODY: |
    <animate 
      attributeName="r" //ターゲット属性(数値に適切)
      dur="数値s" // 持続時間
      to="60" // 終了属性値(優先)
      by="60" // ステップ属性値
      repeatCount="indefinite"|"数値" // 反復回数
      calcMode="linear"|"discrete"|"spline"|"paced"
    />

- KEY: svg.animation4.spline
  EXPLAIN: Animation(keySplines) Safari未対応
  BODY: |
    <animate
      attributeName="cx" //ターゲット属性(数値に適切)
      from="30"
      to="580"
      dur="数値s" // 持続時間
      begin="1s" // 開始時間
      calcMode="spline" // 変化モード
      keyTimes="0;1"
      keySplines="スペースで区切った数値"
      repeatCount="indefinite"|"数値" // 反復回数
    />
    //keySplinesサンプル
    // ** Safari has issues: "0.42; 0.0; 0.58; 1.0"
    //"Linear": "0.0 0.0 1.0 1.0"
    //"Ease": "0.25 0.1 0.25 1.0"
    //"Ease-in": "0.42 0 1.0 1.0"
    //"Ease-out": "0.0 0.0 0.58 1.0"
    //"Ease-in-out": "0.42 0.0 0.58 1.0"

#-------------------------------
# SVG Graph
#-------------------------------
- KEY: svg.sample.graph.category
  CATEGORY: SVG サンプル(Graph)

- KEY: svg.sample.graph.マーカー
  EXPLAIN: グラフ マーカー
  BODY: |
    import { useId } from "@chakra-ui/react";
    import { SVGAttributes, forwardRef, useRef } from "react";

    export type Marker = {
      x: number;
      y: number;
      spec?: SVGAttributes<SVGPathElement> & {
        w?: number;
        callback?: (Props: Marker) => JSX.Element;
      };
      hoverText?: string;
      fontSize?: number;
    };

    //定数
    const DEFAULT_MARKER_SIZE = 10;
    const DEFAULT_FONT_SIZE = 12;
    const DEFAULT_HEIGHT_SIZE = 20;
    const TOOLTIP_MIN_WIDTH = 40;
    const TOOLTIP_PADDING = 12;
    const MARKER_SENSITIVITY_ACTIVATION_SIZE = 5;
    const MARKER_SENSITIVITY = 3; //カーソルの反応をMARKERサイズより拡張

    type Tooltip = {
      x: number;
      y: number;
      w?: number;
      h?: number;
      fontSize?: number;
      hoverText: string;
    } & React.ComponentPropsWithRef<"input">;

    const Tooltip = forwardRef<SVGGElement, Tooltip>(
      (
        {
          x,
          y,
          w,
          h = DEFAULT_HEIGHT_SIZE,
          fontSize = DEFAULT_FONT_SIZE,
          hoverText,
        },
        ref
      ) => {
        const width = hoverText.length * 10;


        return (
          <g ref={ref} display={"none"}>
            <path
              d={`M${x - 20},${y + 8} h16 l5,-5 l5,5 h${
                width - 26
              } v${h} h-${width}z`}
              fill={"white"}
              stroke="#DDD"
            />
            <text
              x={x - 16}
              y={y + 13}
              textAnchor="start"
              fontSize={fontSize}
              transform="scale(1,-1)"
              transform-origin={`${x - 16} ${y + 13}`}
            >
              {hoverText}
            </text>
          </g>
        );
      }
    );

    //--------------------------
    // サークル
    //--------------------------
    export const MarkerCircle = ({ x, y, spec, hoverText, fontSize }: Marker) => {
      const ref = useRef<SVGCircleElement>(null);
      const handleMouse = (isEntered: boolean) => {
        ref.current?.setAttribute(
          "style",
          isEntered ? "display:block" : "display:none"
        );
      };
      const r = (spec?.w ?? DEFAULT_MARKER_SIZE) / 2;
      const id = useId();
      return [
        <g key={id}>
          <circle
            cx={x}
            cy={y}
            r={r}
            strokeWidth={spec?.strokeWidth ?? "1px"}
            stroke={spec?.stroke ?? "#777"}
            fill={spec?.fill ?? "none"}
            onMouseEnter={() => hoverText && handleMouse(true)}
            onMouseLeave={() => hoverText && handleMouse(false)}
          />
          {/* Hover用の透明領域(表示circleが小さい場合) */}
          {r < MARKER_SENSITIVITY_ACTIVATION_SIZE && (
            <circle
              cx={x}
              cy={y}
              r={r + MARKER_SENSITIVITY}
              strokeWidth={"0"}
              stroke={"none"}
              fill={"rgba(255, 0, 0, 0)"}
              onMouseEnter={() => hoverText && handleMouse(true)}
              onMouseLeave={() => hoverText && handleMouse(false)}
            />
          )}
        </g>,
        <>
          {hoverText && (
            <Tooltip
              ref={ref}
              x={x}
              y={y}
              hoverText={hoverText}
              fontSize={fontSize}
            />
          )}
        </>,
      ];
    };

    //--------------------------
    // ダイヤモンド
    //--------------------------
    export const MarkerDiamond = ({ x, y, spec, hoverText, fontSize }: Marker) => {
      const ref = useRef<SVGCircleElement>(null);
      const handleMouse = (isEntered: boolean) => {
        ref.current?.setAttribute(
          "style",
          isEntered ? "display:block" : "display:none"
        );
      };

      const w2 = spec?.w ?? DEFAULT_MARKER_SIZE / 2;
      const id = useId();
      return [
        <g key={id}>
          <path
            d={`M${x - w2},${y} l${w2},${-w2} l${w2},${w2} l${-w2},${w2}z`}
            strokeWidth={spec?.strokeWidth ?? "1px"}
            stroke={spec?.stroke ?? "#777"}
            fill={spec?.fill ?? "none"}
            onMouseEnter={() => hoverText && handleMouse(true)}
            onMouseLeave={() => hoverText && handleMouse(false)}
          />
          {/* Hover用の透明領域(表示circleが小さい場合) */}
          {w2 < MARKER_SENSITIVITY_ACTIVATION_SIZE && (
            <circle
              cx={x}
              cy={y}
              r={w2 + MARKER_SENSITIVITY}
              strokeWidth={"0"}
              stroke={"none"}
              fill={"rgba(255, 0, 0, 0)"}
              onMouseEnter={() => hoverText && handleMouse(true)}
              onMouseLeave={() => hoverText && handleMouse(false)}
            />
          )}
        </g>,
        <>
          {hoverText && (
            <Tooltip
              ref={ref}
              x={x}
              y={y}
              hoverText={hoverText}
              fontSize={fontSize}
            />
          )}
        </>,
      ];
    };

    //--------------------------
    // 四角
    //--------------------------
    export const MarkerSquare = ({ x, y, spec, hoverText, fontSize }: Marker) => {
      const ref = useRef<SVGCircleElement>(null);
      const handleMouse = (isEntered: boolean) => {
        ref.current?.setAttribute(
          "style",
          isEntered ? "display:block" : "display:none"
        );
      };

      const w = spec?.w ?? DEFAULT_MARKER_SIZE;
      const w2 = w / 2;

      const id = useId();
      return [
        <g key={id}>
          <path
            d={`M${x - w2},${y - w2} h${w} v${w} h${-w}z`}
            strokeWidth={spec?.strokeWidth ?? "1px"}
            stroke={spec?.stroke ?? "#777"}
            fill={spec?.fill ?? "none"}
            onMouseEnter={() => hoverText && handleMouse(true)}
            onMouseLeave={() => hoverText && handleMouse(false)}
          />
          {/* Hover用の透明領域(表示circleが小さい場合) */}
          {w2 < MARKER_SENSITIVITY_ACTIVATION_SIZE && (
            <circle
              cx={x}
              cy={y}
              r={w2 + MARKER_SENSITIVITY}
              strokeWidth={"0"}
              stroke={"none"}
              fill={"rgba(255, 0, 0, 0)"}
              onMouseEnter={() => hoverText && handleMouse(true)}
              onMouseLeave={() => hoverText && handleMouse(false)}
            />
          )}
        </g>,
        <>
          {hoverText && (
            <Tooltip
              ref={ref}
              x={x}
              y={y}
              hoverText={hoverText}
              fontSize={fontSize}
            />
          )}
        </>,
      ];
    };

    //--------------------------
    // 三角
    //--------------------------
    export const MarkerTriangle = ({ x, y, spec, hoverText, fontSize }: Marker) => {
      const ref = useRef<SVGCircleElement>(null);
      const handleMouse = (isEntered: boolean) => {
        ref.current?.setAttribute(
          "style",
          isEntered ? "display:block" : "display:none"
        );
      };

      const p = spec?.w ?? DEFAULT_MARKER_SIZE;
      const x2 = p / 2;
      const h2 = Math.sqrt(p) / 6;
      const id = useId();
      return [
        <g key={id}>
          <path
            d={`M${x - x2},${y - h2} l${x2},${p - h2} l${x2},${-p}z`}
            strokeWidth={spec?.strokeWidth ?? "1px"}
            stroke={spec?.stroke ?? "#777"}
            fill={spec?.fill ?? "none"}
            onMouseEnter={() => hoverText && handleMouse(true)}
            onMouseLeave={() => hoverText && handleMouse(false)}
          />
          {/* Hover用の透明領域(表示circleが小さい場合) */}
          {p < MARKER_SENSITIVITY_ACTIVATION_SIZE && (
            <circle
              cx={x}
              cy={y}
              r={p + MARKER_SENSITIVITY}
              strokeWidth={"0"}
              stroke={"none"}
              fill={"rgba(255, 0, 0, 0)"}
              onMouseEnter={() => hoverText && handleMouse(true)}
              onMouseLeave={() => hoverText && handleMouse(false)}
            />
          )}
        </g>,
        <>
          {hoverText && (
            <Tooltip
              ref={ref}
              x={x}
              y={y}
              hoverText={hoverText}
              fontSize={fontSize}
            />
          )}
        </>,
      ];
    };

    //--------------------------
    // X
    //--------------------------
    export const MarkerX = ({ x, y, spec, hoverText, fontSize }: Marker) => {
      const ref = useRef<SVGCircleElement>(null);
      const handleMouse = (isEntered: boolean) => {
        ref.current?.setAttribute(
          "style",
          isEntered ? "display:block" : "display:none"
        );
      };
      const w = spec?.w ?? DEFAULT_MARKER_SIZE;
      const id = useId();
      return [
        <g key={id}>
          <path
            d={`M${x - w / 2},${y - w / 2} l${w},${w} m0,${-w} l${-w},${w}`}
            strokeWidth={spec?.strokeWidth ?? "1px"}
            stroke={spec?.stroke ?? "#777"}
            fill={spec?.fill ?? "none"}
            onMouseEnter={() => hoverText && handleMouse(true)}
            onMouseLeave={() => hoverText && handleMouse(false)}
          />
          <circle
            cx={x}
            cy={y}
            r={w}
            strokeWidth={"0"}
            stroke={"none"}
            fill={"rgba(255, 0, 0, 0)"}
            onMouseEnter={() => hoverText && handleMouse(true)}
            onMouseLeave={() => hoverText && handleMouse(false)}
          />
        </g>,
        <>
          {hoverText && (
            <Tooltip
              ref={ref}
              x={x}
              y={y}
              hoverText={hoverText}
              fontSize={fontSize}
            />
          )}
        </>,
      ];
    };

- KEY: svg.sample.graph.1.カスタムHook
  EXPLAIN: グラフ1 カスタムHook
  BODY: |
    import React, { SVGAttributes } from "react";
    import { mathLib } from "~/utils/math";
    import { MarkerCircle } from "./Markers";

    export type UseGraph = {
      //SVG全体サイズ
      SIZE: {
        WIDTH: number; //px
        HEIGHT: number; //px
        //上下左右の余白
        MARGIN: {
          TOP: number;
          BOTTOM: number;
          LEFT: number;
          RIGHT: number;
        };
      };
      //グラフ
      graph: {
        // タイトル
        title: { text: string; size?: number };
        // 座標配列の配列
        data: {
          coordinates: { x: number; y: number }[]; //座標
          fill?: string; //色
        }[];

        // ツールチップCB
        tooltip?: (x: number, y: number) => string;

        // 軸罫線の描画
        axis: {
          data: {
            x: number[]; // x値
            y: number[]; // y値
          };
          size?: number;
        };

        // グラフ範囲
        range: {
          X: { MIN: number; MAX: number };
          Y: { MIN: number; MAX: number };
        };
      };
    };

    //==================================
    // ■ Graph
    //==================================
    export const useGraph = ({ SIZE, graph }: UseGraph) => {
      // 各サイズ定数
      const GRAPH_WIDTH = SIZE.WIDTH - (SIZE.MARGIN.LEFT + SIZE.MARGIN.RIGHT);
      const GRAPH_HEIGHT = SIZE.HEIGHT - (SIZE.MARGIN.TOP + SIZE.MARGIN.BOTTOM);
      const WIDTH_UNIT = GRAPH_WIDTH / (graph.range.X.MAX - graph.range.X.MIN);
      const HEIGHT_UNIT = GRAPH_HEIGHT / (graph.range.Y.MAX - graph.range.Y.MIN);

      //XY軸座標(値)取得メソッド
      const resolvers = {
        x: (n: number) => mathLib.round(n * WIDTH_UNIT, 2) + SIZE.MARGIN.LEFT,
        y: (n: number) => mathLib.round(n * HEIGHT_UNIT, 2) + SIZE.MARGIN.BOTTOM,
      };

      const drawGraph = () => {
        return (
          <svg
            width={`${SIZE.WIDTH}px`}
            height={`${SIZE.HEIGHT}px`}
            viewBox={`0 0 ${SIZE.WIDTH} ${SIZE.HEIGHT}`} //表示範囲
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMinYMin meet"
          >
            {GraphTitle({ title: graph.title, SIZE })}
            {GraphAxisGroup({ axis: graph.axis, SIZE, resolvers })}
            {GraphMarker({ data: graph.data, resolvers, tooltip: graph.tooltip })}
            {GraphSection({ ...SIZE })}
          </svg>
        );
      };

      return [drawGraph];
    };

    //==================================
    // ■ 画面セクション枠
    //==================================
    const GraphSection = ({ WIDTH, HEIGHT, MARGIN }: UseGraph["SIZE"]) => {
      return (
        <g>
          {Corner({
            x: MARGIN.LEFT,
            y: MARGIN.TOP,
            width: WIDTH - (MARGIN.LEFT + MARGIN.RIGHT),
            height: HEIGHT - (MARGIN.TOP + MARGIN.BOTTOM),
          })}
          {Rectangle({
            x: 1,
            y: 1,
            width: WIDTH - 2,
            height: HEIGHT - 2,
          })}
        </g>
      );
    };

    const Corner = ({
      x,
      y,
      width,
      height,
      stroke = "#777",
    }: SVGAttributes<SVGPathElement>) => {
      return (
        <path
          d={`M${x},${y} v${height} h${width}`}
          stroke={stroke}
          fill={"none"}
          strokeWidth={"1"}
          shapeRendering="CrispEdges"
        />
      );
    };

    const Rectangle = ({
      x,
      y,
      width,
      height,
      stroke = "#777",
    }: SVGAttributes<SVGPathElement>) => {
      return (
        <rect
          x={x}
          y={y}
          ry={10}
          width={width}
          height={height}
          stroke={stroke}
          fill={"none"}
          strokeWidth={"1"}
          shapeRendering="CrispEdges"
        />
      );
    };

    //==================================
    // ■ タイトル
    //==================================
    const GraphTitle = ({
      title,
      SIZE,
    }: {
      title: UseGraph["graph"]["title"];
      SIZE: UseGraph["SIZE"];
    }) => {
      const xCenter = SIZE.WIDTH / 2;

      return (
        <>
          {Title({
            x: xCenter,
            y: 8,
            text: title.text,
            fontSize: title.size,
          })}
        </>
      );
    };

    type Title = {
      x: number;
      y: number;
      text: string;
      transform?: string;
      fontSize?: number;
    };
    const Title = ({ x, y, text, transform, fontSize = 20 }: Title) => {
      return (
        <text
          x={x}
          y={y}
          dominantBaseline={"hanging"}
          textAnchor="middle"
          fontWeight={"400"}
          fontSize={fontSize}
          transform={transform}
        >
          {text}
        </text>
      );
    };

    //==================================
    // ■ 座標線
    //==================================
    const GraphAxisGroup = ({
      axis,
      SIZE,
      resolvers,
    }: {
      axis: UseGraph["graph"]["axis"];
      resolvers: { x: (n: number) => number; y: (n: number) => number };
      SIZE: UseGraph["SIZE"];
    }) => {
      const arrayX = GraphAxisX({
        coordinates: axis.data.x,
        resolver: resolvers.x,
        SIZE: SIZE,
        fontSize: axis.size,
      });
      const arrayY = GraphAxisY({
        coordinates: axis.data.y,
        resolver: resolvers.y,
        SIZE: SIZE,
        fontSize: axis.size,
      });

      return (
        <g>
          {arrayX.map((n, index) => (
            <React.Fragment key={index}>{n}</React.Fragment>
          ))}
          {arrayY.map((n, index) => (
            <React.Fragment key={index}>{n}</React.Fragment>
          ))}
        </g>
      );
    };

    type GraphAxis = {
      coordinates: number[];
      resolver: (n: number) => number;
      SIZE: UseGraph["SIZE"];
      fontSize?: number;
    };

    //共通属性
    const GraphAxisPathAttr = {
      strokeWidth: "1px",
      stroke: "#DDD",
      fill: "none",
      shapeRendering: "CrispEdges",
    } as const;

    //共通属性
    const GraphAxisPathText = {
      dominantBaseline: "central",
      textAnchor: "middle",
    } as const;

    const GraphAxisX = ({
      coordinates,
      resolver,
      SIZE,
      fontSize = 8,
    }: GraphAxis) => {
      return coordinates.map((cx, index) => {
        const x = resolver(cx);
        const y1 = SIZE.MARGIN.TOP;
        const y2 = SIZE.HEIGHT - (SIZE.MARGIN.TOP + SIZE.MARGIN.BOTTOM);
        return (
          <React.Fragment key={index}>
            <path d={`M${x},${y1} v${y2}`} {...GraphAxisPathAttr} />
            <text
              x={x}
              y={y2 + SIZE.MARGIN.TOP + 10}
              {...GraphAxisPathText}
              fontSize={fontSize}
            >
              {cx}
            </text>
          </React.Fragment>
        );
      });
    };

    const GraphAxisY = ({
      coordinates,
      resolver,
      SIZE,
      fontSize = 8,
    }: GraphAxis) => {
      const arranged: [number, string][] = [...coordinates]
        .reverse()
        .map((n, index) => [n, String(coordinates[index])]);
      return arranged.map(([cy, text], index) => {
        const y = resolver(cy) - SIZE.MARGIN.BOTTOM + SIZE.MARGIN.TOP;
        const x1 = SIZE.MARGIN.LEFT;
        const x2 = SIZE.WIDTH - (SIZE.MARGIN.LEFT + SIZE.MARGIN.RIGHT);
        return (
          <React.Fragment key={index}>
            <path d={`M${x1},${y} h${x2}`} {...GraphAxisPathAttr} />
            <text
              x={x1 - 10}
              y={y}
              {...GraphAxisPathText}
              textAnchor={"end"}
              fontSize={fontSize}
            >
              {text}
            </text>
          </React.Fragment>
        );
      });
    };

    //==================================
    // ■ マーカー
    //==================================
    const GraphMarker = ({
      data,
      tooltip,
      resolvers,
    }: {
      data: UseGraph["graph"]["data"];
      tooltip: UseGraph["graph"]["tooltip"];
      resolvers: { x: (n: number) => number; y: (n: number) => number };
    }) => {
      const circlesElements: JSX.Element[] = [];
      const tooltipsElements: JSX.Element[] = [];

      data.forEach((each) => {
        each.coordinates.forEach(({ x, y }) => {
          const [circlesElement, tooltipsElement] = MarkerCircle({
            x: resolvers.x(x),
            y: resolvers.y(y),
            spec: {
              stroke: "none",
              fill: each.fill,
              w: 6,
            },
            hoverText: tooltip && tooltip(x, y),
          });
          circlesElements.push(circlesElement);
          tooltipsElements.push(tooltipsElement);
        });
      });

      return (
        <g transform="scale(1,-1)" transform-origin="50% 50%">
          <g>
            {circlesElements.map((el, index) => (
              <React.Fragment key={index}>{el}</React.Fragment>
            ))}
          </g>
          <g>
            {tooltipsElements.map((el, index) => (
              <React.Fragment key={index}>{el}</React.Fragment>
            ))}
          </g>
        </g>
      );
    };

- KEY: svg.sample.graph.1.呼び出し
  EXPLAIN: グラフ1 呼び出し
  BODY: |
    import { c2j } from "../common/methods";
    import { useMBGraph } from "./useMBGraph";

    /** ------------------------------
    * SAMPLE_DATA
    ------------------------------ */
    const SAMPLE_DATA配列 = ["x", "y1", "y2"] as const;
    type SAMPLE_DATAKEY =
      typeof SAMPLE_DATA配列[number];
    export type SAMPLE_DATA型 = Record<
      SAMPLE_DATAKEY,
      string
    >;
    const SAMPLE_DATA_DATA = `
    50  37  28.32
    60  43  43.62
    70  51  52.91
    80 52  57.75
    90 61  61.24
    100 70  70.68
    `;

    const TBOM_SAMPLE_DATA = c2j(
      SAMPLE_DATA_DATA,
      SAMPLE_DATA配列 as unknown as string[]
    ) as SAMPLE_DATA型[];

    export const MB_Graph1 = () => {
      const [drawGraph] = useMBGraph({
        SIZE: {
          WIDTH: 400, //px
          HEIGHT: 240,
          MARGIN: { TOP: 50, BOTTOM: 50, LEFT: 60, RIGHT: 40 },
        } as const,
        graph: {
          title: { text: "SAMPLE", size: 14 },
          data: [
            {
              coordinates: TBOM_SAMPLE_DATA.map((data) => ({
                x: Number(data.x),
                y: Number(data.y1),
              })),
              fill: "blue",
            },
          ],
          tooltip: (x: number, y: number) => `${x}:${y}`, //自由編集
          axis: {
            data: {
              x: [0, 50, 100],
              y: [0, 20, 40, 60, 80],
            },
            size: 9,
          },
          range: {
            X: { MIN: 0, MAX: 100 },
            Y: { MIN: 0, MAX: 80 },
          } as const,
        },
      });

      return <>{drawGraph()}</>;
    };

- KEY: svg.sample.graph.2.カスタムHook
  EXPLAIN: グラフ2 カスタムHook
  BODY: |
    import React, { SVGAttributes } from "react";
    import { Marker } from "./Markers";
    import { mathLib } from "~/utils/math";

    export type UseSAMPLE_all = {
      //SVG全体サイズ
      SIZE: {
        WIDTH: number; //px
        HEIGHT: number; //px
        //上下左右の余白
        MARGIN: {
          TOP: number;
          BOTTOM: number;
          LEFT: number;
          RIGHT: number; //凡例位置を確保
        };
      };
      //グラフ
      graph: {
        // タイトル
        title?: { text: string; size?: number };
        // 座標 & 線種など属性の配列
        data: {
          coordinates: { x: number; y: number }[]; //座標
          specs?: {
            line?: SVGAttributes<SVGPathElement>;
            marker?: SVGAttributes<SVGPathElement>;
            markerCB?: (Props: Marker) => JSX.Element[];
          };
          title?: string; //凡例タイトル
        }[];
        markerVisible: number[]; // 指定Y座標のみマーカーを表示
        legendFontSize?: number; //凡例タイトルサイズ

        // ツールチップCB
        tooltip?: (x: number, y: number) => string;

        // 軸罫線の描画
        axis: {
          data: {
            x: [number, string?][];
            y: number[];
          };
          title: {
            x: string;
            y: string;
          };
          size?: number;
        };

        // グラフ範囲
        range: {
          X: { MIN: number; MAX: number };
          Y: { MIN: number; MAX: number };
        };
      };
    };

    type Resolvers = {
      x: (n: number) => number;
      y: (n: number) => number;
    };

    //==================================
    // ■ Graph
    //==================================
    export const useSAMPLE_all = ({ SIZE, graph }: UseSAMPLE_all) => {
      // 各サイズ定数
      const GRAPH_WIDTH = SIZE.WIDTH - (SIZE.MARGIN.LEFT + SIZE.MARGIN.RIGHT);
      const GRAPH_HEIGHT = SIZE.HEIGHT - (SIZE.MARGIN.TOP + SIZE.MARGIN.BOTTOM);
      const HEIGHT_UNIT = GRAPH_HEIGHT / (graph.range.Y.MAX - graph.range.Y.MIN);

      //XY軸座標(値)取得メソッド
      const WIDTH_DIV = GRAPH_WIDTH / 3;
      const DIVIDER = [10, 100, 1000]; //グラフ X軸を3分割して表示

      // X軸の指数表記変換メソッド
      const coefficient = 2.5 as const; //この数値で変化の幅を調整
      const adjuster = (n: number) => Math.sqrt(Math.sqrt(n)) ** coefficient;
      const WIDTH_UNITS = DIVIDER.map((n) => WIDTH_DIV / (adjuster(n) * 100));

      // X軸座標(値)
      const resolverX = (n: number): number => {
        const rooted = adjuster(n) * 100;
        const calc = (index: number) => {
          const axisX =
            mathLib.round(rooted * WIDTH_UNITS[index], 2) + WIDTH_DIV * index;
          return SIZE.MARGIN.LEFT + axisX;
        };

        if (n <= DIVIDER[0]) {
          return calc(0);
        } else if (n <= DIVIDER[1]) {
          return calc(1);
        } else {
          return calc(2);
        }
      };

      // Y軸座標(値)
      const resolverY = (n: number): number => {
        return mathLib.round(n * HEIGHT_UNIT, 2) + SIZE.MARGIN.BOTTOM;
      };

      //XY軸座標(値)取得メソッド
      const resolvers: Resolvers = {
        x: resolverX,
        y: resolverY,
      };

      const drawGraph = () => {
        return (
          <svg
            width={`${SIZE.WIDTH}px`}
            height={`${SIZE.HEIGHT}px`}
            viewBox={`0 0 ${SIZE.WIDTH} ${SIZE.HEIGHT}`} //表示範囲
            xmlns="http://www.w3.org/2000/svg"
            preserveAspectRatio="xMinYMin meet"
          >
            {AxisTitleGroup({ title: graph.axis.title, SIZE })}
            {GraphAxisGroup({ axis: graph.axis, resolvers, SIZE })}
            {GraphCurveGroup({
              data: graph.data,
              resolvers,
              markerVisible: graph.markerVisible,
              tooltip: graph.tooltip,
            })}
            {GraphLegend({ graph, SIZE })}
            {graph.title && GraphTitle({ title: graph.title, SIZE })}
            {GraphSection({ ...SIZE })}
          </svg>
        );
      };

      return [drawGraph];
    };

    //==================================
    // ■ 画面セクション枠
    //==================================
    const GraphSection = ({ WIDTH, HEIGHT, MARGIN }: UseSAMPLE_all["SIZE"]) => {
      return (
        <g>
          {Corner({
            x: MARGIN.LEFT,
            y: MARGIN.TOP,
            width: WIDTH - (MARGIN.LEFT + MARGIN.RIGHT),
            height: HEIGHT - (MARGIN.TOP + MARGIN.BOTTOM),
          })}
        </g>
      );
    };

    const Corner = ({
      x,
      y,
      width,
      height,
      stroke = "#777",
    }: SVGAttributes<SVGPathElement>) => {
      return (
        <path
          d={`M${x},${y} v${height} h${width}`}
          stroke={stroke}
          fill={"none"}
          strokeWidth={"1"}
          shapeRendering="CrispEdges"
        />
      );
    };

    const Rectangle = ({
      x,
      y,
      width,
      height,
      stroke = "#777",
    }: SVGAttributes<SVGPathElement>) => {
      return (
        <path
          d={`M${x},${y} v${height} h${width} v-${height}z`}
          stroke={stroke}
          fill={"none"}
          strokeWidth={"1"}
          shapeRendering="CrispEdges"
        />
      );
    };

    //==================================
    // ■ タイトル
    //==================================
    const GraphTitle = ({
      title,
      SIZE,
    }: {
      title: UseSAMPLE_all["graph"]["title"];
      SIZE: UseSAMPLE_all["SIZE"];
    }) => {
      if (!title) return <></>;
      const xCenter = SIZE.WIDTH / 2;
      return (
        <>
          {Title({
            x: xCenter,
            y: 8,
            text: title.text,
            fontSize: title.size,
          })}
        </>
      );
    };

    type Title = {
      x: number;
      y: number;
      text: string;
      transform?: string;
      fontSize?: number;
    };
    const Title = ({ x, y, text, transform, fontSize = 20 }: Title) => {
      return (
        <text
          x={x}
          y={y}
          dominantBaseline={"hanging"}
          textAnchor="middle"
          fontWeight={"400"}
          fontSize={fontSize}
          transform={transform}
        >
          {text}
        </text>
      );
    };

    //==================================
    // ■ 凡例
    //==================================
    const GraphLegend = ({
      graph,
      SIZE,
    }: {
      graph: UseSAMPLE_all["graph"];
      SIZE: UseSAMPLE_all["SIZE"];
    }) => {
      const MARGIN = 10;
      const x = SIZE.WIDTH - SIZE.MARGIN.RIGHT + 10;
      const y = SIZE.MARGIN.TOP;
      const w = SIZE.MARGIN.RIGHT - 20;
      const fontSize = graph.legendFontSize ?? 10;
      const height = (fontSize + MARGIN) * graph.data.length + MARGIN;
      const arrangedY = Array(graph.data.length)
        .fill(0)
        .map((_, index) => {
          return y + (fontSize + MARGIN) * index + 4; //4 調整
        });

      return (
        <>
          <Rectangle x={x} y={y} width={w} height={height} />
          {graph.data.map((n, index) => (
            <React.Fragment key={index}>
              <Legend
                data={n}
                x={x + 4} //4 調整
                y={arrangedY[index]}
                fontSize={fontSize}
              />
            </React.Fragment>
          ))}
        </>
      );
    };

    const Legend = ({
      data,
      x,
      y,
      fontSize,
    }: {
      data: UseSAMPLE_all["graph"]["data"][0];
      x: number;
      y: number;
      fontSize: number;
    }) => {
      const MARGIN = 10;

      const markers = (data.specs?.markerCB &&
        data.specs?.markerCB({
          x: x + MARGIN,
          y: y + MARGIN,
          spec: data.specs?.marker,
        })) ?? [<></>];

      return (
        <g>
          {markers.map((n, index) => (
            <React.Fragment key={index}>{n}</React.Fragment>
          ))}

          <text
            x={x + MARGIN + 16} //add margin
            y={y + MARGIN + 2}
            fontSize={fontSize}
            dominantBaseline={"middle"}
          >
            {data.title}
          </text>
        </g>
      );
    };

    //==================================
    // ■ 座標線
    //==================================
    const GraphAxisGroup = ({
      axis,
      SIZE,
      resolvers,
    }: {
      axis: UseSAMPLE_all["graph"]["axis"];
      resolvers: Resolvers;
      SIZE: UseSAMPLE_all["SIZE"];
    }) => {
      const arrayX = GraphAxisX({
        coordinates: axis.data.x,
        resolver: resolvers.x,
        SIZE: SIZE,
      });
      const arrayY = GraphAxisY({
        coordinates: axis.data.y,
        resolver: resolvers.y,
        SIZE: SIZE,
      });

      return (
        <g>
          {arrayX.map((n, index) => (
            <React.Fragment key={index}>{n}</React.Fragment>
          ))}
          {arrayY.map((n, index) => (
            <React.Fragment key={index}>{n}</React.Fragment>
          ))}
        </g>
      );
    };

    const GraphAxisPathAttr = {
      strokeWidth: "1px",
      stroke: "#DDD",
      fill: "none",
      shapeRendering: "CrispEdges",
    } as const;

    const GraphAxisPathText = {
      dominantBaseline: "central",
      textAnchor: "middle",
    } as const;

    type GraphAxisX = {
      coordinates: [number, string?][];
      resolver: Resolvers["x"];
      SIZE: UseSAMPLE_all["SIZE"];
    };

    const GraphAxisX = ({ coordinates, resolver, SIZE }: GraphAxisX) => {
      return coordinates.map(([cx, text], index) => {
        const x = resolver(cx);
        const y1 = SIZE.MARGIN.TOP;
        const y2 = SIZE.HEIGHT - (SIZE.MARGIN.TOP + SIZE.MARGIN.BOTTOM);
        return (
          <React.Fragment key={index}>
            <path d={`M${x},${y1} v${y2}`} {...GraphAxisPathAttr} />
            {text && (
              <text x={x} y={y2 + 35} {...GraphAxisPathText}>
                {text}
              </text>
            )}
          </React.Fragment>
        );
      });
    };

    type GraphAxisY = {
      coordinates: number[];
      resolver: Resolvers["y"];
      SIZE: UseSAMPLE_all["SIZE"];
    };

    const GraphAxisY = ({ coordinates, resolver, SIZE }: GraphAxisY) => {
      const arranged: [number, string][] = [...coordinates]
        .reverse()
        .map((n, index) => [n, String(mathLib.round(coordinates[index], 1))]);

      return arranged.map(([cy, text], index) => {
        const y = resolver(cy) - SIZE.MARGIN.BOTTOM + SIZE.MARGIN.TOP;
        const x1 = SIZE.MARGIN.LEFT;
        const x2 = SIZE.WIDTH - (SIZE.MARGIN.LEFT + SIZE.MARGIN.RIGHT);
        return (
          <React.Fragment key={index}>
            <path d={`M${x1},${y} h${x2}`} {...GraphAxisPathAttr} />
            {text && (
              <text x={x1 - 10} y={y} {...GraphAxisPathText} textAnchor={"end"}>
                {text}
              </text>
            )}
          </React.Fragment>
        );
      });
    };

    //==================================
    // ■ 軸タイトル
    //==================================
    const AxisTitleGroup = ({
      title,
      SIZE,
    }: {
      title: UseSAMPLE_all["graph"]["axis"]["title"];
      SIZE: UseSAMPLE_all["SIZE"];
    }) => {
      const GRAPH_WIDTH = SIZE.WIDTH - (SIZE.MARGIN.LEFT + SIZE.MARGIN.RIGHT);
      const GRAPH_HEIGHT = SIZE.HEIGHT - (SIZE.MARGIN.TOP + SIZE.MARGIN.BOTTOM);

      const xCenter = SIZE.MARGIN.LEFT + GRAPH_WIDTH / 2;
      const yCenter = SIZE.MARGIN.TOP + GRAPH_HEIGHT / 2;

      return (
        <>
          {AxisTitle({
            x: 30,
            y: yCenter,
            text: title.y,
            transform: `rotate(270,${30},${yCenter})`,
          })}
          {AxisTitle({
            x: xCenter,
            y: SIZE.MARGIN.TOP + GRAPH_HEIGHT + 40,
            text: title.x,
          })}
        </>
      );
    };

    type AxisTitle = { x: number; y: number; text: string; transform?: string };
    const AxisTitle = ({ x, y, text, transform }: AxisTitle) => {
      return (
        <text
          x={x}
          y={y}
          dominantBaseline={"central"}
          fontSize={16}
          textAnchor="middle"
          fontWeight={"600"}
          transform={transform}
        >
          {text}
        </text>
      );
    };

    //==================================
    // ■ マーカーとグラフ線
    //==================================
    const GraphCurveGroup = ({
      data,
      resolvers,
      markerVisible,
      tooltip,
    }: {
      data: UseSAMPLE_all["graph"]["data"];
      resolvers: Resolvers;
      markerVisible: UseSAMPLE_all["graph"]["markerVisible"];
      tooltip: UseSAMPLE_all["graph"]["tooltip"];
    }) => {
      const markersTooltips = data.map((n) =>
        GraphMarker({
          data: n,
          resolvers: resolvers,
          markerVisible: markerVisible,
          tooltip: tooltip,
        })
      );

      return (
        <g transform="scale(1,-1)" transform-origin="50% 50%">
          {data.map((n, index) => (
            <GraphCurve key={index} data={n} resolvers={resolvers} />
          ))}
          {markersTooltips.map((n) =>
            n?.markers.map((marker, index) => (
              <React.Fragment key={index}>{marker}</React.Fragment>
            ))
          )}
          {markersTooltips.map((n) =>
            n?.tooltips.map((tooltip, index) => (
              <React.Fragment key={index}>{tooltip}</React.Fragment>
            ))
          )}
        </g>
      );
    };

    //------------------------
    // ■ Marker
    //------------------------
    const GraphMarker = ({
      data,
      resolvers,
      markerVisible,
      tooltip,
    }: {
      data: UseSAMPLE_all["graph"]["data"][0];
      resolvers: Resolvers;
      markerVisible: UseSAMPLE_all["graph"]["markerVisible"];
      tooltip: UseSAMPLE_all["graph"]["tooltip"];
    }) => {
      const array = data.coordinates.map(({ x, y }) => {
        if (!data.specs?.markerCB || !markerVisible.includes(x)) return [<></>];
        return data.specs?.markerCB({
          x: resolvers.x(x),
          y: resolvers.y(y),
          spec: data.specs?.marker,
          hoverText: tooltip && tooltip(x, y),
        });
      });

      if (!array.length) return undefined;
      return { markers: array.map((n) => n[0]), tooltips: array.map((n) => n[1]) };
    };

    //------------------------
    // ■ グラフ線
    //------------------------
    type CoordinateLine = { x1: number; y1: number; x2: number; y2: number };

    const GraphCurve = ({
      data,
      resolvers,
    }: {
      data: UseSAMPLE_all["graph"]["data"][0];
      resolvers: Resolvers;
    }) => {
      const coordinate = data.coordinates.reduce((acc, cur, index) => {
        if (data.coordinates.length < index + 2) return acc;
        return [
          ...acc,
          {
            x1: resolvers.x(cur.x),
            y1: resolvers.y(cur.y),
            x2: resolvers.x(data.coordinates[index + 1].x),
            y2: resolvers.y(data.coordinates[index + 1].y),
          },
        ];
      }, [] as CoordinateLine[]);
      if (!coordinate.length) return <></>;

      return (
        <g>
          {coordinate.map((coordinate, index) => (
            <path
              key={index}
              d={`M${coordinate.x1},${coordinate.y1} L${coordinate.x2},${coordinate.y2}`}
              strokeWidth={data.specs?.line?.strokeWidth ?? "2px"}
              stroke={data.specs?.line?.stroke ?? "#777"}
              fill={"none"}
              strokeDasharray={data.specs?.line?.strokeDasharray}
              shapeRendering="CrispEdges"
            />
          ))}
        </g>
      );
    };

- KEY: svg.sample.graph.2.呼び出し
  EXPLAIN: グラフ2 呼び出し
  BODY: |
    import { UseSAMPLE_all, useSAMPLE_all } from "./useSAMPLE_all";
    import {
      MarkerDiamond,
      MarkerSquare,
      MarkerTriangle,
      MarkerX,
    } from "./Markers";
    import { c2j } from "../common/methods";


    /** ------------------------------
    * SAMPLE
    ------------------------------ */
    const SAMPLE配列 = [
      "Y_VALUE",
      "X_VALUE_1",
      "X_VALUE_2",
      "X_VALUE_3",
      "X_VALUE_4",
      "X_VALUE_5",
    ] as const;
    type SAMPLE_KEY = typeof SAMPLE配列[number];
    export type SAMPLE型 = Record<SAMPLE_KEY, string>;
    const SAMPLE_DATA = `
    5 1 1 1 1
    10  1 1 1 1
    20  1.28  1.25  1.25  1.25
    30  1.45  1.2 1.2 1.2
    40  1.625 1.35  1.4 1.4
    50  1.65  1.6 1.45  1.425
    60  1.625 1.45  1.4 1.4
    70  1.45  1.3 1.2 1.25
    80  1.1 1.1 1.25  1.25
    90  0.98  0.78  0.78  0.78
    100 0.85  0.85  0.85  0.75
    150 0.5 0.575 0.79  0.85
    300 0.45  0.55  0.87  0.85
    500 0.55  0.55  0.75  0.95
    800 0.45  0.55  0.75  0.85
    `;

    const TBOM_SAMPLE = c2j(
      SAMPLE_DATA,
      SAMPLE配列 as unknown as string[]
    ) as SAMPLE型[];

    const specs: UseSAMPLE_all["graph"]["data"][0]["specs"][] = [
      {
        line: { strokeDasharray: "10 3", stroke: "SteelBlue" },
        marker: { stroke: "SteelBlue", fill: "white" },
        markerCB: MarkerDiamond,
      },
      {
        line: { strokeDasharray: "3 3", stroke: "OrangeRed" },
        marker: { stroke: "OrangeRed", fill: "white" },
        markerCB: MarkerSquare,
      },
      {
        line: { strokeDasharray: "10 5 2 5", stroke: "MediumSeaGreen" },
        marker: {
          stroke: "MediumSeaGreen",
          fill: "white",
        },
        markerCB: MarkerTriangle,
      },
      {
        line: { strokeDasharray: "15 5 2 5", stroke: "Gold" },
        marker: { stroke: "Gold", fill: "white" },
        markerCB: MarkerX,
      },
    ];


    const TOC = [
      TBOM_SAMPLE.map((data) => ({
        x: Number(data.Y_VALUE),
        y: Number(data.X_VALUE_1),
      })),
      TBOM_SAMPLE.map((data) => ({
        x: Number(data.Y_VALUE),
        y: Number(data.X_VALUE_2),
      })),
      TBOM_SAMPLE.map((data) => ({
        x: Number(data.Y_VALUE),
        y: Number(data.X_VALUE_3),
      })),
      TBOM_SAMPLE.map((data) => ({
        x: Number(data.Y_VALUE),
        y: Number(data.X_VALUE_4),
      })),
    ];

    export const SAMPLE_all = () => {
      const [drawGraph] = useSAMPLE_all({
        SIZE: {
          WIDTH: 900, //px
          HEIGHT: 400,
          MARGIN: { TOP: 20, BOTTOM: 60, LEFT: 80, RIGHT: 200 },
        },
        //グラフ
        graph: {
          //prettier-ignore
          data: [
            { coordinates: TOC[0], specs: specs[0], title: "SAMPLE1 mm" },
            { coordinates: TOC[1], specs: specs[1], title: "SAMPLE2 mm" },
            { coordinates: TOC[2], specs: specs[2], title: "SAMPLE3 mm" },
            { coordinates: TOC[3], specs: specs[3], title: "SAMPLE4 mm" },
            { coordinates: TOC[4], specs: specs[4], title: "SAMPLE5 mm" },
          ],
          // 以下のY座標のみマーカーを表示
          markerVisible: [5, 10, 50, 100, 500, 1000],
          //凡例フォントサイズ
          legendFontSize: 10,
          //ツールチップ引数
          tooltip: (x: number, y: number) => `${x},${y}`, //自由編集
          //軸
          axis: {
            data: {
              //prettier-ignore
              x: [[1, "1"],[2],[3],[4],[5],[6],[7],[8],[9],
                [10, "10"],[20],[30],[40],[50],[60],[70],[80],[90],
                [100, "100"],[200],[300],[400],[500],[600],[700],[800],[900],
                [1000, "1000"],
              ],
              y: Array(10)
                .fill(0)
                .map((_, i) => i * 0.2),
            },
            title: { x: "X_VALUE[mm]", y: "F1 (Y値)" },
          },
          //データと軸の範囲
          range: {
            X: { MIN: 1, MAX: 1000 },
            Y: { MIN: 0, MAX: 1.8 },
          } as const,
        },
      });

      return <>{drawGraph()}</>;
    };
