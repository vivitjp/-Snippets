---
#-------------------------------
# Service Workers
#-------------------------------
- ENTRY:
  CATEGORY: Service Workers

- ENTRY:
  EXPLAIN: 概要 & メソッド
  BODY: |
    ■ 概要

    ・Webブラウザでバックグラウンドで動作するスクリプト
    ・ネットワークリクエストの制御、プッシュ通知の受信、バックグラウンド同期などが可能
    ・オフライン対応やパフォーマンス向上に利用される
    ・非同期APIで動作し、Promiseベースのインターフェースを提供
    ・同一オリジン（プロトコル、ドメイン、ポートが同じ）内でのみアクセス可能

    ■ ユースケース

    ・オフライン対応のウェブアプリケーションの構築
    ・プッシュ通知の受信と表示
    ・バックグラウンドでのデータ同期
    ・リソースのキャッシュと高速化

    ■ ブラウザサポート状況

    ・ほとんどのモダンブラウザでサポートされているが、古いブラウザではサポートされていない場合がある

    ■ 主なメソッド

    ・navigator.serviceWorker.register(scriptURL, options): サービスワーカーを登録
    ・navigator.serviceWorker.ready: サービスワーカーがアクティブになるのを待つ
    ・self.addEventListener('install', event): インストールイベントをリッスン
    ・self.addEventListener('activate', event): アクティベートイベントをリッスン
    ・self.addEventListener('fetch', event): フェッチイベントをリッスン
    ・self.addEventListener('push', event): プッシュイベントをリッスン
    ・self.addEventListener('sync', event): バックグラウンド同期イベントをリッスン

    ■ npm パッケージの種類

      npm install workbox-sw
      npm install sw-precache
      npm install sw-toolbox
      npm install serviceworker-webpack-plugin
      npm install next-pwa
      npm install react-service-worker
      npm install offline-plugin
      npm install pwa-asset-generator
      npm install vite-plugin-pwa
      npm install create-react-pwa

- ENTRY:
  EXPLAIN: 実装
  BODY: |
    ■ 実装(全メソッドを持つカスタムフック)

    import { useCallback } from 'react';

    function useServiceWorker() {
      // サービスワーカーの登録
      const registerServiceWorker = useCallback(async (scriptURL, options = {}) => {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register(scriptURL, options);
            console.log('サービスワーカーが登録されました:', registration);
            return registration;
          } catch (error) {
            console.error('サービスワーカーの登録エラー:', error);
            throw error;
          }
        } else {
          throw new Error('このブラウザはサービスワーカーをサポートしていません');
        }
      }, []);

      // サービスワーカーの準備完了を待つ
      const waitForServiceWorkerReady = useCallback(async () => {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.ready;
            console.log('サービスワーカーがアクティブになりました:', registration);
            return registration;
          } catch (error) {
            console.error('サービスワーカーの準備エラー:', error);
            throw error;
          }
        } else {
          throw new Error('このブラウザはサービスワーカーをサポートしていません');
        }
      }, []);

      return {
        registerServiceWorker,
        waitForServiceWorkerReady,
      };
    }

- ENTRY:
  EXPLAIN: 運用
  BODY: |
    ■ 実装運用(useServiceWorker)

    import useServiceWorker from './useServiceWorker';
    import { useEffect } from 'react';

    function App() {
      const { registerServiceWorker, waitForServiceWorkerReady } = useServiceWorker();

      useEffect(() => {
        // サービスワーカーの登録
        registerServiceWorker('/service-worker.js').catch(console.error);

        // サービスワーカーの準備完了を待つ
        waitForServiceWorkerReady().catch(console.error);
      }, [registerServiceWorker, waitForServiceWorkerReady]);

      return (
        <div>
          <h1>Service Worker Example</h1>
          <p>サービスワーカーが登録され、アクティブになるのを待っています。</p>
        </div>
      );
    }

- ENTRY:
  EXPLAIN: addEventListener 例
  BODY: |
    ■ addEventListener 例

    // service-worker.js

    // インストールイベント
    self.addEventListener('install', (event) => {
      console.log('サービスワーカーがインストールされました');
      // キャッシュの初期化などの処理をここに記述
    });

    // アクティベートイベント
    self.addEventListener('activate', (event) => {
      console.log('サービスワーカーがアクティブになりました');
      // 古いキャッシュの削除などの処理をここに記述
    });

    // フェッチイベント
    self.addEventListener('fetch', (event) => {
      console.log('フェッチリクエスト:', event.request.url);
      // リクエストの制御やキャッシュからのレスポンス提供などの処理をここに記述
    });

    // プッシュイベント
    self.addEventListener('push', (event) => {
      console.log('プッシュ通知を受信しました');
      // 通知の表示などの処理をここに記述
    });

    // バックグラウンド同期イベント
    self.addEventListener('sync', (event) => {
      console.log('バックグラウンド同期イベント:', event.tag);
      // 同期処理などの処理をここに記述
    });

- ENTRY:
  EXPLAIN: service-worker.js の最も短いが完全なサンプル
  BODY: |
    // public/service-worker.js
    const CACHE_NAME = 'sw-sample-v1';
    const PRECACHE_URLS = [
      '/',
      '/index.html',
      '/offline.html',
    ];

    // インストール：プリキャッシュ
    self.addEventListener('install', (event) => {
      self.skipWaiting();
      event.waitUntil(
        caches.open(CACHE_NAME).then((cache) => cache.addAll(PRECACHE_URLS))
      );
    });

    // アクティベート：古いキャッシュのクリーンアップ
    self.addEventListener('activate', (event) => {
      event.waitUntil(
        caches.keys().then((keys) =>
          Promise.all(
            keys
              .filter((key) => key !== CACHE_NAME)
              .map((key) => caches.delete(key))
          )
        )
      );
      self.clients.claim();
    });

    // フェッチ：キャッシュ優先、ネットワークから取得しつつランタイムキャッシュ
    self.addEventListener('fetch', (event) => {
      if (event.request.method !== 'GET') return;

      event.respondWith(
        caches.match(event.request).then((cachedResponse) => {
          if (cachedResponse) return cachedResponse;

          return fetch(event.request)
            .then((networkResponse) => {
              if (!networkResponse || networkResponse.status !== 200 || networkResponse.type !== 'basic') {
                return networkResponse;
              }
              const responseClone = networkResponse.clone();
              caches.open(CACHE_NAME).then((cache) => cache.put(event.request, responseClone));
              return networkResponse;
            })
            .catch(() => {
              // HTML ドキュメント要求はオフラインフォールバック
              const accept = event.request.headers.get('accept') || '';
              if (event.request.destination === 'document' || accept.includes('text/html')) {
                return caches.match('/offline.html');
              }
              return new Response('Offline', { status: 503, statusText: 'Offline' });
            });
        })
      );
    });
