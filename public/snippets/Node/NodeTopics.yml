---
#-------------------------------
# Node
#-------------------------------
- ENTRY:
  CATEGORY: Node

- ENTRY:
  EXPLAIN: |
    Node バージョン
  BODY: |
    ■ AWSの各種サービスがサポートする Node.js のバージョンに要注意
    Lambda: Node.js 18以前のバージョンは、2025年4月でサポート切れ

    Node.js リリース
    https://nodejs.org/ja/about/previous-releases
  TABLE:
    OPTION:
      ALIGN:
        - left
        - left
        - left
        - left
        - left
      HAS_TITLE: true
      WIDTH:
        - 10%
        - 25%
        - 20%
        - 20%
    BODY: |
      Node.js	コードネーム	最初のリリース	最終更新日	ステータス
      v24 🔵		2025/05/06	2025/05/14	Current🔵
      v23 🟡		2024/10/16	2025/05/14	Maintenance🟡
      v22 🔵	Jod	2024/04/24	2025/05/14	LTS🔵
      v21 ❌		2023/10/17	2024/04/10	End-of-life❌
      v20 🟡	Iron	2023/04/18	2025/05/14	Maintenance🟡
      v19 ❌		2022/10/18	2023/04/10	End-of-life❌
      v18 ❌	Hydrogen	2022/04/19	2025/03/27	End-of-life❌
      v17 ❌		2021/10/19	2022/06/01	End-of-life❌
      v16 ❌	Gallium	2021/04/20	2023/08/08	End-of-life❌
      v15 ❌		2020/10/20	2021/04/06	End-of-life❌
      v14 ❌	Fermium	2020/04/21	2023/02/16	End-of-life❌

- ENTRY:
  EXPLAIN: 設定
  BODY: |
    ■ 使用メモリ

    ・Node.jsのデフォルトのメモリ制限は約1.5GB
    ・大量データ処理や大規模アプリケーションでは、--max-old-space-size フラグでメモリ制限を増加可能
    ・例: node --max-old-space-size=4096 app.js  // 4GBに設定

        開発・小規模プロジェクト: 512MB → 1024MB
        中規模プロジェクト: 2048MB
        大規模アプリ / 多数の依存: 4096MB
        大規模モノレポ / 並列ビルド: 8192MB〜16384MB（ホストの物理RAMに依存）

    ■ 環境変数

    ・環境変数は、アプリケーションの設定や機密情報を管理するために使用
    ・process.env オブジェクトを通じてアクセス可能
    ・dotenv パッケージを使用して .env ファイルから環境変数をロード可能
    ・例: npm install dotenv
      require('dotenv').config();
      const dbPassword = process.env.DB_PASSWORD;

- ENTRY:
  EXPLAIN: 起動オプション
  BODY: |
    ■ --inspect

    ・リモートデバッガ（V8 Inspector）を有効化
    ・デフォルト: 127.0.0.1:9229
    ・用途: ライブデバッグ、プロファイリング

      例: node --inspect app.js

    ■ --inspect-brk

    ・起動時に最初の行でブレークしてデバッガ接続を待機
    ・用途: プロセス初期化のデバッグ

      例: node --inspect-brk app.js

    ■ -r, --require

    ・起動時にモジュールを事前ロード
    ・用途: トランスパイラ登録、polyfill 挿入

      例: node -r ts-node/register src/index.ts

    ■ --max-old-space-size=<MB>

    ・V8 ヒープの最大サイズ（MB）を指定
    ・用途: メモリ制限の調整（バッチ処理等）

      例: node --max-old-space-size=4096 app.js

    ■ --trace-warnings / --trace-deprecation

    ・警告や非推奨呼び出しのスタックトレースを出力
    ・用途: 非推奨箇所の検出、CI 監視

      例: node --trace-deprecation app.js

    ■ --trace-gc / --trace-gc-verbose

    ・GC の挙動ログを出力
    ・用途: メモリリーク調査、GC チューニング

      例: node --trace-gc app.js

    ■ --expose-gc

    ・global.gc() を有効化（手動 GC 呼び出し可能）
    ・用途: テストや特殊ケースのメモリ制御

      例: node --expose-gc app.js

    ■ --prof

    ・V8 プロファイルを生成（後で解析）
    ・用途: CPU ホットスポット解析

      例: node --prof app.js

    ■ --enable-source-maps

    ・ソースマップを有効にしてスタックトレースを復元
    ・用途: TypeScript / バンドル後のデバッグ

      例: node --enable-source-maps dist/app.js

    ■ --abort-on-uncaught-exception

    ・未処理例外で即時プロセス終了（コアダンプ等）
    ・用途: 障害解析（クラッシュ状態を残す）

    ■ --watch

    ・ファイル変更でプロセスを再起動（開発向け）
    ・注意: 本番ではプロセスマネージャ使用を推奨

      例: node --watch app.js

    ■ 環境変数: NODE_OPTIONS

    ・全 Node 起動に対する共通オプションを設定可能
    ・用途: コンテナ/CI の一括設定

    例:
      export NODE_OPTIONS="--max-old-space-size=2048 --trace-warnings"
      node app.js

    ■ 運用上の注意

    ・セキュリティ

      --inspect をパブリックに公開しない（認証無しでデバッグアクセスされる）

    ・本番でのフラグ

      --max-old-space-size 等は有効だが、--expose-gc や --inspect の常用は避ける

    ・永続的設定

      コンテナ/サービスで一括設定する場合は NODE_OPTIONS を使うと便利
      しかしデバッグ用オプションを誤って含めないよう注意する

    ・互換性

      一部のフラグは Node バージョン依存（事前に node --help / ドキュメントを確認する）

    ・パフォーマンス調整

      V8 フラグは強力だが副作用が出やすい
      変更は小さく、ベンチで検証してから本番へ

- ENTRY:
  EXPLAIN: レポジトリ(モノレポとポリレポ)
  BODY: |
    ■ Monorepo

    利点: 単一リポジトリで横断的な変更が容易、リファクタやAPI変更を一度で適用できる
    利点: コード・設定・CIを共有でき、依存同期が楽（workspaces）

    欠点: リポジトリ肥大化でクローン/CIが重くなる(ツール/パイプライン設計が必要)
    欠点: 権限分離や独立リリース運用が複雑化することがある

    ■ Multi-repo (Polyrepo)

    利点: 各プロジェクトが独立(小さく速いクローン・単純なCI・権限管理が容易)

    欠点: クロスリポジトリ変更が面倒、設定やスクリプトが重複しやすい、依存の不整合が起きやすい

    ■ 選び方ガイド

    ・チーム連携が高く依存が多い: Monorepo が有利（共通ライブラリが頻繁に変わる場合）
    ・完全に独立したサービス群／異なるライフサイクル: Multi-repo が適切
    ・スケール基準: パッケージ数やビルド時間が増えるなら、Monorepo で project references や分割ビルドを導入

    ■ 実務Tips

    ・必須ツール: pnpm/yarn/npm workspaces、リポ管理は lerna/nx/rush を検討
    ・CI最適化: 変更に応じた差分ビルド（affected/changed only）とキャッシュを使う
    ・TypeScript: 大規模なら composite + references で分割ビルド（速く安定）
    ・バージョン管理: 固定モード vs 独立モードを決め、changesets 等でリリース自動化
    ・Git対策: 大リポジトリは sparse-checkout / shallow clone / CI の部分チェックを活用
    ・リソース対策: CIランナーのメモリ上限や node --max-old-space-size を環境に合わせて調整

#-------------------------------
# Volta
#-------------------------------
- ENTRY:
  CATEGORY: |
    Nodeバージョン管理: Volta

- ENTRY:
  EXPLAIN: |
    Volta
  BODY: |
    ■ Node.js バージョン確認
    $ node -v
    v20.14.0

    ■ Volta インストール
    For Windows, download and run the Windows installer
    https://docs.volta.sh/guide/getting-started

    ■ Node.js インストール(複数のバージョンをインストール可能)
    volta install node@20.11.0                    // バージョン指定
    volta install node                            // LTS バージョン自動

    C:\Users\VIVIT\AppData\Local\Volta\tools\image\node\20.14.0\node.exe

    ■ yarn インストール
    volta install yarn

    ■ 要注意 uninstall
    node も yarn も uninstall に非対応

- ENTRY:
  EXPLAIN: Volta Pin
  BODY: |
    ■ 指定バージョンの Node.js を使用
    volta pin node@18.19
    volta pin yarn@1.19

- ENTRY:
  EXPLAIN: Volta Commands
  BODY: |
    fetch         ツールをローカル マシンにフェッチ
    install       ツールチェーンにツールをインストール
    uninstall     ツールチェーンからツールをアンインストール
    pin           ランタイム/パッケージマネージャー固定
    list          現在のツールチェーン表示

      $ volta list
      ⚡️ Currently active tools:
          Node: v20.14.0 (default)
          Tool binaries available: NONE

    completions   Volta 完了を生成
    which         Volta が呼ぶ実際のバイナリ表示
    setup         現在のユーザー/シェルに対して Volta 有効化
    help          ヘルプ出力

#-------------------------------
# nvm
#-------------------------------
- ENTRY:
  CATEGORY: |
    Nodeバージョン管理: nvm

- ENTRY:
  EXPLAIN: |
    nvm
  BODY: |
    ■ インストール
    nvm: https://github.com/coreybutler/nvm-windows/releases

    ■ バージョン確認
    > nvm version                       PowerShell使用
    1.1.11

    ■ Nodeバージョン
    > nvm ls

    ■ インストール Nodejs
    > nvm install 16.13.2

    ■ バージョン切替
    > nvm use 16.13.2
    Now using node v16.13.2 (64-bit)

    ■ デフォルトバージョン設定
    > nvm alias default 16.13.2
    default -> 16.13.2 (64-bit)
    ※VSCOde再起動!

#-------------------------------
# 一般 トピック
#-------------------------------

- ENTRY:
  CATEGORY: 一般 トピック

- ENTRY:
  EXPLAIN: |
    Express: webhook
  BODY: |
    ■ Webhookの受信
    • Webhookは、特定のイベント発生時、指定URLにHTTPリクエストを送信する仕組み
    • リアルタイムでデータを受信、処理

    ■ WebhookとAPI
    • データの流れ方(通信方式)が異なる
    • APIは、クライアントからサーバーにリクエストを送ってデータを取得する「プル型」通信方式
    • Webhookは、サーバーからクライアントにデータを送る「プッシュ型」通信方式

    ■ サンプル
      const express = require('express');
      const bodyParser = require('body-parser');
      const app = express();
      const port = 3000;

      app.use(bodyParser.json());

      app.post('/webhook', (req, res) => {
        const data = req.body;
        console.log('Received webhook data:', data);
        res.status(200).send('Webhook received successfully');
      });

      app.listen(port, () => {
        console.log(`Server listening on port ${port}`);
      });

- ENTRY:
  EXPLAIN: |
    Buffer
  BODY: |
    ■ バイナリデータを扱うためのクラス
    • Node.js専用のクラスでUint8Arrayのサブクラス 
    • Bufferは、固定長のバイナリデータを表現するオブジェクト

    ■ サンプル
      const buffer = Buffer.from('Hello, World!', 'utf8');
      console.log(buffer);              // <Buffer 48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 21>
      buffer.toJSON();                  // { type: 'Buffer', data: [ 72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33 ] }

      buffer.toString('utf8');          // Hello, World!
      buffer.length;                    // 13
      buffer[0];                        // 72 (ASCIIコードの'H')
      buffer.slice(0, 5).toString('utf8'); // Hello
      buffer.equals(Buffer.from('Hello, World!', 'utf8')); // true
      Buffer.isBuffer(buffer);          // true
      Buffer.alloc(10);                 // 10バイトのゼロで埋められたバッファ 
      Buffer.allocUnsafe(10);           // 10バイトの未初期化バッファ
      Buffer.concat([buffer, Buffer.from(' Goodbye!')]); // <Buffer 48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 21 20 47 6f 6f 64 62 79 65 21>
      Buffer.byteLength('Hello, World!', 'utf8'); // 13
      Buffer.from([72, 101, 108, 108, 111]); // <Buffer 48 65 6c 6c 6f>

      Buffer.from('48656c6c6f', 'hex'); // <Buffer 48 65 6c 6c 6f>
      buffer.write("o", 1);             // バッファの2バイト目に'o'を書き込む
      buffer.toString();                // "Hollo, World!"

#-------------------------------
# ID
#-------------------------------
- ENTRY:
  CATEGORY: ID 生成 Packages

- ENTRY:
  EXPLAIN: ID 生成パッケージの生成時間比較
  BODY: |
    参照: https://qiita.com/okm-uv/items/0b84c75e7524640dab11

    crypto.randomUUID         21,119,429 ops/sec
    uuid v4                   20,368,447 ops/sec ●
    @napi-rs/uuid             11,493,890 ops/sec
    uid/secure                 8,409,962 ops/sec
    @lukeed/uuid               6,871,405 ops/sec
    nanoid                     5,652,148 ops/sec ●
    customAlphabet             3,565,656 ops/sec
    secure-random-string         394,201 ops/sec
    uid-safe.sync                393,176 ops/sec
    cuid                         208,131 ops/sec ●
    shortid                       49,916 ops/sec

- ENTRY:
  EXPLAIN: 各フォーマットと特徴
  BODY: |
    ■ UUID (v4)

      36文字、128ビット(16進数の文字32個、乱数122ビット)
      Rがランダム、4が固定、rが2ビットだけ固定

      RRRRRRRR-RRRR-4RRR-rRRR-RRRRRRRRRRRR

    ■ NanoID

      21文字、乱数126ビット
      UUIDの問題「生成結果の文字列が長い」を解決

      V1StGXR8_Z5jdHi6B-myT

    ■ ULID

      UUIDの問題(長い,ソート不可)を解消
      16進数ではなく英数字
      前半48bit:timestamp(~10889年)、後半80bit:ランダム
      1.21*(10**24)個/msまでソート可能性維持

      01AN4Z07BY79KA1307SR9X4MV3

    ■ CUID

      スケーラブル、水平方向のスケーラビリティ
      パフォーマンスが良い

      ch72gsb320000udocl363eofy
      c - h72gsb32 - 0000 - udoc - l363eofy
        c:        固定値
        h72gsb32: timestamp
        0000:     Counter
        udoc :    クライアントのfingerprint(複数クライアント間でも衝突回避)
        l363eofy: ランダム
