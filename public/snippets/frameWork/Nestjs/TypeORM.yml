---
#-------------------------------
# TypeORM
#-------------------------------

#-------------------------------
# Quick Start
#-------------------------------

- KEY: orm.quick.entity
  EXPLAIN: Quick:Entity
  BODY: |
    @Entity('users')
    export class User {
      @PrimaryColumn({ type: 'varchar', comment: 'ID', length: 50 })
      id: string;
      @Column({ type: 'varchar', comment: 'Ê∞èÂêç', length: 255 })
      name?: string;
      @Column({ type: 'varchar', comment: 'ÁîüÂπ¥Êúà', length: 255 })
      birth_date?: string;
      @Column({ type: 'tinyint', comment: 'ÊÄßÂà•' })
      gender?: number;
    }

- KEY: orm.quick.service
  EXPLAIN: Quick:NestService
  BODY: |
    @Injectable()
    export class UsersService {
      constructor(
        @InjectRepository(User)
        private usersRepository: Repository<User>,
      ) {}

      async findByEmail(id: string): Promise<User> {
        const query: SelectQueryBuilder<User> =
          this.usersRepository.createQueryBuilder('users')
          .select(["id","name","birth_date"])
          .where('users.id = :id', { id });

        const user = await query.getOne();
        return user;
      }
    }

- KEY: orm.quick.reqParamValid
  EXPLAIN: Quick:ReqÂºïÊï∞Entity&Ê§úË®º
  BODY: |
    export class CreateUsersRequest {
      @MaxLength(255, { message: "---" })
      @IsNotEmpty({ message: "---" })
      name: string;

      @Matches(/^(\d{4})-(\d{2})$/, { message: "---" })
      @Length(7, 7, { message: "---" })
      @IsNotEmpty({ message: "---" })
      birth_date: string;

      @IsInt({ message: "---" })
      @IsNotEmpty({ message: "---" })
      cities_id: number;

      @IsNotEmpty({ message: "---") })
      @IsInt({ message: "---" })
      @Transform(({ value }) => Number(value))
      times_id: number;

      @IsOptional()
      @MaxLength(255, { message: "---" })
      @CustomIsJISString({ message: "---" })      // Custom Validator
      @Transform(({ value }) => value.replaceAll('\r\n', '\n'))
      memo: string;
    }

- KEY: orm.quick.dataSource
  EXPLAIN: dataSourceË®≠ÂÆö
  BODY: |
    const myDataSource = new DataSource({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "test",
      password: "test",
      database: "test",

      // EntityÂ∞éÂÖ•ÊñπÊ≥ï(ÂÄãÂà•)
      // import { User } from "./entity/User"
      entities: [User],

      // EntityÂ∞éÂÖ•ÊñπÊ≥ï(DirÂà•)
      entities: ["entity/*.js"],
    })

    @Entity()
    export class User {
      @PrimaryGeneratedColumn({ comment:'ID' })
      id: number;
    }

    ‚ñ† „Ç≥„Éº„É´ÊñπÊ≥ï
    1) Manager
    const person = await dataSource.manager.findOneBy(Person, { id: 1 })
    2) Repository
    const person = await dataSource.getRepository(Person).findOneBy({ id: 1 })

#-------------------------------
# Entity
#-------------------------------

- KEY: orm.entity
  EXPLAIN: EntityÂÆöÁæ©„Å®Á∂ôÊâø
  BODY: |
    ‚ñ† Entity
    @Entity('example')                            // EntityÂêç
    class Example { ... }

    ‚ñ† EntityÁ∂ôÊâø
    class Base {                                  // @Entity„Å™„Åó
      @Column()
      title: string
    }

    ‚ñ† EntityÁ∂ôÊâø(abstract)
    abstract class Base {                         // Á∂ôÊâøÂ∞ÇÁî®„ÇØ„É©„Çπ
      @Column()
      title: string
    }

    @Entity('example')                            // EntityÂêç
    class Example extends Base { ... }

    ‚ñ† EntityÁ∂ôÊâø(TableInheritance)
    @Entity('example')                            // EntityÂêç
    @TableInheritance({
      column: { type:"int", name:"type" }         // Âçò‰∏ÄË°å„ÅÆÁ∂ôÊâø
    })
    class Example extends Base { ... }

- KEY: orm.entity.naming
  EXPLAIN: „Ç´„É©„É†ÂëΩÂêç
  BODY: |
    ‚ñ† @Entity() „Å™„Åó
    export class Name {
      @Column()
      first: string
      
      @Column()
      last: string
    }

    ‚ñ† @Entity() „ÅÇ„Çä
    @Entity()
    export class User {
      @PrimaryGeneratedColumn()
      id: string
      
      @Column(() => Name)
      name: Name
    }

    +-------------+--------------+
    | id          | int(11)      | PRIMARY KEY AUTO_INCREMENT
    | nameFirst   | varchar(255) | *„Åì„ÅÆÂêçÂâç„Å´Ê≥®ÊÑè
    | nameLast    | varchar(255) |
    +-------------+--------------+

- KEY: orm.entity.recursive
  EXPLAIN: Èö£Êé•„É™„Çπ„Éà(Ëá™Â∑±Â∑°ÂõûÂèÇÁÖß)
  BODY: |
    @Entity()
    export class Category {
      @PrimaryGeneratedColumn()
      id: number

      @ManyToOne((type) => Category, (category) => category.children)
      parent: Category

      @OneToMany((type) => Category, (category) => category.parent)
      children: Category[]
    }

- KEY: orm.entity.tree
  EXPLAIN: TreeÊßãÈÄ†
  BODY: |
    @Entity()
    @Tree("nested-set")
    export class Category {
      @PrimaryGeneratedColumn()
      id: number

      @TreeChildren()
      children: Category[]

      @TreeParent()
      parent: Category

      @TreeLevelColumn()
      level: number
    }

- KEY: orm.entity.type.primary
  EXPLAIN: Entity Primary
  BODY: |
    @PrimaryGeneratedColumn({ comment: 'ID' })    // „Ç∑„Éº„Ç±„É≥„ÇπPKËá™ÂãïÁîüÊàê(ÊåøÂÖ•ÊôÇ)
    id: number;

    @PrimaryGeneratedColumn("uuid")               // HEX„Å´„Çà„ÇãUUIDËá™ÂãïÊåøÂÖ•
    id: string

    @PrimaryColumn({
      type: 'varchar',
      length: 50,
      comment: 'ID'
    })
    id: string;

- KEY: orm.entity.type.auto
  EXPLAIN: Entity Ëá™ÂãïÊõ¥Êñ∞
  BODY: |
    @CreateDateColumn()                           // Êó•‰ªòËá™ÂãïÁîüÊàê(ÊåøÂÖ•ÊôÇ)
    created_at: Date;

    @UpdateDateColumn()                           // Êó•‰ªòËá™ÂãïÁîüÊàê(ÊåøÂÖ•ÊôÇ„ÉªÊõ¥Êñ∞ÊôÇ)
    updated_at: Date;

    @DeleteDateColumn()                           // Êó•‰ªòËá™ÂãïÁîüÊàê(soft-deleteÊôÇ)
    updated_at: Date;

    @VersionColumn()                              // EntityVersionË®òÈå≤
    entity_version: number;

- KEY: orm.entity.type.index
  EXPLAIN: Entity Index
  BODY: |
    ‚ñ† Âçò‰∏Äindex
    @Index()                                      // Ê§úÁ¥¢DBIndex‰ΩúÊàê
    @Column()
    name: string;

    ‚ñ† Ë§áÂêàindex(Not Unique)
    @Entity()
    @Index(["firstName","lastName"])              // Default: Unique:false
    export class User {
        @PrimaryGeneratedColumn()
        id: number
        
        @Column()
        firstName: string
        
        @Column()
        lastName: string
        ...
    }

    ‚ñ† Ë§áÂêàindex(Unique)
    @Entity()
    @Index(
      ["firstName","middleName","lastName"],
      { unique:true }                             // Unique ÊåáÂÆö
    )
    export class User {
        @PrimaryGeneratedColumn()
        id: number
        
        @Column()
        firstName: string
        
        @Column()
        middleName: string
        
        @Column()
        lastName: string
        ...
    }

    ‚ñ† Ë§áÂêàindex: ÈùûLockÁîüÊàê(Postgres)
    @Index(
      ["firstName", "middleName"],
      { concurrent: true }                        // ÈùûLockÁîüÊàê
    )

#-------------------------------
# Entity: Column Type
#-------------------------------

- KEY: orm.entity.column.types
  EXPLAIN: „Ç´„É©„É†„Çø„Ç§„Éó
  BODY: |
    ‚ñ† Êï∞ÂÄ§
    bit, int, integer, tinyint, smallint, mediumint,
    bigint, float, double, double precision, dec, 
    decimal, numeric, fixed, 
    ‚ñ† Boolean
    bool, boolean, 
    ‚ñ† Êó•‰ªò
    date, datetime, timestamp, time, year, 
    ‚ñ† ÊñáÂ≠ó
    char, nchar, national char,
    ‚ñ† ÊñáÂ≠óÂàó(var)
    varchar, nvarchar, national varchar,
    ‚ñ† ÊñáÂ≠óÂàó(text)
    text, tinytext, mediumtext, longtext,
    ‚ñ† ÊñáÂ≠óÂàó(string)
    linestring, multilinestring,
    ‚ñ† Blob
    blob, tinyblob, mediumblob, longblob, 
    ‚ñ† id
    uuid,
    ‚ñ† binary
    binary, varbinary, 
    ‚ñ† ‰ªñ
    enum, set, json, geometry, point, polygon,
    multipoint, multipolygon, geometrycollection, 
    inet4, inet6

- KEY: orm.column.type.options
  EXPLAIN: „Ç´„É©„É†Options
  BODY: |
    name:          string,                        // DB„ÅÆ„Ç´„É©„É†Âêç(‰∏äÊõ∏„ÅçÂÑ™ÂÖà)
    primary:       boolean,                       // =@PrimaryColumn
    unique:        boolean,                       // uniqueË®≠ÂÆö
    default:       Type,                          // defaultÂÄ§
    nullable:      boolean,                       // nullË®±ÂÆπ(default: false)
    update:        boolean,                       // save()„ÅßUDPATEÊôÇ‰ΩøÁî®(default: true)
    insert:        boolean,                       // INSERTÊôÇ‰ΩøÁî®(default: true)
    select:        boolean,                       // SELECTÊôÇ‰ΩøÁî®(default: true)
    onUpdate:      string,                        // update„ÅÆTriggerË®òËø∞(Áî®Ê≥ï‰∏çÊòé)
    comment:       string,                        // „Éï„É™„Éº„Ç≥„É°„É≥„Éà
    asExpression:  string,                        // „Ç´„É©„É†Expression(MYSQL)?

    //ÊñáÂ≠ó
    length:        number,                        // ÊñáÂ≠óÂàóÈï∑(ÊñáÂ≠óÂàóÈñ¢ÈÄ£„ÅÆ„ÅøÊúâÂäπ)
    charset:       string,                        // ÊñáÂ≠ó„Çª„ÉÉ„Éà(utf8mb4„Å™„Å©)
    collation:     string,                        // Collation(utf8mb4_0900_ai_ci„Å™„Å©)

    //Êï∞
    width:         number,                        // Ë°®Á§∫ÂπÖ
    precision:     number,                        // (decimal„Ç´„É©„É†Â∞èÊï∞ÁÇπ)
    scale:         number,                        // (decimal„Ç´„É©„É†Â∞èÊï∞ÁÇπÊ°ÅÊï∞)
    zerofill:      boolean,                       // (MYSQL:unsigned)
    unsigned:      boolean,                       // (MYSQL)

    //Âûã
    enum:          string[]|anyEnum,              // type:"enum"„Åß‰ΩøÁî®„Åï„Çå„ÇãÂûãÈÖçÂàó
    enumName:      string,                        // "enum"Âêç
    generatedType: "VIRTUAL"|"STORED",            // @Generated(MYSQL)
    hstoreType:    "object"|"string",             // HSTORE (Postgres)
    array:         boolean,                       // cockroachdb (Postgres)

    transformer: {
      from(value:DBType): EntityType,
      to(value:EntityType): DBType
    }

- KEY: orm.column.type.format
  EXPLAIN: „Ç´„É©„É†Êõ∏Âºè
  BODY: |
    @Column('varchar')
    name: string;

    @Column('varchar', { comment:'ÂêçÂâç' })
    name: string;

    @Column({ type:'varchar', length:255, comment:'ÂêçÂâç' })
    name: string;

- KEY: orm.column.type.enum
  EXPLAIN: „Ç´„É©„É†Êõ∏Âºè(enum)
  BODY: |
    export enum Key { A="a", B="b", C="c" }

    @Column({ type: "enum", enum: Key, default: Key.A })
    key: Key

    export const Keys = ["a","b","c"] as const
    export type Key = typeof Keys[number]

    @Column({ type: "enum", enum: Keys, default: "a"})
    key: Key

- KEY: orm.column.type.set
  EXPLAIN: „Ç´„É©„É†Êõ∏Âºè(set)
  BODY: |
    export const Keys = ["a","b","c"] as const
    export type Key = typeof Keys[number]

    @Column({ type: "set", enum: ["a","b","c"], default: ["a","b"]})
    keys: Key[]

- KEY: orm.column.type.array
  EXPLAIN: „Ç´„É©„É†Êõ∏Âºè(ÂçòÁ¥îÈÖçÂàó)
  BODY: |
    export Class Keys{
      @Column("simple-array")
      names: string[]
    }

    const keys = new Keys()
    keys.names = ["A", "B", "C", "D"]

- KEY: orm.column.type.object
  EXPLAIN: „Ç´„É©„É†Êõ∏Âºè(ÂçòÁ¥î„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà)
  BODY: |
    export Class Key{
      @Column("simple-json")
      info: { name:string, age:number }
    }

    const key = new Key()
    key.info = { name:"A", age:7 }

- KEY: orm.column.type.generatedId
  EXPLAIN: Ëá™ÂãïÁîüÊàêId
  BODY: |
    @Column()
    @Generated("uuid")
    uuid: string

#-------------------------------
# View
#-------------------------------

- KEY: orm.view.sql
  EXPLAIN: View Entity by SQL
  BODY: |
    //SQL„Å´„Çà„ÇãVIEWÁîüÊàê
    @ViewEntity({
      expression: `
        SELECT post.id AS id, post.name AS name, category.name AS categoryName
        FROM post
        LEFT JOIN category ON post.categoryId = category.id
      `
    })
    export class PostCategory {
      @ViewColumn()
      id: number

      @Index()                                    // Âçò‰∏Ä„Ç´„É©„É†INDEX
      @Index("name-idx", { unique: true })        // (INDEXÂêç„ÄÅ„Ç™„Éó„Ç∑„Éß„É≥)
      @ViewColumn({ name: "postName", ... })
      name: string

      @ViewColumn()
      categoryName: string
    }

    const postCategories = await dataSource.manager.find(PostCategory)
    const postCategory = await dataSource.manager.findOneBy(PostCategory, { id: 1 })

- KEY: orm.view.qb
  EXPLAIN: View Entity by QB
  BODY: |
    //QueryBuilder„Å´„Çà„ÇãVIEWÁîüÊàê
    @ViewEntity({
      materialized: true,                         // PostgreSQL„Ç™„Éó„Ç∑„Éß„É≥
      expression: (dataSource: DataSource) => dataSource
        .createQueryBuilder()
        .select("post.id", "id")
        .addSelect("post.name", "name")
        .addSelect("category.name", "categoryName")
        .from(Post, "post")
        .leftJoin(Category, "category", "category.id = post.categoryId")
        //„Éë„É©„É°„Çø„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞
        [X].where("category.name = :name", { name: "Cars" })
        //„É™„ÉÜ„É©„É´
        [O].where("category.name = 'Cars'")
    })
    export class PostCategory {
      @ViewColumn()
      id: number

      @Index()                                    // Âçò‰∏Ä„Ç´„É©„É†INDEX
      @Index("name-idx", { unique: true })        // (INDEXÂêç„ÄÅ„Ç™„Éó„Ç∑„Éß„É≥)
      @ViewColumn({ name: "postName", ... })
      name: string

      @ViewColumn()
      categoryName: string
    }

    const postCategories = await dataSource.manager.find(PostCategory)
    const postCategory = await dataSource.manager.findOneBy(PostCategory, { id: 1 })

#-------------------------------
# Entity Relation
#-------------------------------

- KEY: orm.relation.cascade
  EXPLAIN: Entity Cascade
  BODY: |
    @Entity()
    export class B {
      ...
      @ManyToMany((type) => A, (a) => a.b, 
        { cascade: true },                        // options:true,
                                                  // ["insert"],["update"],["insert","update"]
      )
      @JoinTable()                                // @ManyToMany„Åß‰ΩøÁî®
      a: A[]

      @ManyToOne(type => A)
      @JoinColumn({ name: "a_id" })               // @ManyToOne„Åß‰ΩøÁî®
      a: A;

      @JoinColumn([                               // Ë§áÊï∞„ÅÆÂ†¥Âêà
        { name: "category_id", referencedColumnName: "id" },
        { name: "locale_id", referencedColumnName: "locale_id" }
      ])
    }

- KEY: orm.relation.oneToOne
  EXPLAIN: EntityÈñ¢‰øÇ OneToOne
  BODY: |
    @Entity("user")
    export class User {
      @PrimaryColumn({ type: 'varchar', length: 50, })
      user_id: string;

      @OneToOne(() => Setting, (setting) => setting.user)
      setting?: Setting;                          // „Ç≥„Éç„ÇØ„Çø(ÂÆüÈöõ„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´„Å™„ÅÑ)
    }

    @Entity("setting")
    export class Setting {
      @PrimaryColumn({ type:'varchar', name:'setting_id', length:50 })
      setting_id: string;                         // PK„Åß„ÅÇ„ÇäFK

      @OneToOne(() => User, (user) => user.setting)
      @JoinColumn({ name: 'setting_id' })         // ‰∏ÄÊñπ„ÅÆ„Åø„Åß„ÅÆË®≠ÂÆö
      readonly user?: User;                       // „Ç≥„Éç„ÇØ„Çø(ÂÆüÈöõ„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´„Å™„ÅÑ)
    }

- KEY: orm.relation.oneToMany
  EXPLAIN: EntityÈñ¢‰øÇ OneToMany
  BODY: |
    ‚ñ† User(Many)
    @Entity("user")
    export class User {
      @PrimaryColumn({ type: 'varchar', length: 50, })
      user_id: string;

      @Column({ type: 'int' })
      city_id?: number;

      @ManyToOne(() => City, (city) => city.users, migrationOption)
      @JoinColumn({ name: 'city_id', referencedColumnName: 'user_id' })
      readonly city: City;                        // „Ç≥„Éç„ÇØ„Çø(ÂÆüÈöõ„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´„Å™„ÅÑ)
    }

    ‚ñ† City(One)
    @Entity("city")
    export class City {
      @PrimaryGeneratedColumn({ type: 'int' })
      readonly city_id: number;

      @OneToMany(() => User, (user) => user.city, migrationOption)
      readonly users?: User[];                    // „Ç≥„Éç„ÇØ„Çø(ÂÆüÈöõ„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´„Å™„ÅÑ)
    }

    ‚ñ† Migration Options
    migrationOption: {
      createForeignKeyConstraints: false,
      persistence: false
    })

- KEY: orm.relation.manyToMany
  EXPLAIN: EntityÈñ¢‰øÇ ManyToMany
  BODY: |
    ‚ñ† User(many)
    @Entity("user")
    export class User {
      @PrimaryColumn({ type: 'varchar', length: 50, })
      user_id: string;

      @Column({ type: 'int' })
      offer_id?: number;

      @ManyToMany(() => Offer)
      @JoinTable({
        name: 'offer',
        joinColumn: {
          name: 'users_id',
          referencedColumnName: 'offer_id'
        },
        inverseJoinColumn: {
          name: 'offer_id',
          referencedColumnName: 'user_id'
        },
      })
      readonly offers?: Offer[];                  // „Ç≥„Éç„ÇØ„Çø(ÂÆüÈöõ„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´„Å™„ÅÑ)
    }

    ‚ñ† Offer(many)
    @Entity("offer")
    export class Offer {
      @PrimaryColumn({ type: 'int' })
      offer_id: number;

      @OneToMany(() => User, (user) => user.offers, migrationOption)
      readonly users?: User[];                    // „Ç≥„Éç„ÇØ„Çø(ÂÆüÈöõ„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´„Å™„ÅÑ)
    }

    ‚ñ† Migration Options
    migrationOption: {
      createForeignKeyConstraints: false,
      persistence: false
    })

- KEY: orm.manager.vs.repository
  EXPLAIN: Manager Repository ÊØîËºÉ
  BODY: |
    ‚ñ† Manager
    const myDataSource = new DataSource(/*...*/)
    const manager = myDataSource.manager
    const user = await manager.findOneBy(User, { id: 1 })
    user.name = "john"
    await myDataSource.manager.save(user)

    ‚ñ† Repository
    const userRepository = dataSource.getRepository(User)
    const user = await userRepository.findOneBy({ id: 1 })
    user.name = "john"
    await userRepository.save(user)

- KEY: orm.manager
  EXPLAIN: üîµManager
  BODY: |
    ‚ñ† SQL
    const rawData = await manager.query(`SELECT * FROM USERS`)

    ‚ñ† Transaction
    await manager.transaction(async (manager) => { ... })

    ‚ñ† ID
    const userId = manager.getId(user)

    ‚ñ† Create
    const user = manager.create(User)
    const user = manager.create(User, { id:1, name: "John" })

    ‚ñ† Merge
    const user = new User()
    manager.merge(User, user, { name: "John" }, { city: "Tokyo" })

    ‚ñ† Preload
    const partialUser = { id: 1, name: "John" }
    const user = await manager.preload(User, partialUser)

    ‚ñ† Save
    await manager.save(user)                      // Insert or Update
    await manager.save([category1, category2])    // Insert or Update Ë§áÊï∞

    ‚ñ† Insert
    await manager.insert(User, { name:"John" })   // Insert 
    await manager.insert(User, [                  // Insert Ë§áÊï∞
      { name:"John" }, { name:"Karen" }
    ])

    ‚ñ† Update
    await manager.update(
      User,                                       // Entity
      { age: 18 },                                // Where
      { category: "A" }                           // Set
    )
    // =UPDATE user SET category='A' WHERE age=18

    await manager.update(
      User,                                       // Entity
      1,                                          // Where(id=)
      { name: "John" }                            // Set
    )
    // =UPDATE user SET name='John' WHERE id=1

    ‚ñ† Upsert
    await manager.upsert(
      User,                                       // Entity
      [{id:1,name:"John"},{id:2,name:"Karen"}],   // Set
      ["id"]                                      // ÈáçË§áCheckÂØæË±°
    )
    // =INSERT INTO user VALUES (id=1, name='John'), (id=2, name='Karen')
    //  ON CONFLICT(id) DO UPDATE name = EXCLUDED.name

    ‚ñ† Delete/Remove
    await manager.delete(User, 1)                 // Delete By Id
    await manager.delete(User, [1, 2, 3])         // Transactional
    await manager.delete(User, { name: "John" })  // Êù°‰ª∂

    const removedUser = await manager.remove(user) // ÂâäÈô§ and return entity
    const removedUser = await manager.remove([category1, category2])  // Transactional

    ‚ñ† Clear/Release
    await manager.clear(User)                     // „ÉÜ„Éº„Éñ„É´„Éá„Éº„ÇøÂÖ®ÂâäÈô§
    await manager.release()                       // „Ç´„Çπ„Çø„É†RepogitoryËß£Êîæ

    ‚ñ† inc/dec
    await manager.increment/decrement(
      User,                                       // Entity
      { name: "John" },                           // Where
      "age",                                      // Â§âÊõ¥ÂØæË±°„Ç´„É©„É†
      3                                           // Â§âÊõ¥Êï∞
    )

    ‚ñ† Exists
    const exists:boolean = await manager.exists(
      User,                                       // Entity
      { where: { name: "John" } }                 // Where
    )
    const exists:boolean = await manager.existsBy(
      User,                                       // Entity
      { name: "John" }                            // Where
    )

    ‚ñ† find
    const user = await manager.find(
      User,                                       // Entity
      { where: {  name: "John" } }                // Where
    )
    const user = await manager.findBy(
      User,                                       // Entity
      { name: "John" }                            // Where
    )
    const user = await manager.findOne(
      User,                                       // Entity
      { where: { name: "John" } }                 // Where
    )
    const user = await manager.findOneBy(
      User,                                       // Entity
      { name: "John" }                            // Where
    )
    const user = await manager.findOneOrFail(
      User,                                       // Entity
      { where: { name: "John" } }                 // Where
    )

    ‚ñ† Count
    const count = await manager.count(
      User,                                       // Entity
      { where:{ name:"John" } }                   // Where
    )
    const count = await manager.countBy(
      User,                                       // Entity
      { name: "John" }                            // Where
    )
    const [user, userCount] = await manager.findAndCount(
      User,                                       // Entity
      {where:{ name:"John" }}                     // Where
    )
    const [user, userCount] = await manager.findAndCountBy(
      User,                                       // Entity
      { name: "John" }                            // Where
    )

- KEY: orm.repository
  EXPLAIN: üîµRepository
  BODY: |
    ‚ñ† Find
    const Tims = await repository.find({ where: { name: "Tim" }})
    const Tims = await repository.findBy({ name: "Tim" })

    const Tim = await repository.findOne({ where: { name: "Tim" }})
    const Tim = await repository.findOneBy({ name: "Tim" })
    const Tim = await repository.findOneOrFail({ where: { name: "Tim" }})
    const Tim = await repository.findOneByOrFail({ name: "Tim" })

    ‚ñ† Query
    const rawData = await repository.query(`SELECT * FROM USERS`)

    ‚ñ† Transaction
    await connection.transaction(async (manager) => {
        const userRepository = manager.withRepository(UserRepository)
        await userRepository.createAndSave("Tim")
        const Tim = await userRepository.findByName("Tim")
    })

    ‚ñ† Exists
    const exists = await repository.exists({ where: { name: "Tim" }})
    const exists = await repository.existsBy({ name: "Tim" })

    ‚ñ† Count
    const count = await repository.count({ where: { name: "Tim" }})
    const count = await repository.countBy({ name: "Tim" })

    ‚ñ† Find & Count
    const [user, userCount] = await repository.findAndCount({ where: { name:"Tim" }})
    const [user, userCount] = await repository.findAndCountBy({ name: "Tim" })

    ‚ñ† ID
    if (repository.hasId(user)) { ... }
    const userId = repository.getId(user)

    ‚ñ† Create & Clear
    const user = repository.create()              // =new User()
    const user = repository.create({ id: 1, name: "John" })

    await repository.clear()

    ‚ñ† Merge(„Ç´„É©„É†ÂÄ§ËøΩÂä†)
    const user = new User()
    repository.merge(user, { name:"John" }, { city:"Tokyo" })

    ‚ñ† Preload
    const partialUser = { id: 1, name:"John" }
    const user = await repository.preload(partialUser)  // ÂèñÂæó„Å®‰∏äÊõ∏„Åç

    ‚ñ† Save
    await repository.save(user)
    await repository.save([category1, category2])

    ‚ñ† Insert
    await repository.insert({ name: "Tim" })
    await repository.insert([                     // Ë§áÊï∞ÈÖçÂàó
      { name: "Tim" },{ name: "John" }
    ])

    ‚ñ† Update
    await repository.update(
      { age: 18 },                                // where
      { category: "A" }                           // set
    )
    // =UPDATE user SET category='A' WHERE age=18

    await repository.update(
      1,                                          // ID
      { name: "John" }                            // set
    )
    // =UPDATE user SET name = 'John' WHERE id = 1

    ‚ñ† Upsert
    await repository.upsert(
      [{ id:12, name:"John" },{ id:13, name:"Tim" }],
      ["id"]                                      // ÈáçË§áCheck„Ç´„É©„É†
    )
    // =INSERT INTO user VALUES (id=12, name='John'),(id=13, name='Tim')
    //   ON CONFLICT(id) DO UPDATE name=EXCLUDED.name

    ‚ñ† Remove/Delete/Restore
    await repository.remove(user)
    await repository.remove([category1, category2])

    await repository.delete(1)                    // by ID
    await repository.delete([1, 2, 3])            // by Ë§áÊï∞ID
    await repository.delete({ name: "Tim" })      // Êù°‰ª∂

    ‚ñ† Soft Delete & Restore
    await repository.softDelete(1)
    await repository.restore(1)

    ‚ñ† Soft Remove & Recover
    const entities = await repository.find({...})
    const entities = await repository.softRemove(entities)
    await repository.recover(entitiesAfterSoftRemove)

    await repository.increment({ name: "Tim" }, "age", 3)
    await repository.decrement({ name: "Tim" }, "age", 3)

    ‚ñ† Êï∞Â≠¶Methods
    const sum = await repository.sum("age", { name: "Tim" })
    const ave = await repository.average("age", { name: "Tim" })
    const min = await repository.minimum("age", { name: "Tim" })
    const max = await repository.maximum("age", { name: "Tim" })

    ‚ñ† Manager„Å™„Å©ÂèñÂæó
    const manager = repository.manager
    const metadata = repository.metadata
    const queryRunner = repository.queryRunner
    const target = repository.target              // Target Entity

    ‚ñ† RepositoryÊã°Âºµ
    export const UserRepository = dataSource.getRepository(User).extend({
        findByName(name: string) {
            return this.createQueryBuilder("user")
                .where("user.name = :name", { name }).getMany()
        },
    })

    export class UserController {
        users() { return UserRepository.findByName("Tim") }
    }

    ‚ñ† QueryBuilder‰ΩøÁî®
    const users = await repository
        .createQueryBuilder("user")
        .where("user.name = :name", { name: "John" })
        .getMany()

- KEY: orm.repository.options
  EXPLAIN: Repository SQL
  BODY: |
    repository.find({ OPTIONS })

    ‚ñ† SELECT
    select: { name: true, address: true },
    // =SELECT "name", "address" FROM "user"

    ‚ñ† WHERE(AND)
    where: { name: "A", address: "B" },
    // =SELECT * FROM "user" WHERE "name"='A' AND "address"='B'

    ‚ñ† WHERE(OR)
    where: [{ name: "A", address: "B" }, { name: "C", address: "D" }],
    // =WHERE ("name" = 'A' AND "address" = 'B')
    //     OR ("name" = 'C' AND "address" = 'D')

    ‚ñ† LEFT JOIN
    relations: { profile: true, photos: true },
    // =SELECT * FROM "user"
    //  LEFT JOIN "profile" ON "profile"."id" = "user"."profileId"
    //  LEFT JOIN "photos" ON "photos"."id" = "user"."photoId"

    relations: { profile: true, videos: { videoAttr: true }},
    // =SELECT * FROM "user"
    //  LEFT JOIN "profile" ON "profile"."id" = "user"."profileId"
    //  LEFT JOIN "videos" ON "videos"."id" = "user"."videoId"
    //  LEFT JOIN "video_attr" ON "video_attrs"."id" = "videos"."video_attrId"

    ‚ñ† LEFT JOIN AND WHERE
    relations: { project: true },
    where: { project: { name: "A", address: "B" } }
    // =SELECT * FROM "user"
    //  LEFT JOIN "project" ON "project"."id" = "user"."projectId"
    //  WHERE "project"."name" = 'A' AND "project"."address" = 'B'

    ‚ñ† ORDER
    order: { name: "ASC", id: "DESC" },
    // =ORDER BY "name" ASC, "id" DESC

    ‚ñ† OFFSET,LIMIT
    skip: 5, take: 10,                            // ÂêåÊôÇ‰ΩøÁî®„Åô„Åπ„Åó
    // =OFFSET 5 LIMIT 10

    ‚ñ† SOFT DELETED
    withDeleted: true,                            // softDelete or softRemove

    ‚ñ† CACHE
    cache: true,
    cache: { duration: 60000 },                   // dataSource(1ÂàÜ)
    cache: { id: "users_id", milliseconds: 25000 },
    await dataSource.queryResultCache.remove(["users_id"]) // „Ç≠„É£„ÉÉ„Ç∑„É•ÊâãÂãïÂâäÈô§

    ‚ñ† LOCK
    lock: { mode: "optimistic", version: 1 },

- KEY: orm.where.condition
  EXPLAIN: „Ç´„É©„É†Êù°‰ª∂
  BODY: |
    ‚ñ† ÊñáÂ≠óÂàó
    Not("A")                                      // WHERE NOT(COLUMN = 'A')
    IsNull(),                                     // WHERE COLUMN IS NULL
    Like("%out%"),                                // WHERE COLUMN LIKE '%out%'
    ILike("%out%"),                               // WHERE COLUMN ILIKE '%out%'
    In(["A", "B"]),                               // WHERE COLUMN IN ('A','B')
    Any(["A", "B"]),                              // WHERE COLUMN Any ('A','B')

    ‚ñ† ÊñáÂ≠óÂàóÈÖçÂàó
    ArrayContains(["A"]),                         // WHERE COLUMN @> '{A}'
    ArrayContainedBy(["A"]),                      // WHERE COLUMN <@ '{A}'
    ArrayOverlap(["A"]),                          // WHERE COLUMN && '{A}'

    ‚ñ† Êï∞ÂÄ§
    Equal(7)                                      // WHERE COLUMN = 7
    LessThan(7)                                   // WHERE COLUMN < 7
    LessThanOrEqual(7)                            // WHERE COLUMN <=7
    MoreThan(7)                                   // WHERE COLUMN > 7
    MoreThanOrEqual(7)                            // WHERE COLUMN >=7
    Between(1, 10)                                // WHERE COLUMN BETWEEN 1 AND 10

    ‚ñ† ROW(SQLÁõ¥Êõ∏„Åç)
    Raw("COLUMN - 4"),                            // WHERE COLUMN1 = COLUMN2 - 4
    Raw((a) => `${a} > NOW()`),                   // WHERE COLUMN > NOW()
    Raw((a) => `${a} > :date`,{date:"2020-10-06"}), // WHERE COLUMN > '2020-10-06'
    Raw((a) => `${a} IN (:...x)`, {x:["A","B"]}), // WHERE COLUMN IN ('A','B')

    ‚ñ† OR, AND
    Or(Equal("A"), ILike("B%")),                  // WHERE COLUMN='A' OR COLUMN ILIKE 'B%'
    And(Not(Equal("A")), ILike("B%"))             // WHERE NOT(COLUMN='A') OR COLUMN ILIKE 'B%'

- KEY: orm.qb.3types
  EXPLAIN: Query Builder 3Á®ÆÈ°û
  BODY: |
    ‚ñ† 1.DataSource
    const user = await dataSource
      .createQueryBuilder()
      .select("user")
      .from(User, "user")
      .where("user.id = :id", { id: 1 })
      .getOne()

    ‚ñ† 2.Entity Manager
    const user = await dataSource
      .manager
      .createQueryBuilder(User, "user")           // =SELECT * FROM
      .where("user.id = :id", { id: 1 })
      .getOne()

    ‚ñ† 3.Repository
    const user = await dataSource
      .getRepository(User)
      .createQueryBuilder("user")                 // =SELECT * FROM
      .where("user.id = :id", { id: 1 })
      .getOne()

- KEY: orm.qb.5sql
  EXPLAIN: Query Builder 5 SQLs
  BODY: |
    ‚ñ† SELECT
    const user = await dataSource.createQueryBuilder()
      .select("user")
      .from(User, "user")
      .where("user.id = :id", { id: 1 })
      .getOne()

    ‚ñ† INSERT
    await dataSource.createQueryBuilder()
      .insert()
      .into(User)
      .values([{ name:"A" },{ name:"B" }])
      .execute()

    ‚ñ† UPDATE
    await dataSource.createQueryBuilder()
      .update(User)
      .set({ name:"A" })
      .where("id = :id", { id: 1 })
      .execute()

    ‚ñ† DELETE
    await dataSource.createQueryBuilder()
      .delete()
      .from(User)
      .where("id = :id", { id: 1 })
      .execute()

    ‚ñ† RELATION
    await dataSource.createQueryBuilder()
      .relation(User,"photos")
      .of(id)
      .loadMany();

- KEY: orm.qb.select
  EXPLAIN: QB:SELECTÁØÄ
  BODY: |
    ‚ñ† 1. Entities
    const timber = await dataSource.createQueryBuilder("user")
    .where(...)
    .getOne()                                     // ÂçòÁã¨

    const timber = await dataSource.createQueryBuilder("user")
    .where(...)
    .getOneOrFail()                               // EntityNotFoundError

    const timber = await dataSource.createQueryBuilder("user")
    .where(...)
    .getMany()                                    // ÈÖçÂàó

    ‚ñ† 2. Raw Results
    // createQueryBuilder(Âûã)„Å´„Å™„ÅÑÊàª„ÇäÂÄ§„ÇíËøî„Åô
    const { sum } = await dataSource.createQueryBuilder("user")
      .select("SUM(user.count)", "sum")
      .where(...)
      .getRawOne()                                // ÂçòÁã¨

    const photosSums = await dataSource.createQueryBuilder("user")
      .select("user.id")
      .addSelect("SUM(user.count)", "sum")
      .groupBy("user.id")
      .getRawMany()                               // ÈÖçÂàó

    ‚ñ† Count
    const count = await dataSource.createQueryBuilder("user")
      .where(...)
      .getCount()

    ‚ñ† Alias
    createQueryBuilder("user")
    = createQueryBuilder()
      .select("user")
      .from(User, "user")

    ‚ñ† Distinct
    createQueryBuilder("user")
      .distinctOn(["user.id"])

- KEY: orm.qb.where
  EXPLAIN: QB:SELECT WHEREÁØÄ
  BODY: |
    ‚ñ† ÂºïÊï∞Âá¶ÁêÜ
    .where("user.name = :name", { name: "Tim" })
    .where("user.name = :name").setParameter("name", "Tim")

    ‚ñ† ÈÖçÂàóÂºïÊï∞Âá¶ÁêÜ
    .where("user.name IN (:...names)", { names: [ "A","B","C" ] })
      = WHERE user.name IN ('A','B','C')

    ‚ñ† ANDÂá¶ÁêÜ
    .where("user.name = :name", { name: "Tim" })
    .andWhere("user.age = :age", { age: 20 })

    ‚ñ† ÂèçÂæ©Âá¶ÁêÜ: ÂÖàÈ†≠„ÅÆorWhere„ÇíÈÅ©ÂÆúÂá¶ÁêÜ
    .andWhere(
      new Brackets/NotBrackets((qb) => {          // Brackets or NotBrackets
        array.forEach((item, index) => {
          qb.orWhere(
            `user.name = :name${index}`,          // ÂèçÂæ©Âá¶ÁêÜÂØæÁ≠ñ
            { [`name${index}`]: item }
          )
        })
      }),
    )

    ‚ñ† ‚õîÂºïÊï∞ÂêçÈáçË§á
    .where('user.linkedGroup = :id', { id: groupId })
    .andWhere('user.linkedSet = :id', { id: setId });

    .where("user.name = :name", { name: "Tim" })
    .orWhere("user.name = :name", { name: "Jim" })

    ‚ñ† ‚õîÂºïÊï∞ÂêçÈáçË§á
    .andWhere(
      new Brackets/NotBrackets((qb) => {
        qb.where("user.name = :name", { name: "Tim" })
          .orWhere("user.name = :name", { name: "Jim" })
      }),
    )

- KEY: orm.qb.orderby
  EXPLAIN: QB:SELECT ORDERBYÁØÄ
  BODY: |
    ‚ñ† ÂçòÊï∞„ÇΩ„Éº„Éà„Ç≠„Éº
    .orderBy("user.id")
    .orderBy("user.id", "DESC"/"ASC")

    ‚ñ† Ë§áÊï∞„ÇΩ„Éº„Éà„Ç≠„Éº
    .orderBy("user.name").addOrderBy("user.id")
    .orderBy({ "user.name": "ASC", "user.id": "DESC" })

- KEY: orm.qb.groupby
  EXPLAIN: QB:SELECT GROUPBYÁØÄ
  BODY: |
    ‚ñ† ÂçòÊï∞„Ç≠„Éº
    .groupBy("user.id")
      = SELECT ... FROM users user GROUP BY user.id

    ‚ñ† Ë§áÊï∞„Ç≠„Éº
    .groupBy("user.name").addGroupBy("user.id")

- KEY: orm.qb.limitOffset
  EXPLAIN: QB:SELECT LIMITÁØÄ OFFSETÁØÄ
  BODY: |
    ‚ñ† Limit & Offset
    .limit(10).offset(10)

    ‚≠ïÊé®Â•®: Ë§áÈõë„Å™Query, Pagination„Å™„Å©
    ‚ñ† Take & Skip
    .take(10).skip(10)

- KEY: orm.qb.join
  EXPLAIN: QB:SELECT OUTER JOIN
  BODY: |
    ‚ñ† EntityÂÆöÁæ©
    @Entity()
    export class User {
      @PrimaryGeneratedColumn()
      id: number

      @Column()
      name: string

      @Column()
      act: boolean

      @OneToMany((type) => Photo, (photo) => photo.user)
      photos: Photo[]

    @Entity()
    export class Photo {
      @PrimaryGeneratedColumn()
      id: number

      @Column()
      url: string

      @Column()
      isOK: boolean

      @ManyToOne((type) => User, (user) => user.photos)
      user: User

    ‚ñ† Left Outer Join: JOINÂ§ñÈÉ®„Å´Êù°‰ª∂
    const user = await createQueryBuilder("user")
      .leftJoinAndSelect(
        "user.photos",                            // ConnectColumn
        "photo"                                   // TargetEntity
      )
      .where("user.act = :act, { act: true })
      .andWhere("photo.isOK = :isOK", { isOK:false })
      .getOne()

        SELECT user.*, photo.* FROM users user
        LEFT JOIN photos photo
        ON photo.user = user.id
        WHERE user.name = 'Timber' AND photo.isOK = FALSE

    ‚ñ† Left Outer Join: JOINÂÜÖÈÉ®„Å´Êù°‰ª∂
    const user = await createQueryBuilder("user")
      .leftJoinAndSelect(
        "user.photos",                            // ConnectColumn
        "photo",                                  // TargetEntity
        "photo.isOK= :isOK",                      // TargetÊù°‰ª∂
        { isOK:false }                            // Êù°‰ª∂Â§âÊï∞
      )
      .where("user.name = :name", { name: "Tim" })
      .getOne()

        SELECT user.*, photo.* FROM users user
        LEFT JOIN photos photo
        ON photo.user = user.id AND photo.isOK = FALSE
        WHERE user.name = 'Tim'

- KEY: orm.qb.join
  EXPLAIN: QB:SELECT INNER JOIN„ÄêWIP„Äë
  BODY: |
    ‚ñ† Inner Join
    const user = await createQueryBuilder("user")
      .innerJoin(
        "user.photos",
        "photo"
      )
      .where("user.name = :name", { name: "Tim" })
      .getOne()

- KEY: orm.qb.join
  EXPLAIN: QB:SELECT LEFT OUTER JOIN & MAP„ÄêWIP„Äë
  BODY: |
    ‚ñ† Join & Mapping
    export class User {
        ...
        profilePhoto: Photo
    }

    const user = await createQueryBuilder("user")
    .leftJoinAndMapOne/leftJoinAndMapMany(
      "user.profilePhoto",                        // ËøΩÂä†Â±ûÊÄß‰ªò‰∏é
      "user.photos",                              // ConnectColumn
      "photo",                                    // TargetEntity
      "photo.isForProfile = TRUE",                // Áµû„ÇäËæº„ÅøÊù°‰ª∂Â§âÊï∞
    )
    .where("user.name = :name", { name: "Tim" })
    .getOne/getMany()

- KEY: orm.qb.subQuery.where
  EXPLAIN: QB:SELECT SubQuery WHERE
  BODY: |
    ‚ñ† WHERE: Áõ¥Êõ∏„Åç‰∏ÄÊã¨„Éë„Çø„Éº„É≥
    const qb = await dataSource.getRepository(Post).createQueryBuilder("post")
    const posts = qb
      .where(
        "post.title IN " +
          qb.subQuery()
            .select("user.name")
            .from(User, "user")
            .where("user.ok = :ok")
            .getQuery(),
      )
      .setParameter("ok", true)
      .getMany()

    ‚ñ† WHERE: „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ‰∏ÄÊã¨„Éë„Çø„Éº„É≥
    const posts = await dataSource.getRepository(Post).createQueryBuilder("post")
      .where((qb) => {
        const subQuery = qb
          .subQuery()
          .select("user.name")
          .from(User, "user")
          .where("user.ok = :ok")
          .getQuery()
        return "post.title IN " + subQuery
      })
      .setParameter("ok", true)
      .getMany()

    ‚ñ† WHERE: ÂàÜÂâ≤„Éë„Çø„Éº„É≥
    const userQb = await dataSource.getRepository(User).createQueryBuilder("user")
        .select("user.name")
        .where("user.ok = :ok", { ok: true })

    const posts = await dataSource.getRepository(Post).createQueryBuilder("post")
        .where("post.title IN (" + userQb.getQuery() + ")")
        .setParameters(userQb.getParameters())
        .getMany()

- KEY: orm.qb.subQuery.from
  EXPLAIN: QB:SELECT SubQuery FROM
  BODY: |
    ‚ñ† FROM: „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ‰∏ÄÊã¨„Éë„Çø„Éº„É≥
    const posts = await dataSource.createQueryBuilder()
        .select("user.name", "name")
        .from((subQuery) => {
            return subQuery
              .select("user.name", "name")
              .from(User, "user")
              .where("user.ok = :ok", { ok: true })
        }, "user")
        .getRawMany()

    ‚ñ† FROM: ÂàÜÂâ≤„Éë„Çø„Éº„É≥
    const userQb = await dataSource.getRepository(User).createQueryBuilder("user")
        .select("user.name", "name")
        .where("user.ok = :ok", { ok: true })

    const posts = await dataSource.createQueryBuilder()
        .select("user.name", "name")
        .from("(" + userQb.getQuery() + ")", "user")
        .setParameters(userQb.getParameters())
        .getRawMany()

- KEY: orm.qb.subQuery.from
  EXPLAIN: QB:SELECT SubQuery SELECT
  BODY: |
    ‚ñ† SELECT: „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ‰∏ÄÊã¨„Éë„Çø„Éº„É≥
    const posts = await dataSource.createQueryBuilder()
        .select("post.id", "id")
        .addSelect((subQuery) => {
            return subQuery
              .select("user.name", "name")
              .from(User, "user")
              .limit(1)
        }, "name")
        .from(Post, "post")
        .getRawMany()

- KEY: orm.qb.getSql
  EXPLAIN: QB:SELECT SQLÂèñÂæó
  BODY: |
    const sql = createQueryBuilder("user")
      .where("user.name = :name", { name: "Tim" })
      .getSql()

    const users = await createQueryBuilder("user")
      .where("user.name = :name", { name: "Tim" })
      .printSql()
      .getMany()

- KEY: orm.qb.raw
  EXPLAIN: QB:SELECT RawÁµêÊûú„ÄêWIP„Äë
  BODY: |
    const { sum } = await dataSource.getRepository(User)
      .createQueryBuilder("user")
      .select("SUM(user.photosCount)", "sum")     // GroupBy „Åõ„Åö„Å´SUM()??
      .where("user.id = :id", { id: 1 })
      .getRawOne()

    const photosSums = await dataSource.getRepository(User)
      .createQueryBuilder("user")
      .select("user.id")
      .addSelect("SUM(user.photosCount)", "sum")
      .groupBy("user.id")
      .getRawMany()

- KEY: orm.qb.stream
  EXPLAIN: QB:SELECT Stream„ÄêWIP„Äë
  BODY: |
    const stream = await dataSource.getRepository(User)
      .createQueryBuilder("user")
      .where("user.id = :id", { id: 1 })
      .stream()

- KEY: orm.qb.lock
  EXPLAIN: QB:LOCK„ÄêWIP„Äë
  BODY: |
    const users = await dataSource.getRepository(User)
      .createQueryBuilder("user")
      .setLock("pessimistic_read")                Ëß£Ë™¨?
      .setLock("pessimistic_write")               Ëß£Ë™¨?
      .setLock("dirty_read")                      Ëß£Ë™¨?
      .setLock("optimistic", existUser.version)   Ëß£Ë™¨?
      .setOnLocked("nowait")                      Ëß£Ë™¨?
      .setOnLocked("skip_locked")                 Ëß£Ë™¨?
      .getMany()

- KEY: orm.qb.index
  EXPLAIN: QB:INDEXÊåáÂÆö
  BODY: |
    const users = await dataSource.getRepository(User)
      .createQueryBuilder("user")
      .useIndex("index_name")                     // Index‰ΩøÁî®ÊåáÁ§∫
      .getMany()

- KEY: orm.qb.executionTime
  EXPLAIN: QB:ÊúÄÂ§ßÂÆüË°åÊôÇÈñì
  BODY: |
    const users = await dataSource.getRepository(User)
      .createQueryBuilder("user")
      .maxExecutionTime(1000)                     // milliseconds
      .getMany()

- KEY: orm.qb.softDeleted
  EXPLAIN: QB:Ë´ñÁêÜÂâäÈô§„É¨„Ç≥„Éº„ÉâÂèñÂæó
  BODY: |
    const users = await dataSource.getRepository(User)
      .createQueryBuilder()
      .select("user.id", "id")
      .withDeleted()
      .getMany()

- KEY: orm.qb.debug
  EXPLAIN: QB:Debug(Query&ÂºïÊï∞)
  BODY: |
    const queryAndParams = await dataSource
      .getRepository(User)
      .createQueryBuilder("user")
      .where("user.id = :id", { id: 1 })
      .getQueryAndParameters()

- KEY: orm.qb.cte
  EXPLAIN: QB:Common Table Expression
  BODY: |
    ‚ñ† Áõ¥Êõ∏„Åç„Çπ„Çø„Ç§„É´
    const users = await connection.getRepository(User)
      .createQueryBuilder('user')
      .select("user.id", 'id')
      .addCommonTableExpression(`SELECT "userId" FROM "post"`, 'CTE')
      .where(`user.id IN (SELECT "userId" FROM 'CTE')`)
      .getMany();

    ‚ñ† ÂàÜÂâ≤„Çπ„Çø„Ç§„É´
    const insertQueryBuilder = connection.getRepository(User)
      .createQueryBuilder()
      .insert({ name: 'John Smith' })
      .returning(['id']);                         // „Ç≥„Éº„É´ÂÖà„Åß‰ΩøÁî®

    const users = await connection.getRepository(User)
      .createQueryBuilder('user')
      .addCommonTableExpression(insertQueryBuilder, 'CTE')
      .where(`user.id IN (SELECT "id" FROM 'CTE')`)
      .getMany();

- KEY: orm.qb.cache
  EXPLAIN: QB:Cache
  BODY: |
    Ë®≠ÂÆö: { 
      type: "mysql", host: "localhost", username: "test",
      ...
      cache: true,                                // ÂçòÁ¥îÊúâÂäπÂåñ
      cache: { duration: 30000 },                 // ÊôÇÈñìÊåáÂÆö(ms) 30s
      cache: {                                    // Ë©≥Á¥∞Ë®≠ÂÆö
        type: "database",
        tableName: "my-query-result-cache"        // CacheÊ†ºÁ¥ç„ÉÜ„Éº„Éñ„É´
      },
      cache: {                                    // Âà•„Éõ„Çπ„Éà„Åß„Ç≠„É£„ÉÉ„Ç∑„É•
        type: "redis",
        options: { 
          socket: { host: "localhost", port: 6379 }
        }
      },
    }

    const users = await dataSource
      .getRepository(User)
      .find({
        where: { isAdmin: true },
        cache: true,                              //Default 1000ms
        cache: 60000,                             //ÊôÇÈñìÊåáÂÆö(1ÂàÜ)
      })

    const users = await dataSource
      .createQueryBuilder(User, "user")
      .where("user.isAdmin = :isAdmin", { isAdmin: true })
      .cache(60000)                               // 1 min
      .getMany()

    ‚ñ† Cache ID

    const users = await dataSource
      .getRepository(User)
      .find({
        where: { isAdmin: true },
        cache: { id: "users_admins", milliseconds: 25000 },
      })

    const users = await dataSource
      .createQueryBuilder(User, "user")
      .where("user.isAdmin = :isAdmin", { isAdmin: true })
      .cache("users_admins", 25000)
      .getMany()

- KEY: orm.qb.insert
  EXPLAIN: QB:INSERT
  BODY: |
    await dataSource
      .createQueryBuilder()
      .insert()
      .into(User)
      .values([{ name: "Tim" },{ name: "Kei" }])
      .execute()

    ‚ñ† „Ç≥„Éº„É´„Éê„ÉÉ„ÇØÈñ¢Êï∞„Å´„Çà„ÇãÂãïÁöÑÂ§âÊõ¥
    await dataSource
      .createQueryBuilder()
      .insert()
      .into(User)
      .values({ name:"Tim", zip: ()=>"CONCAT('001','-','0012')" })
      .execute()

    ‚ñ† IDË°ùÁ™Å=>UPDATE                              // <postgres>Optional: skip
    await dataSource
      .createQueryBuilder()
      .insert()
      .into(User)
      .values({ name: "Timber", extId: "abc123" })
      .orUpdate(
        ["name"],                                 // UPDATE„Ç´„É©„É†
        ["extId"],                                // Êó¢Â≠òID
        { skipUpdateIfNoValuesChanged: true }     // ÂêåÂÄ§„Å™„ÇâSkip
      )
      .execute()

    ‚ñ† IDË°ùÁ™Å=>Ignore
    await dataSource
      .createQueryBuilder()
      .insert()
      .into(User)
      .values({ name:"Timber", extId:"abc123" })  
      .orIgnore()	                                // Error(mySQL) / Do Nothing(postgres)
      .execute()

- KEY: orm.qb.update
  EXPLAIN: QB:UPDATE
  BODY: |
    await dataSource
      .createQueryBuilder()
      .update(User)
      .set({ name: "Tim" })
      .where("id = :id", { id: 1 })
      .execute()

    ‚ñ† „Ç≥„Éº„É´„Éê„ÉÉ„ÇØÈñ¢Êï∞„Å´„Çà„ÇãÂãïÁöÑÂ§âÊõ¥
    await dataSource
      .createQueryBuilder()
      .update(User)
      .set({ name:"Tim", age: ()=>"age + 1" })
      .where("id = :id", { id:1 })
      .execute()

- KEY: orm.qb.delete
  EXPLAIN: QB:DELETE
  BODY: |
    await myDataSource
      .createQueryBuilder()
      .delete()
      .from(User)
      .where("id = :id", { id: 1 })
      .execute()

    ‚ñ† Soft Delete
    await myDataSource
      .getRepository(User)
      .createQueryBuilder()
      .softDelete()
      .where("id = :id", { id: 1 })
      .execute();

    ‚ñ† Soft Restore
    await myDataSource
      .getRepository(User)
      .createQueryBuilder()
      .restore()
      .where("id = :id", { id: 1 })
      .execute();

- KEY: orm.transaction
  EXPLAIN: TRANSACTION
  BODY: |
    await myDataSource
      .transaction(async (transactionalEntityManager) => {
        ...
      })

    await myDataSource.manager
      .transaction(
        "SERIALIZABLE",                           //Optional Isolation „É¨„Éô„É´
        async (manager) => {                      // transactionalEntityManager
          await manager.save(users)
          await manager.save(photos)
          ...
        }
      )

    ‚ñ† ÂÖ®‰Ωì„Éï„É≠„Éº(createQueryRunner)
    const queryRunner = dataSource.createQueryRunner()
    await queryRunner.connect()
    //SQL
    await queryRunner.query("SELECT * FROM users")
    //find()
    const users = await queryRunner.manager.find(User)

    await queryRunner.startTransaction()
    try {
      await queryRunner.manager.save(user)
      await queryRunner.manager.save(photos)
      await queryRunner.commitTransaction()
    } catch (err) {
      await queryRunner.rollbackTransaction()
    } finally {
      await queryRunner.release()
    }
