---
#-------------------------------
# Package: Jotai
#-------------------------------
- ENTRY:
  CATEGORY: Jotai

- ENTRY:
  EXPLAIN: インストール & 概要
  BODY: |
    ■ インストール

      npm install jotai

    ■ 概要

    ・Jotai は React 向けの軽量な状態管理ライブラリ
    ・Atom ベースのアプローチで、状態を細かく分割して管理可能
    ・シンプルな API で学習コストが低い
    ・React の Suspense や Concurrent Mode とも相性が良い
    ・TypeScript にも対応し、型安全な状態管理が可能

    ■ メソッド一覧

    ・atom: 状態の単位である atom を作成
    ・useAtom: atom の値と更新関数を取得
    ・useAtomValue: atom の値のみを取得
    ・useSetAtom: atom の更新関数のみを取得
    ・Provider: atom のコンテキストを提供

- ENTRY:
  CATEGORY: |
    atom

- ENTRY:
  EXPLAIN: atom 基礎
  BODY: |
    import { atom } from "jotai"

    export const countAtom = atom(0)
    export const countDerivedAtom = atom(0)

    export const citiesAtom = atom(["東京", "京都", "大阪"])
    export const citySelectedAtom = atom("")

    ■ atom

- ENTRY:
  EXPLAIN: atom 型定義
  BODY: |
    ■ 基礎

    function atom<Value>(initialValue: Value): PrimitiveAtom<Value>

    ■ 読み取り専用

    function atom<Value>(
      read: (get: Getter) => Value
    ): Atom<Value>

    ■ 派生 atom(読み取り/書き込み)

    function atom<Value, Args extends unknown[], Result>(
      read: (get: Getter) => Value,
      write: (get: Getter, set: Setter, ...args: Args) => Result,
    ): WritableAtom<Value, Args, Result>

    ■ 派生 atom(書き込み専用)

    function atom<Value, Args extends unknown[], Result>(
      read: Value,
      write: (get: Getter, set: Setter, ...args: Args) => Result,
    ): WritableAtom<Value, Args, Result>

- ENTRY:
  EXPLAIN: onMount
  BODY: |
    ■ onMount

      atom 作成後に一度だけ実行されるコールバックを登録

    ■ 例

    const anAtom = atom(1)
    anAtom.onMount = (setAtom) => {
      console.log('atom is mounted in provider')
      
      setAtom(c => c + 1)               // increment count on mount
      return () => { ... }              // return optional onUnmount function
    }

    const Component = () => {
      useAtom(anAtom)                   // マウント時にコール
      useAtomValue(anAtom)              // マウント時にコール

      useSetAtom(anAtom)                // マウント時にコールされない
      useAtomCallback(                  // マウント時にコールされない
        useCallback((get) => get(anAtom), []),
      )
      ...
    }

- ENTRY:
  EXPLAIN: atom 定義と Get & Set
  BODY: |
    ■ 値

      const priceAtom = atom(10)

    ■ 読み取り専用

      const readOnlyAtom = atom((get) => get(priceAtom) * 2)

    ■ 書き込み専用

      const writeOnlyAtom = atom(
        null,                             // `null` 書き込み専用
        (get, set, update) => {
          set(priceAtom, get(priceAtom) - update.discount)     // 1. 他の atom 書き込み可能
          set(priceAtom, (price) => price - update.discount)   // 2. 関数形式も可能
        },
      )

    ■ 読み取り/書き込み

      const readWriteAtom = atom(
        (get) => get(priceAtom) * 2,      // 読み取り
        (get, set, newPrice) => {
          set(priceAtom, newPrice / 2)    // 複数の atoms 書き込み可能
        },
      )

      export const addingCountDerivedAtom = atom(
        (get) => get(countDerivedAtom),            // Get(null にすれば WriteOnly)
        (get, set, num: number) => {               // Method(複数不可)
          set(countDerivedAtom, get(countDerivedAtom) + num)
        }
      )

    ■ 派生(他の atom の値を加工)

      export const doubledCountAtom = atom((get) => get(numberAtom) * 2)
      export const uppercaseAtom    = atom((get) => get(textAtom).toUpperCase())

- ENTRY:
  EXPLAIN: 非同期
  BODY: |
    ■ 非同期: 即時コール

    export const urlAtom = atom("http://localhost:5099/posts")

    export const fetchUrlAtom = atom(
      async (get) => {
        const response = await fetch(get(urlAtom))
        return await response.json()
      }
    )

    ■ 非同期: Lazyコール

    export const fetchDataAtom = atom("")

    export const fetchUrlLazyAtom = atom(
      (get) => get(fetchDataAtom),
      async (get, set) => {
        const response = await fetch(get(urlAtom))
        set(fetchDataAtom, await response.json())
      }
    )

- ENTRY:
  EXPLAIN: useMemoとの併用
  BODY: |
    ■ 目的

    ・props や状態に基づいて atom を動的に作成
    ・不要な再作成を防ぎ、パフォーマンスを最適化

    ■ 実装

      import { atom, useAtom } from 'jotai'
      import { useMemo } from 'react'

      const Component = ({ value }) => {
        const valueAtom = useMemo(() => atom({ value }), [value])
        const [state, setState] = useAtom(valueAtom)

        return (
          <div>{state.value}</div>  
        )
      }

- ENTRY:
  EXPLAIN: Abort Control(signal)
  BODY: |
    ■ 読み取り専用

    const readOnlyDerivedAtom = atom(
      async (get, { signal }) => { ... },  // signalで動作中断
    )

    ■ 派生非同期

    const writableDerivedAtom = atom(
      async (get, { signal }) => { ... },  // signalで動作中断
      (get, set, arg) => { ... },
    )

    ■ フルサンプル

    import { Suspense } from 'react'
    import { atom, useAtom } from 'jotai'

    const userIdAtom = atom(1)
    const userAtom = atom(async (get, { signal }) => {
      const userId = get(userIdAtom)
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/users/${userId}?_delay=2000`,
        { signal },
      )
      return response.json()
    })

    const Controls = () => {
      const [userId, setUserId] = useAtom(userIdAtom)
      return (
        <div>
          User Id: {userId}
          <button onClick={() => setUserId((c) => c - 1)}>Prev</button>
          <button onClick={() => setUserId((c) => c + 1)}>Next</button>
        </div>
      )
    }

    const UserName = () => {
      const [user] = useAtom(userAtom)
      return <div>User name: {user.name}</div>
    }

    const App = () => (
      <>
        <Controls />
        <Suspense fallback="Loading...">
          <UserName />
        </Suspense>
      </>
    )

    export default App

- ENTRY:
  CATEGORY: |
    メソッド

- ENTRY:
  EXPLAIN: useAtom()
  BODY: |
    ■ 目的

    ・atom の値と更新関数を取得

    ■ 実装

      const [count, setCount] = useAtom(countAtom)
      
      const [flag, setFlag] = useAtom(flagAtom)
      const handle = () => setFlag(true)

- ENTRY:
  EXPLAIN: useAtomValue()
  BODY: |
    ■ 目的

    ・atom の値のみを取得

    ■ 実装

      const count = useAtomValue(countAtom)    // 値
      const handle = () => console.log(count)

- ENTRY:
  EXPLAIN: useSetAtom()
  BODY: |
    ■ 目的

    ・atom の更新関数のみを取得

    ■ 実装

      const setFlag = useSetAtom(flagAtom)     // セッター
      const handle = () => setFlag(true)

- ENTRY:
  EXPLAIN: useAtomValue()
  BODY: |
    ■ 目的

    ・atom の値のみを取得

    ■ 実装

      const count = useAtomValue(countAtom)    // 値
      const handle = () => console.log(count)

- ENTRY:
  EXPLAIN: useSetAtom()
  BODY: |

    ■ 目的

    ・atom の更新関数のみを取得

    ■ 実装

      const count = useAtomValue(countAtom)    // 値
      const setCount = useSetAtom(countAtom)   // セッター
      const handle = () => setCount(count+1)

- ENTRY:
  EXPLAIN: useAtomCallback()
  BODY: |
    ■ 目的

    ・atom の値を取得するコールバックを作成

    ■ 実装

      import { useAtomCallback } from 'jotai/utils'
      import { useCallback } from 'react'
      import { countAtom } from './atoms'

      const logCount = useAtomCallback(
        useCallback((get) => {
          const count = get(countAtom)
          console.log('Current count:', count)
        }, []),
      )

      <button onClick={logCount}>Log Count</button>

- ENTRY:
  EXPLAIN: サンプル
  BODY: |
    ■ ディレクトリ構成

    /src
      /components
        Counter.tsx
      atoms.ts
      Component.tsx

    ■ atoms.ts

    import { atom } from "jotai"
      
    export const countAtom = atom(0)
    export const countDerivedAtom = atom(0)

    ■ Counter.tsx: 子コンポーネント

    import { useAtom } from "jotai"
    import { countAtom } from "../atoms"

    export const Counter = () => {
      const [value, setValue] = useState(0)
      const [_, setCounter] = useAtom(countAtom)

      const handleSetValue = () => { setCounter(value) }
      const handleOnChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setValue(Number(e.currentTarget.value))
      }

      return (
        <Row>
          <Div>カウント</Div>
          <Input defaultValue={value} onChange={handleOnChange} />
          <Button onClick={handleSetValue}>セット</Button>
        </Row>
      )
    }

    ■ Component.tsx: 親コンポーネント

    import { useAtom } from "jotai"
    import { countAtom } from "./atoms"
    import { Counter } from "./components/Counter"

    const Component = () => {
      const [count] = useAtom(countAtom)

      return (
        <Row>
          <Counter />
          <Div> カウント: {count} </Div>
        </Row>
      )
    }

- ENTRY:
  EXPLAIN: Excelスタイル連鎖更新
  BODY: |
    ■ Excelの連鎖参照を実現

    [atoms.ts]
    import { atom } from "jotai"
    export const atom_A = atom(0)
    export const atom_B = atom((get) => get(atom_A) * 2)
    export const atom_C = atom((get) => get(atom_B) * 2)

    [ExcelChainedReaction.tsx]
    const ExcelChainedReaction = () => {
      const [cell_A, setCell_A] = useAtom(atom_A)
      const [cell_B] = useAtom(atom_B)
      const [cell_C] = useAtom(atom_C)

      const handleOnChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setCell_A(Number(e.currentTarget.value))
      }

      return (
        <Flex>
          <Flex>
            <Input defaultValue={cell_A} onChange={handleOnChange} />
          </Flex>
          <Box> {cell_B} </Box>
          <Box> {cell_C} </Box>
        </Flex>
      )
    }

- ENTRY:
  CATEGORY: jotai/utils

- ENTRY:
  EXPLAIN: メソッドリスト
  BODY: |
    ■ メソッド一覧

    ・useAtomCallback: atom の値を取得するコールバックを作成
    ・atomWithStorage: ローカルストレージやセッションストレージと同期する atom を作成
    ・atomWithDefault: デフォルト値を持つ atom を作成
    ・selectAtom: atom の値を選択的に取得する派生 atom を作成
    ・splitAtom: 配列を分割して複数の atom にする
    ・freezeAtom: atom の値を変更不可にする
    ・debounceAtom: atom の更新をデバウンスする
    ・loadable: 非同期 atom の状態を管理するためのユーティリティ
    ・atomFamily: パラメータ化された atom を作成するユーティリティ
    ・scopeAtom: atom を特定のスコープに関連付けるユーティリティ

- ENTRY:
  EXPLAIN: atomWithStorage
  BODY: |
    ■ 解説

    ・ローカルストレージやセッションストレージと同期する atom を作成
    ・ページのリロード後も状態が保持

    ■ サンプル

    import { atomWithStorage } from 'jotai/utils'

    const darkModeAtom = atomWithStorage('darkMode', false)

    const App = () => {
      const [darkMode, setDarkMode] = useAtom(darkModeAtom)
      return (
        <button onClick={() => setDarkMode(!darkMode)}>
          {darkMode ? 'ライトモード' : 'ダークモード'}
        </button>
      )
    }

- ENTRY:
  EXPLAIN: atomWithDefault
  BODY: |
    ■ 解説

    ・他の atom の値が未設定（null や undefined）の場合にデフォルト値を提供する派生 atom を作成

    ■ サンプル

    import { atom, atomWithDefault } from 'jotai'
    import { atomWithDefault } from 'jotai/utils'

    const baseAtom = atom<string | null>(null)
    const derivedAtom = atomWithDefault(baseAtom, 'デフォルト値')

    const App = () => {
      const [value] = useAtom(derivedAtom) // null の場合は 'デフォルト値'
      return <div>{value}</div>
    }

- ENTRY:
  EXPLAIN: selectAtom
  BODY: |
    ■ 解説

    ・atom の値から特定の部分を選択的に取得する派生 atom を作成
    ・メモ化によりパフォーマンスが向上

    ■ サンプル

    import { atom } from 'jotai'
    import { selectAtom } from 'jotai/utils'

    const userAtom = atom({ name: 'John', age: 30 })
    const nameAtom = selectAtom(userAtom, (user) => user.name)

    const App = () => {
      const name = useAtomValue(nameAtom) // 'John'
      return <div>名前: {name}</div>
    }

- ENTRY:
  EXPLAIN: splitAtom
  BODY: |
    ■ 解説

    ・配列 atom を個別の atom に分割
    ・各要素を独立して操作できるように

    ■ サンプル

    import { atom } from 'jotai'
    import { splitAtom } from 'jotai/utils'

    const itemsAtom = atom([1, 2, 3])
    const itemAtomsAtom = splitAtom(itemsAtom)

    const App = () => {
      const itemAtoms = useAtomValue(itemAtomsAtom)
      return (
        <ul>
          {itemAtoms.map((itemAtom, index) => (
            <li key={index}>
              <ItemComponent itemAtom={itemAtom} />
            </li>
          ))}
        </ul>
      )
    }

- ENTRY:
  EXPLAIN: freezeAtom
  BODY: |
    ■ 解説

    ・atom の値を Object.freeze で凍結
    ・変更不可に
    ・イミュータビリティを強制

    ■ サンプル

    import { atom } from 'jotai'
    import { freezeAtom } from 'jotai/utils'

    const dataAtom = freezeAtom(atom({ a: 1, b: 2 }))

    const App = () => {
      const [data] = useAtom(dataAtom)           // data は凍結されているため変更不可
      return <div>{JSON.stringify(data)}</div>
    }

- ENTRY:
  EXPLAIN: debounceAtom
  BODY: |
    ■ 解説

    ・atom の更新をデバウンス
    ・指定された時間内に複数の更新が発生した場合、最後の更新のみを適用

    ■ サンプル

    import { atom } from 'jotai'
    import { debounceAtom } from 'jotai/utils'

    const inputAtom = debounceAtom(atom(''), 300)

    const App = () => {
      const [input, setInput] = useAtom(inputAtom)
      return (
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="デバウンス入力"
        />
      )
    }

- ENTRY:
  EXPLAIN: loadable
  BODY: |
    ■ 解説

    ・非同期 atom のロード状態（loading, hasError, data）を管理するためのユーティリティ

    ■ サンプル

    import { atom } from 'jotai'
    import { loadable } from 'jotai/utils'

    const asyncAtom = atom(async () => {
      const response = await fetch('/api/data')
      return response.json()
    })
    const loadableAtom = loadable(asyncAtom)

    const App = () => {
      const loadableState = useAtomValue(loadableAtom)
      if (loadableState.state === 'loading') return <div>Loading...</div>
      if (loadableState.state === 'hasError') return <div>Error</div>
      return <div>{JSON.stringify(loadableState.data)}</div>
    }

- ENTRY:
  EXPLAIN: atomFamily
  BODY: |
    ■ 解説

    ・パラメータに基づいて動的に atom を生成するユーティリティ
    ・同じパラメータに対しては同じ atom を返

    ■ サンプル

    import { atom } from 'jotai'
    import { atomFamily } from 'jotai/utils'

    const todoFamily = atomFamily((id: string) => atom({ id, text: '', completed: false }))

    const TodoItem = ({ id }: { id: string }) => {
      const [todo, setTodo] = useAtom(todoFamily(id))
      return (
        <div>
          <input
            value={todo.text}
            onChange={(e) => setTodo({ ...todo, text: e.target.value })}
          />
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={(e) => setTodo({ ...todo, completed: e.target.checked })}
          />
        </div>
      )
    }

- ENTRY:
  EXPLAIN: scopeAtom
  BODY: |
    ■ 解説

    ・atom を特定のスコープに関連付け
    ・異なるスコープ間で同じ atom を独立して使用できるように

    ■ サンプル

    import { atom } from 'jotai'
    import { scopeAtom } from 'jotai/utils'

    const countAtom = scopeAtom(atom(0), 'counterScope')

    const Counter = () => {
      const [count, setCount] = useAtom(countAtom)
      return (
        <div>
          <button onClick={() => setCount(count - 1)}>-</button>
          {count}
          <button onClick={() => setCount(count + 1)}>+</button>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: resetAtom
  BODY: |
    ■ 解説

    ・atom の値を初期値にリセットするためのユーティリティ

    ■ サンプル

    import { atom } from 'jotai'
    import { resetAtom } from 'jotai/utils'

    const countAtom = atom(0)
    const resetCountAtom = resetAtom(countAtom)

    const App = () => {
      const [count, setCount] = useAtom(countAtom)
      const reset = useSetAtom(resetCountAtom)
      return (
        <div>
          <button onClick={() => setCount(count + 1)}>Increment</button>
          <button onClick={reset}>Reset</button>
          <div>Count: {count}</div>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: atomWithStorage
  BODY: |
    ■ 解説

    ・atomWithStorage は、localStorage や sessionStorage と同期する atom を作成
    ・ページのリロードやブラウザの再起動後も状態が保持
    ・ストレージのキーとデフォルト値を指定

    ■ サンプル

    import { atomWithStorage } from 'jotai/utils'

    const countAtom = atomWithStorage('count', 0)

    function Counter() {
      const [count, setCount] = useAtom(countAtom)
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(c => c + 1)}>+1</button>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: atomWithDefault
  BODY: |
    ■ 解説

    ・atomWithDefault は、別の atom の値に基づいてデフォルト値を持つ atom を作成
    ・読み取り専用の atom で、依存する atom の値が変更されると自動的に更新

    ■ サンプル

    import { atom, atomWithDefault } from 'jotai/utils'

    const baseAtom = atom(1)
    const derivedAtom = atomWithDefault((get) => get(baseAtom) * 2)

    function App() {
      const [base, setBase] = useAtom(baseAtom)
      const derived = useAtomValue(derivedAtom)
      return (
        <div>
          <p>Base: {base}</p>
          <p>Derived: {derived}</p>
          <button onClick={() => setBase(b => b + 1)}>+1</button>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: selectAtom
  BODY: |
    ■ 解説

    ・selectAtom は、既存の atom から特定のプロパティや値を選択して新しい読み取り専用の atom を作成
    ・元の atom の変更を監視し、選択した部分のみを更新

    ■ サンプル

    import { atom, selectAtom } from 'jotai/utils'

    const userAtom = atom({ name: 'John', age: 30 })
    const nameAtom = selectAtom(userAtom, (user) => user.name)

    function UserProfile() {
      const name = useAtomValue(nameAtom)
      return <p>Name: {name}</p>
    }

- ENTRY:
  EXPLAIN: splitAtom
  BODY: |
    ■ 解説

    ・splitAtom は、配列を表す atom を個別の atom に分割
    ・各要素に対して個別の atom を作成し、配列の変更を個別の atom に反映

    ■ サンプル

    import { atom, splitAtom } from 'jotai/utils'

    const listAtom = atom(['item1', 'item2', 'item3'])
    const itemAtoms = splitAtom(listAtom)

    function ItemList() {
      const items = useAtomValue(itemAtoms)
      return (
        <ul>
          {items.map((itemAtom, index) => (
            <Item key={index} itemAtom={itemAtom} />
          ))}
        </ul>
      )
    }

    function Item({ itemAtom }: { itemAtom: PrimitiveAtom<string> }) {
      const [item, setItem] = useAtom(itemAtom)
      return <li>{item}</li>
    }

- ENTRY:
  EXPLAIN: freezeAtom
  BODY: |
    ■ 解説

    ・freezeAtom は、atom の値を Object.freeze で凍結し、変更不可に
    ・開発時に不変性を強制するのに役立つ

    ■ サンプル

    import { atom, freezeAtom } from 'jotai/utils'

    const dataAtom = freezeAtom(atom({ a: 1, b: 2 }))

    function DataComponent() {
      const data = useAtomValue(dataAtom)
      // data は凍結されているので変更不可
      return <p>Data: {JSON.stringify(data)}</p>
    }

- ENTRY:
  EXPLAIN: debounceAtom
  BODY: |
    ■ 解説

    ・debounceAtom は、atom の更新をデバウンス
    ・指定した遅延時間内に複数の更新が発生した場合、最後の更新のみを適用

    ■ サンプル

    import { atom, debounceAtom } from 'jotai/utils'

    const inputAtom = atom('')
    const debouncedInputAtom = debounceAtom(inputAtom, 500)

    function SearchInput() {
      const [input, setInput] = useAtom(inputAtom)
      const debouncedInput = useAtomValue(debouncedInputAtom)

      return (
        <div>
          <input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Search..."
          />
          <p>Debounced: {debouncedInput}</p>
        </div>
      )
    }

- ENTRY:
  EXPLAIN: loadable
  BODY: |
    ■ 解説

    ・loadable は、非同期 atom のロード状態を管理
    ・loading、hasError、data の状態を提供し、Suspense やエラーハンドリングを容易に

    ■ サンプル

    import { atom, loadable } from 'jotai/utils'

    const asyncDataAtom = atom(async () => {
      const response = await fetch('/api/data')
      return response.json()
    })
    const loadableDataAtom = loadable(asyncDataAtom)

    function DataComponent() {
      const data = useAtomValue(loadableDataAtom)

      if (data.state === 'loading') return <p>Loading...</p>
      if (data.state === 'hasError') return <p>Error: {data.error.message}</p>
      return <p>Data: {JSON.stringify(data.data)}</p>
    }

- ENTRY:
  EXPLAIN: atomFamily
  BODY: |
    ■ 解説

    ・atomFamily は、パラメータに基づいて動的に atom を作成するファミリーを生成
    ・同じパラメータに対しては同じ atom を返し、メモ化

    ■ サンプル

    import { atomFamily } from 'jotai/utils'

    const todoFamily = atomFamily((id: string) => atom({ id, text: '', completed: false }))

    function TodoItem({ id }: { id: string }) {
      const [todo, setTodo] = useAtom(todoFamily(id))
      return (
        <div>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={(e) => setTodo({ ...todo, completed: e.target.checked })}
          />
          <input
            value={todo.text}
            onChange={(e) => setTodo({ ...todo, text: e.target.value })}
          />
        </div>
      )
    }

- ENTRY:
  EXPLAIN: scopeAtom
  BODY: |
    ■ 解説

    ・scopeAtom は、atom を特定のスコープに関連付け
    ・異なるスコープ間で同じ atom を独立して使用できる

    ■ サンプル

    import { atom, createScope, scopeAtom } from 'jotai/utils'

    const myScope = createScope()
    const countAtom = scopeAtom(atom(0), myScope)

    function Counter() {
      const [count, setCount] = useAtom(countAtom, myScope)
      return (
        <div>
          <p>Count: {count}</p>
          <button onClick={() => setCount(c => c + 1)}>+1</button>
        </div>
      )
    }
