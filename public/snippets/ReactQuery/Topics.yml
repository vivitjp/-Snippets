---
#-------------------------------
# utilities
#-------------------------------
- KEY: utilities.query-key-factory.category
  CATEGORY: query-key-factory

- KEY: utilities.query-key-factory.要点
  EXPLAIN: 要点
  BODY: |
    ■ 要点

    ・インストール不要（React Query / TanStack Query のみで利用可能）
    ・query-key-factory = クエリキーを一箇所で生成する関数群
    ・キーの一貫性確保、再利用、invalidate/prefetch の管理が容易に
    ・同じキーの文字列/配列を各所で書かない
    ・パラメータ付与やネストを型安全に扱う

    ■ 簡単ルール

    ・キーは配列推奨（深い比較が容易）
    ・factory はルートキーを中心に小さく作る
    ・パラメータは末尾に置く（invalidate のマッチ制御が明確）
    ・生成関数を1箇所に置く（リネーム・リファクタ容易化）

- KEY: utilities.query-key-factory.実装例
  EXPLAIN: 実装例
  BODY: |
    ■ factory 定義

      const todosKeys = {
        all: ['todos'] as const,
        lists: () => [...todosKeys.all, 'lists'] as const,
        list: (listId: number) => [...todosKeys.lists(), 'list', listId] as const,
        item: (listId: number, itemId: number) => [...todosKeys.list(listId), 'item', itemId] as const,
      }

    ■ useQuery での利用

      const { data } = useQuery(todosKeys.list(1), () => fetchList(1))

    ■ invalidate / prefetch

      queryClient.invalidateQueries(todosKeys.lists())
      queryClient.prefetchQuery(todosKeys.list(2), () => fetchList(2))

    ■ 型取得(ReturnType)

      type ListKey = ReturnType<typeof todosKeys.list>   // readonly [..., number]

- KEY: utilities.lukemorales
  EXPLAIN: |
    @lukemorales/query-key-factory
  BODY: |
    ■ 導入

      npm: npm install @lukemorales/query-key-factory

    ■ factory 定義(Topics.yml)(同上)

      [src/library/queryKeys/todosKeys.ts]
      const todosKeys = {
        all: ['todos'] as const,
        lists: () => [...todosKeys.all, 'lists'] as const,
        list: (listId: number) => [...todosKeys.lists(), 'list', listId] as const,
        item: (listId: number, itemId: number) => [...todosKeys.list(listId), 'item', itemId] as const,
      }

    ■ 使い方

      import React from 'react'
      import { QueryClient, QueryClientProvider, useQuery } from '@tanstack/react-query'
      import { todosKeys } from '../../library/queryKeys/todosKeys'

      const queryClient = new QueryClient()

      async function fetchList(listId: number) {
        // 実際は fetch/API 呼び出しに置換
        return { id: listId, items: [{ id: 1, text: 'item A' }] }
      }

      function List({ listId }: { listId: number }) {
        const { data, isLoading, error } = useQuery(todosKeys.list(listId), () => fetchList(listId))
        if (isLoading) return <div>loading</div>
        if (error) return <div>error</div>
        return <pre>{JSON.stringify(data, null, 2)}</pre>
      }

      export default function TodosSample() {
        return (
          <QueryClientProvider client={queryClient}>
            <List listId={1} />
          </QueryClientProvider>
        )
      }

    ■ 型取得(同上)

      // invalidate
      queryClient.invalidateQueries(todosKeys.lists())

      // prefetch
      queryClient.prefetchQuery(todosKeys.list(2), () => fetchList(2))

    ■ 型取得(同上)

      type ListKey = ReturnType<typeof todosKeys.list>

    ■ @lukemorales/query-key-factory を使うと何が楽か:

    ・上のような factory をより短く・型安全に作れるヘルパーが提供される
      -> 冗長な as const や配列連結のボイラープレートが減る
    ・生成される型が読みやすくなるため、ReturnType やユーティリティ型との併用が楽

    ■ 運用上の注意:

    ・キーの形を後から変えると invalidate の挙動に影響するため、キー定義は慎重にリファクタする
    ・ルートキーを安易に増やさない（粒度は使い方に合わせて）
    ・ランタイムに文字列ベースで比較する処理と混ぜると意図しないマッチが起きることがある

- KEY: utilities.lukemorales.実装サンプル
  EXPLAIN: 実装サンプル
  BODY: |
    ■ src/library/queryKeys/todosKeys.ts

    export const todosKeys = {
      all: ['todos'] as const,
      lists: () => [...todosKeys.all, 'lists'] as const,
      list: (listId: number) => [...todosKeys.lists(), 'list', listId] as const,
      item: (listId: number, itemId: number) => [...todosKeys.list(listId), 'item', itemId] as const,
    }

    ■ src/lib/api/todos.ts: 架空 API に fetch を投げるラッパー（signal 対応）

    export type TodoItem = { id: number; title: string; completed: boolean }
    export type TodoList = { id: number; title: string; items: TodoItem[] }

    const API_BASE = 'https://api.example.com'

    export async function fetchList(listId: number, signal?: AbortSignal): Promise<TodoList> {
      const res = await fetch(`${API_BASE}/todos/${listId}`, { signal })
      if (!res.ok) throw new Error(`fetch failed: ${res.status}`)
      const todo = await res.json()
      return {
        id: todo.id,
        title: todo.title ?? `list-${listId}`,
        items: [{ id: todo.id, title: todo.title, completed: todo.completed }],
      }
    }

    export async function updateItem(listId: number, item: TodoItem): Promise<TodoItem> {
      const res = await fetch(`${API_BASE}/todos/${item.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(item),
      })
      if (!res.ok) throw new Error(`update failed: ${res.status}`)
      return res.json()
    }

    ■ src/pages/base/TodosSample.tsx: QueryClientProvider を含む最小コンポーネント

    import React from 'react'
    import { QueryClient, QueryClientProvider, useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
    import { todosKeys } from '../../library/queryKeys/todosKeys'
    import { fetchList, updateItem, TodoItem } from '../../lib/api/todos'

    const queryClient = new QueryClient()

    function List({ listId }: { listId: number }) {
      const qc = useQueryClient()

      const { data, isLoading, error } = useQuery(
        todosKeys.list(listId),
        ({ signal }) => fetchList(listId, signal) // fetchList に signal(abort) を渡す
      )

      const mutation = useMutation((item: TodoItem) => updateItem(listId, item), {
        onSuccess: () => {
          // 成功したら該当リストを再フェッチ/invalidate
          qc.invalidateQueries(todosKeys.list(listId))
        },
      })

      if (isLoading) return <div>loading</div>
      if (error) return <div>error</div>

      return (
        <div>
          <h3>{data?.title}</h3>
          <pre>{JSON.stringify(data?.items, null, 2)}</pre>

          <button
            onMouseEnter={() => {
              // ホバーで事前取得（prefetch）
              qc.prefetchQuery(todosKeys.list(listId + 1), () => fetchList(listId + 1))
            }}
          >
            Prefetch next list
          </button>

          <button onClick={() => qc.invalidateQueries(todosKeys.lists())}>Invalidate lists</button>

          <button
            onClick={() =>
              mutation.mutate({
                id: data!.items[0].id,
                title: data!.items[0].title + ' (updated)',
                completed: !data!.items[0].completed,
              })
            }
          >
            Update first item (mutation)
          </button>
        </div>
      )
    }

    export default function TodosSample() {
      return (
        <QueryClientProvider client={queryClient}>
          <List listId={1} />
        </QueryClientProvider>
      )
    }

    ■ 短い補足

    ・useQuery の queryFn 内で渡される { signal } を fetch に渡すと、コンポーネントアンマウント時や再フェッチでリクエストが中断される
    ・実運用では API_BASE を環境変数にし、エラーハンドリング/タイムアウト/リトライ設定を検討する
